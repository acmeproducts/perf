
Repo Report

Task: 

step 1: organize and rationalize criteria in this document below the marker    ####$ material to create checklist #####
  into a single outline formatted checklist with section/subsection/line item. each line item must be atomic in nature (e.g. single, indivisible statement that expresses one complete function, feature, need, or capability of a system or product. Atomic requirements are designed to be independently implementable, testable, and traceable, ensuring a clear pass or fail result for each requirement and simplifying processes like change management, impact analysis, and product de-scoping. 
Key Characteristics
Single Unit of Functionality: Contains one distinct piece of functionality, feature, or capability, avoiding multiple clauses or conjunctions. 
Indivisible: Cannot be broken down further into smaller, meaningful requirements. 
Independently Testable: Can be tested with a clear, measurable pass or fail result. 
Independently Implementable: Can be implemented as a standalone unit of work. 
Granular: Represents the most fundamental, detailed unit of a requirement. 
Why Atomic Requirements Are Important
Enhanced Traceability: Makes it easier to link requirements to design, testing, and implementation. 
Improved Change Management: Changes to a single atomic requirement affect only that one statement. 
Simplified Impact Analysis: Allows for precise analysis of what other requirements might be affected by a change. 
Clear Pass/Fail Testing: Enables definitive verification, reducing ambiguity in quality assessment. 
Precise De-scoping: Makes it easier to remove specific functionalities from a project's scope when needed. 
Better Planning: Each atomic requirement can be scheduled, prioritized, and valued for a single release. 
Increased Clarity: Fosters better understanding among stakeholders, developers, and testers. 
) and verifiable via user testing

  
Step 2: Assess every file in this repo and all previous versions for compliance with checklist in step 1.
  
If an orbital8 app or a derivative thereof then proceed to evaluate else update skip log for non-orbital8 app with filename and goto next file

Step 3: Output md
Checklist
  Section # | Section Name
  	Subsection # | Subsection Name
  		Line Item # |Line Item Description | Acceptance Criteria
Summary
table
  rows: Line Item # |Line Item Description | Acceptance Criteria
  columns: filename(s) with live link to repo and page
  content: status (meets (1), exceeds (2), not present (-1), bug (0))
  column total
  column average
  row total
  row average

Executive Summary
  reccomendation to get to full functionality in a consolidated instance:
   use <filename> as baseline
   build order
   r1 : prompt | spec
   r2: prompt | spec
   rn: prompt | spec

     
   ####$ material to create checklist #####
   
1. Consolidated Feature checklist

Interaction & Gestures
Implement the Quick Move/Focus navigation package: Eliminate regressions by preventing the triangular tap zone from advancing two images,  and relying on the hub as the focus-mode toggle. All stack, details button, folder button, favorites, trash can icon all work consistently with no degredation

Search, Tagging & Selection
Broaden search to filenames, timestamps, metadata (including PNG text), apply the three-pass (#modifier → positive → exclusion) pipeline, keep results consistent between grid and stage, surface #favorite, preserve stage ordering in grid, and leave selections active until the user clears the pill.

Rework the search helper overlay so desktop users can click modifiers without losing the menu and reposition/dismiss it to stop colliding with the favorites control.

Redesign tagging UI/UX: use black text, show assigned tags with removable chips above the input, list session tags below with their own “x,” mirror the layout in bulk edit, and surface new tags instantly with no extra confirmation.

UI Layout & Controls
While in focus mode only a bottom-center favorite ❤️ icon filled red as shown when selected when off - not selected  empty with grey fill there is no circular button or visible click/tap area however icon click area must be simple for user to click or tap, toggle metadata directly on icon click/tap, persist the flag, and make it searchable via #favorite.

Modals & Export:Simplify export to run entirely off local state with a running success/fail counter instead of a scrolling log.

Fix modal ergonomics: make details/grid modals draggable and resizable, double-click to reset (max/full-screen), and ensure bulk tag entry shows chips immediately without extra apply/cancel steps.

Performance, Caching & Sync
Stand up the three-tier caching and instantaneous navigation flow (in-memory LRU, IndexedDB warm cache, cloud fetches), optimistic UI updates, and unified background sync worker.

Deliver the sync overhaul: inline blob workers, lifecycle flush handshake, 750 ms debounce for steady-state metadata edits, per-file batching, OneDrive GET–merge–PUT upserts, revamped IndexedDB stores (syncQueue/metadata/folderCache/pngText/syncMeta), PNG zTXt inflation, periodic eviction metrics, and keep the UI “no-touch” surfaces intact.

Guard against cross-browser staleness by forcing every manifest flush to publish a version higher than the remote marker before persisting.

Diagnostics & Logging
Ship the SyncDiagnostics workflow: console helper returning a shareable JSON report, toast coordination, and a footer log button so mobile users can open the report without dev tools.

Guardrails & Release Tracking
Respect immutable areas (provider selection, auth, folder chooser, overall look/feel), keep solutions personal-scale, and update header/footer annotations with timestamp, version bump, and change summary for each release.
Shareable URL’s
Ship with permanent urls for image and thumbnail display
Long-Term UI Architecture
Pursue the UI revamp roadmap: extract a headless core with reusable components/state, then experiment with the five proposed interfaces (progressive disclosure, integrated dashboard, task modes, casual “Tinder,” guided assistant) accessible via a switcher page.

2. Detailed Feature checklist
1. Assess navigation and display
a. Storage provider selection
b. Auth
c. Folder selection
d. Sort mode
inbox/in
keep/priority
maybe/out
trash/recycle
Trash Can Icon
e. Stack to Stack and Stack to Itself behavior Triangle Zones
For Each Active Stack
-Flick
-Tap
-Click
 Top to
Bottom
Left
Right
Top
Bottom to
Top
Left
Right
Bottom
Left to 
Top
Right
Bottom
Left
Right
Top
Bottom 
Left
Right
g. Hub Zone
Click
Tap
h. Stack counter if not active tab and single click/tap then
Mark previous active stack inactive
Mark current stack active
Change display
Change image to first image in active stack
I. If stack counter active and single tap/click then open grid modal and auto select first image.
If click or tap stack counter in grid modal then select all images and update items selected pill counter, if already selected click x to deselect and reverse effect of select
Search: The helper box needs to be simplified. 
No chips 
When the user clicks on a special item like #favorite it appends the search term and the helper closes
The X on the helper doesn't work it needs to work so the user can cancel the operation if they change their mind, if they want to add another special item they click on the 'i' again
Implement zero items found by showing 0 in the stack counter and items selected and no images displayed in the grid
When a search has been completed the  images that meet the criteria MUST BE PRE-SELECTED with a BLUE OUTLINE and the items selected chip is updated.
When user selects # currently all images selected it should behave as a zero items found result until it matches a tag or a special selection like #favorite or #content
J. Tags
TAGS: the look, feel, functions of the details Tag tab and the bulk tab assignment/editing must be identical, ideally the same code would be called as a shared module of some sort
Here is the standard layout of the TAG Modal
Line 1: //Text//"Assigned Tags"
Line 2: <chips with an x>.....
Line 3: //Entry Field//[Enter tags separated by commas - if a tag does not start with a # then PREPEND # before updating ASSIGNED TAGS WHEN THE USER HITS ENTER - if it does start with # then tag as is]
Line 4://Text// "Recently Used Tags"
Line 5: <chips with an x>...
All input text is black 
Chips use standard format size, color, shape, font, behavior
K. Focus mode
1.Stack Switcher 
Single tap/click, Stack switcher Modal
2.Details Button
Single click
Info
Clickable permanent url
Tags
Same as bulk tag
Notes


Meta


Close 
3. Navigation
Left
back/left <move/display>
-Flick
-Tap
-Click
Hub Toggle 
-Flick
-Tap
-Click
Right
-Flick
-Tap
-Click
item#/# of items
-Tap
-Click
Favorite Icon ❤️
Size
Large Click Zone
Toggle on state
Display 
Action 
Toggle off State
Display 
Action
Trash Can (Click or Tap)
Move current image to storage provider recycle bin (toast confirm yes/no)
Display next available image in stack or display no more images message




3. Official Development Standards
All development, starting from this point forward, must adhere to the following standards without exception.
Standard
Requirement
Baseline Integrity
We have lost our baseline once it is established this section will be updated then No release may introduce a functional or visual regression from this baseline unless it is an explicit, approved change.
Single File Architecture
Each version must be a single, self-contained HTML file. All CSS and JavaScript must be inline.
Net New Canvas
All development for a new version must occur in a new, clean canvas.
Versioning
A comment must be placed at the top of the HTML file (before <!DOCTYPE html>) and in a <footer id="master-footer"> element on every screen, containing the exact release name and timestamp. There must be a link to synch log and a link to reset folder from cloud reload
No Console Reliance
The application must be fully functional in an environment where a developer console is not available. Code must be free of syntax and runtime errors upon delivery. A synch log is available via a link in the footer that is a continuous readout of app activity and synch behavior with a functional copy to clipboard, download, and clear buttons
Execution Protocol
All changes will be executed according to the following, mandatory four-step process: 1. Prescribe: The developer will state the exact, literal, atomic changes required for a release in a numbered list and request approval before proceeding. 
 checklist. 2. Approval: The user must approve the prescribed changes before work can begin. 3. Execute: The developer will apply only the approved changes to a pristine copy of the baseline file and include in the comments - releases notes which contain the numbered list of approved changes such that each line item can be validated with a test plan. 4. Validate: The developer must run both a linter and a diff check on the final file. The diff must confirm that only the prescribed changes were made. If either check fails, the developer will retry by rolling back to the baseline and reapplying add change and delete actions to the code base to affect the prescribed and approved outcomes without error and passing quality assurance


2. Do not make any other changes. 
Do not change storage provider selection, auth, folder selection, UI navigation or display behavior in sort or focus mode.
3. Critical Function Checklist
do not modify storage provider selection screen, auth, folder selection, look and feel of UI, no regressions. Please ensure comments are updated with timestamp and list of changes, please ensure footers are updated with correct version and updated timestamp matching comments

1.  Unreliable Synchronization (OneDrive and Google Drive).
Incremental Change: Background sync worker is event driven and fires immediately after any metadata change, rather than waiting for the session to end. This makes data saving reliable.
Background worker to process its queue of pending changes sequentially (one at a time), waiting for a success confirmation before starting the next. This prevents race conditions during bulk operations.
CURRENTLY MULTIPLE VERSIONS OF ORBITAL8-STATE.JSON EXIST FOR A GIVEN FOLDER IDENTIFY THIS BUG AND HOW TO CORRECT IT
Huge deficiency


4. UNIFIED CODE BASE provider-specific code into a unified DataManager with provider "adapters." EXCEPT FOR Storage Provider Selection, Auth, and Folder Selection.
5.  Implement "Drag and Drop Reordering" in the grid view, including visual feedback (blue selection outline, orange drop target outline

6. Permanent URL
Updated Google Drive file listings and ID-based fetches to request webViewLink, persist a durable view URL, and keep the API download link for fallbacks. 
Revised Google Drive fallback image selection to try the permanent link first and only use API downloads if necessary. 
Ensured CSV exports reuse the permanent Google Drive URL format for the “Direct Image URL” column.
7. Device b not showing changes made on device a
The “Recycle/Trash” behavior and the mismatched priority counts both point to the same underlying sync gap: Device A is successfully pushing stack mutations (stack:move to "priority"/"out"), but it is not rehydrating the latest stack metadata from Google Drive after those pushes. Without a pull/rehydrate step, the UI never reflects remote changes (including priority counts), so Device A’s folder view remains stale even though it says “fetching from cloud.”
Device B’s shorter log proves the backend is storing the new stack state, but Device A isn’t consuming it. The priority-count mismatch therefore isn’t a separate bug; it’s a symptom of the same missing inbound-sync/rehydration logic that also keeps the recycle stack from appearing.
To confirm, we should log every inbound fetch (timestamp, request params, number of stack records returned), any filtering/merge decisions, and the resulting UI state (count per stack, last applied stackSequence). That instrumentation will tell us whether the pull never happens, the payload is empty, or the merge logic is discarding it.
8. Major Syncing Requirements 
analysis-v9-cross-browser-sync.md is centered on diagnosing stale metadata caused by reusing the same folder cloudVersion across browsers and recommends ensuring each flush bumps the version marker beyond what peers already cached.
Requirement 1 – Fast cloud-vs-internal freshness check
The analysis calls out the need for monotonically increasing version markers but does not describe any mechanism for performing a lightweight comparison that would let an internal store bypass expensive hydration when it is already ahead of the cloud state. Adding explicit guidance on how to short-circuit hydration (for example, by comparing version headers before attempting to load manifest contents) would make the plan satisfy this requirement.
Document lightweight version gating 
Requirement 2 – Incremental updates when the cloud is ahead
The document notes that Browser B skipped the manifest diff entirely because it thought the versions matched, but it never prescribes how to scope downstream work so that, when the cloud version truly is ahead, only incremental additions/changes/deletes are applied locally. Detailing the expected delta-application flow (e.g., reusing manifest diffs and pruning deleted entries) would ensure the sync remains efficient once version bumps are reliable.
9. Synch analysis
# v9 cross-browser sync diagnosis
## Observed symptoms
- Browser A (1:46–1:48 AM log) applied four stack mutations and two Drive recycle operations.
- Browser A persisted those updates (`manifest:update` and `foldersync:version:bump`) but only advanced the folder version marker to **1**.
- Browser B opened minutes later and hydrated its cache because its locally stored folder state was already at version **1**. As a result, it skipped downloading Browser A's manifest diff and showed the pre-change state.
## Root cause
We only bump a folder's `cloudVersion` monotonically by **+1** from whatever is already in IndexedDB. When two browsers start from the same cached state (version 1) and one of them flushes first, it reuses the same target version (1). The second browser still sees version 1 locally, so it believes nothing has changed and retains stale metadata. The manifest diff never applies until a later flush happens to push version 2+ or a full resync is forced.
In short, the folder version marker is not guaranteed to increase beyond the value other browsers already cached, so peers cannot detect new work.
## Remediation options
### 1. Use strictly increasing timestamps for version markers
- **Change**: Replace the `localVersion + 1` increment in `FolderSyncCoordinator.recordLocalFlush` with `Math.max(Date.now(), existing.cloudVersion + 1)` and persist that value.
- **Pros**: Guarantees each flush produces a unique, increasing version—even across multiple browsers or tabs that share stale values.
- **Cons**: Versions become large timestamps, which may be harder to reason about and could expose clock skew between devices. Requires ensuring server/storage accepts large integers.
### 2. Force remote version bumps when reusing an existing value
- **Change**: Detect when `nextVersion` equals the current remote version and increment again (e.g., `if (nextVersion <= existing.cloudVersion) nextVersion = existing.cloudVersion + 1`).
- **Pros**: Keeps versions as small integers while guaranteeing progress. Minimal schema impact.
- **Cons**: Still depends on the last persisted cloud value—if the provider write silently ignores repeated values, we can regress. Needs defensive handling when provider overwrites the version marker concurrently.
### 3. Derive version from manifest content hash
- **Change**: Hash the pending manifest payload and store that as the version (or pair it with an increment). Peers detect differences even when numeric versions collide.
- **Pros**: Automatically reflects real data changes and avoids relying solely on counters.
- **Cons**: Requires manifest compare logic and storage of hashes. Slightly heavier computation and introduces extra state to sync.
## Recommendation
Option 2 provides the quickest, least invasive fix: enforce `nextVersion > existing.cloudVersion` before pushing the marker. Pair it with an integration test that exercises two browser caches to ensure the second client downloads changes immediately.
10. Tags and notes (bulk in grid and single in details)
Introduced reusable TagService, TagEditor, and NotesEditor utilities so chip input, inline removal, and note/rating edits update all targeted files instantly while keeping the shared tag cache in sync.

Rewired the details panel’s Tags and Notes tabs to render the new editors with multi-selection messaging, ensuring updates apply across the active selection once per change.

Added a bulk Notes action alongside the existing Tag control and wired it through the shared editors so dialog saves propagate notes and ratings to every selected image.
11. Test plan
To be done with google drive AND one drive

1.0 Setup & Initial State
Authenticate: Successfully authenticate with the storage provider.
Folder Selection:
OneDrive: Navigate to a parent folder, then select a child folder containing multiple images.
Google Drive: Select a folder containing multiple images.
Load Folder: Verify that the folder loads successfully and the first image is displayed on the main stage in the "In" stack.
2.0 Main View & Focus Mode Interaction
6. Initial Sort:
7. Flick Image 1 up to the priority/keep stack.
8. Flick Image 2 right to the out/maybe stack.
9. Flick Image 3 down to the trash/recycle stack.
10. Flick Image 4 left (back to the in/inbox stack).
11. Focus Mode Navigation (in/inbox stack):
12. Open the "In" stack grid.
13. Click into Focus Mode.
14. Swipe left three times (navigating forward through the images).
15. Exit Focus Mode.
16. Stack Navigation & Validation:
17. Swipe to the priority/keep stack.
18. Swipe to the out/maybe stack.
19. Swipe to the trash/recycle stack.
20. Swipe back to the in/inbox stack.
21. Focus Mode Deletion:
22. Click back into Focus Mode.
23. Swipe right four times (navigating backward).
24. Click the delete button twice, removing two images.
25. Exit Focus Mode.
3.0 Details Panel Validation
26. Open Details: Click the Details button for the current image.
27. Tag Management:
28. Navigate to the Tags tab.
29. Create a new tag. Verify the text entered in the input box is black.
30. Select an existing tag from the "Tags in this Folder" list to apply it.
31. Remove a tag that has just been applied.
32. Notes & Ratings:
33. Navigate to the Notes tab.
34. Enter a note. Verify the text entered is black.
35. Rate Quality and Content both 3 stars.
36. Change both ratings to 5 stars.
37. Change the Quality rating to 1 star.
38. Info & Metadata:
39. Navigate to the Info tab.
40. Verify the filename is a clickable link that opens the source image in a new tab.
41. Verify the date, time, and size are listed correctly.
42. Navigate to the Metadata tab.
43. Confirm that "Prompt" is the first row in the table.
44. Confirm that "Model", "Seed", and "Negative Prompt" are listed in that order.
45. Confirm that all priority/keep fields have a functional, orange copy button.
46. Confirm the rest of the metadata fields are displayed correctly.
47. Close Details Panel.
4.0 Grid Mode & Bulk Actions
48. Stack Navigation & Grid Entry:
49. Navigate through the "In", "Out", "priority/keep", and "Trash" stacks.
50. Open the grid for the trash/recycle stack.
51. Grid Move & Validation:
52. Verify the single image in the trash/recycle stack is highlighted with a blue outline.
53. Click the Move button and select the in/inbox stack.
54. Verify the image is removed from the Trash grid.
55. Close the grid, switch to the in/inbox stack.
56. Verify the moved image is now displayed on center stage.
57. Flick & Grid Validation:
58. Flick the current image to the priority/keep stack.
59. Open the grid for the priority/keep stack.
60. Verify the image just moved is the first item in the grid.
61. Selection Logic:
62. Select the second image in the grid.
63. De-select the first image (which was auto-selected).
64. Close the grid. Verify the second image is now on center stage and is the new first item in the priority/keep stack.
65. Bulk Move & Reordering:
66. Switch to the in/inbox stack and open the grid.
67. De-select the first auto-selected image.
68. Select the next three images.
69. Click Move and select the in/inbox stack.
70. Verify the three selected images are now the first three items in the grid, in alphabetical order.
71. Verify the former first image is now the fourth item.
72. Search & Delete:
73. Search for the tag created in step 3.2.
74. Verify the tagged image appears by itself and is pre-selected.
75. Close the grid. Verify the tagged image is on center stage.
76. Re-open the grid and search for the same tag again.
77. Click the Delete button.
78. Confirm the action in the dialog box.
79. Verify the API request is correct for the provider's trash/delete functionality.
80. Verify the grid is now empty (as the only searched item was deleted).
81. Folder Move:
82. Clear the search and select the first three images in the "In" stack.
83. Click the Folder button and move them to a different destination folder.
84. Navigate to the destination folder.
85. Verify the three images are at the top of the "In" stack in grid mode.
86. Enter Focus Mode and verify they are in the correct position.
87. Export:
88. Select the next three images.
89. Click the Export button.
90. Verify the modal shows a progress counter and percentage.
91. Verify the CSV file is created and contains all appropriate columns, including a valid source URL and correctly parsed metadata.
92. Close the modal.
93. Advanced Selection:
94. Select three images.
95. Verify the selection pill counter shows "3 selected".
96. Click the "X" on the pill counter. Verify the selection is cleared.
97. Click the pill counter itself. Verify all images in the grid are now selected.
98. Move all images to the out/maybe stack.
99. Empty Stack Navigation:
100. Verify the "stack is empty" message appears.
101. Click the button to change stacks.
102. Verify the next clockwise, non-empty stack is selected.
5.0 Final Focus Mode Validation
103. Navigate & Switch:
104. Change to the out/maybe stack.
105. Enter Focus Mode.
106. Click the stack name in the top-left corner and switch to the priority/keep stack.
107. Verify Image:
108. Confirm the image displayed is the original "test" image (Image 1 -> Trash -> In -> priority/keep).
109. Final State Check:
110. Exit Focus Mode.
111. Flick the current image to the in/inbox stack.
112. Click into the in/inbox stack.
113. Verify that this same image is now displayed on center stage.
