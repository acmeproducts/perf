<!-- Raw House Music Studio - v15.0 - 2025-10-12 04:15 AM PDT -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raw House Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1f2937;
            --control-light: #fcd34d;
            --kick-color: #ef4444; /* Red, now DRUM HIT */
            --clap-color: #3b82f6; /* Blue */
            --hh-color: #f97316; /* Orange */
            --oh-color: #8b5cf6; /* Violet */
            --perc-color: #2dd4bf; /* Teal */
            --backtrack-color: #a855f7; /* Violet */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        .step-button {
            transition: all 0.05s ease;
            height: 2rem;
            min-width: 1rem;
        }
        .step-button:active {
            transform: scale(0.95);
        }
        .step-active {
            box-shadow: 0 0 10px var(--control-light), 0 0 5px var(--control-light) inset;
        }
        .glow-shadow {
            box-shadow: 0 0 10px rgba(252, 211, 77, 0.5);
        }
        .control-panel {
            background-color: var(--bg-dark);
        }
        .track-label {
            width: 7rem;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .track-muted {
            opacity: 0.3;
        }
        .track-slider {
            -webkit-appearance: none;
            height: 6px;
            background: #4b5563;
            border-radius: 3px;
            cursor: pointer;
            width: 100%;
        }
        .track-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fcd34d;
            cursor: pointer;
        }
        .recording-active {
            animation: pulse-red 1s infinite alternate;
        }
        @keyframes pulse-red {
            from { opacity: 1; }
            to { opacity: 0.5; }
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 10px;
        }
        /* Custom styles for simplified controls */
        .simplified-control-spacer {
            width: 25%;
            margin-right: 1rem; /* Matches space-x-4 from parent */
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-8 flex flex-col items-center">

    <div id="app" class="w-full max-w-6xl bg-gray-800 p-4 sm:p-6 rounded-xl shadow-2xl space-y-6">

        <!-- Control Bar (Horizontal Compression) -->
        <div class="control-panel p-3 rounded-lg flex flex-wrap gap-4 justify-between items-center">
            
            <!-- Left Group: Play/Stop/Record -->
            <div class="flex items-center gap-3 flex-shrink-0">
                <button id="togglePlay" class="px-4 py-2 font-bold rounded-full text-gray-900 glow-shadow hover:opacity-90 transition-colors text-sm"
                        style="background-color: var(--control-light);">
                    START
                </button>
                <div class="flex items-center gap-3 bg-gray-900/40 px-3 py-2 rounded-full">
                    <button id="toggleRecord" class="px-3 py-2 font-bold rounded-full text-white bg-red-600 hover:bg-red-700 transition-colors text-xs">
                        <span id="recordIcon">REC</span>
                    </button>
                    <div class="flex flex-col text-[10px] sm:text-xs text-gray-300 font-mono leading-tight">
                        <div class="flex items-center gap-2">
                            <span id="recordLed" class="block w-2.5 h-2.5 rounded-full bg-gray-500"></span>
                            <span id="recordStatusLabel" class="uppercase tracking-wide">Standby</span>
                        </div>
                        <span id="recordTimecode" class="text-xs sm:text-sm">00:00</span>
                    </div>
                </div>
            </div>


            <!-- Middle Group: BPM/Grit/Drum Controls -->
            <div class="flex flex-wrap gap-4 items-center flex-grow min-w-[300px] sm:min-w-[400px]">
                <!-- BPM Control -->
                <div class="flex items-center space-x-2 flex-grow min-w-[150px]">
                    <label for="bpmSlider" class="text-gray-400 text-sm flex-shrink-0">BPM (<span id="bpmValue">125</span>)</label>
                    <input type="range" id="bpmSlider" min="1" max="225" value="125" step="1" 
                           class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- DRUM Volume Control -->
                <div class="flex items-center space-x-2 flex-grow min-w-[150px]">
                    <label for="drumVolumeSlider" class="text-gray-400 text-sm flex-shrink-0">DRUM VOL (<span id="drumVolumeValue">70</span>)</label>
                    <input type="range" id="drumVolumeSlider" min="1" max="100" value="70" step="1" 
                           class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
            
            <!-- Right Group: Grit/Decay/Backing Track -->
            <div class="flex flex-wrap gap-4 items-center flex-grow min-w-[300px] sm:min-w-[400px]">
                
                <!-- DRUM Decay Control -->
                <div class="flex items-center space-x-2 flex-grow min-w-[150px]">
                    <label for="drumDecaySlider" class="text-gray-400 text-sm flex-shrink-0">DRUM DECAY (<span id="drumDecayValue">50</span>)</label>
                    <input type="range" id="drumDecaySlider" min="1" max="100" value="50" step="1" 
                           class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Distortion Control -->
                <div class="flex items-center space-x-2 flex-grow min-w-[150px]">
                    <label for="gritSlider" class="text-red-400 text-sm flex-shrink-0">GRIT (<span id="gritValue">50</span>)</label>
                    <input type="range" id="gritSlider" min="1" max="100" value="50" step="1" 
                           class="w-full h-2 bg-red-500 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <button id="toggleBacktrackPanel" class="px-3 py-2 text-white text-sm rounded-md bg-violet-600 hover:bg-violet-700 transition-colors flex-shrink-0">
                    <span id="backtrackLabel">Load Backing Track</span>
                </button>
            </div>
        </div>

        <!-- Sequencer Grid Container -->
        <div class="space-y-4 max-h-[60vh] overflow-y-auto pr-2" id="sequencerContainer">

            <!-- Track UIs generated here -->

        </div>

        <div id="recordingPreviewCard" class="hidden bg-gray-900 border border-red-500/60 rounded-xl p-4 space-y-3">
            <div class="flex items-center justify-between">
                <h3 class="text-sm font-semibold text-red-300 uppercase tracking-wide">Recording Preview</h3>
                <span id="recordingPreviewStatus" class="text-xs text-gray-400"></span>
            </div>
            <audio id="recordingPreviewAudio" controls class="w-full rounded-lg"></audio>
            <div class="flex flex-wrap gap-3">
                <button id="saveRecording" class="px-4 py-2 text-sm font-semibold rounded-md bg-emerald-500 hover:bg-emerald-600 text-gray-900 transition-colors">Save Take</button>
                <button id="discardRecording" class="px-4 py-2 text-sm font-semibold rounded-md bg-gray-700 hover:bg-gray-600 text-gray-100 transition-colors">Discard</button>
            </div>
        </div>
        
        <!-- Backing Track Uploader Panel -->
        <div id="backtrackPanel" class="mt-4 p-4 rounded-lg border border-violet-600 hidden">
            <h3 class="text-xl font-bold text-violet-400 mb-3">Backing Track Loader</h3>
            
            <!-- Sync/Speed Control -->
            <div class="mb-4 flex flex-wrap gap-4 items-center text-white text-sm bg-gray-700 p-3 rounded-lg">
                <label class="font-semibold text-violet-300">Playback Mode:</label>
                <div class="flex items-center space-x-2">
                    <input type="radio" id="syncMode" name="backtrackMode" value="sync" checked class="text-violet-500 focus:ring-violet-500">
                    <label for="syncMode">Tempo Sync (4 Bar Loop)</label>
                </div>
                <div class="flex items-center space-x-2">
                    <input type="radio" id="originalMode" name="backtrackMode" value="original" class="text-violet-500 focus:ring-violet-500">
                    <label for="originalMode">Original Speed</label>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                <input type="url" id="audioUrlInput" placeholder="Paste Audio URL (.mp3/.wav)" class="flex-grow p-2 rounded-md bg-gray-700 text-white placeholder-gray-400 border border-gray-700 focus:border-violet-500 focus:outline-none">
                <input type="file" id="audioFileInput" accept="audio/*" class="w-full sm:w-auto text-gray-400 p-2 rounded-md bg-gray-700 cursor-pointer border border-gray-700">
            </div>
            <div class="mt-3 text-sm text-gray-400" id="backTrackStatus">Status: Ready.</div>
        </div>

    </div>

    <!-- Master Footer -->
    <footer id="master-footer" class="fixed bottom-0 left-0 right-0 p-2 text-center text-xs text-gray-500 bg-gray-900 border-t border-gray-700">
        v15.0 | 2025-10-12 04:15 AM PDT
    </footer>

    <script>
        const NUM_STEPS = 16;
        const CLAP_NOISE_DURATION = 0.05;
        const DECAY_RANGE = 0.5;
        
        // --- Global Audio Variables & State ---
        let audioContext;
        let isPlaying = false;
        let isRecording = false;
        let currentStep = 0;
        let nextNoteTime = 0.0;
        let timerID = 0;
        let backTrackSource = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingTimerId = null;
        let recordingStartTime = null;
        let recordingPreviewUrl = null;
        let recordingDestination = null;
        let recorderWarningShown = false;
        let recorderSupportLogged = false;

        const customSampleCache = new Map();
        const customSampleLoads = new Map();

        // --- Audio Nodes ---
        let masterGainNode;
        let distortionNode;
        let backTrackGain;

        // --- Drum Sound Options for the unified DRUM HIT Track ---
        // 5 highly-normalized, distinct sounds.
        const drumHitOptions = [
            // KICK: Deep Sine for classic house thump
            { value: 'deepKick', label: 'Deep Kick (Sine)', gainMult: 1.5, baseDecay: 0.4 }, 
            // SNARE: Classic noise-based snare drum
            { value: 'snareHit', label: 'Snare Hit (Noise/Tone)', gainMult: 1.0, baseDecay: 0.2 }, 
            // RIM/CLAVE: High frequency, short tone for rhythmic accents
            { value: 'rimShot', label: 'Rim Shot/Clave (Tone)', gainMult: 0.9, baseDecay: 0.05 }, 
            // TAIKO: Low resonant drum for fills
            { value: 'taikoDrum', label: 'Low Taiko (Tonal)', gainMult: 1.1, baseDecay: 0.5 },
            // CYMBAL: Washed highpass noise for sizzle
            { value: 'cymbalSiz', label: 'Cymbal Sizzle (Noise)', gainMult: 0.6, baseDecay: 1.0 }, 
        ];

        // --- Sequencer State & Defaults (Bass Track Removed) ---
        const sequencer = {
            drumHit: { pattern: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], color: 'var(--kick-color)', gain: 1.0, muted: false, 
                        params: { 
                            id: 'decay', label: 'Decay', unit: 's', min: 0.01, max: DECAY_RANGE, default: 0.1, step: 0.01, 
                            type: 'select', options: drumHitOptions 
                        } 
                    }, 
            clap: { pattern: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], color: 'var(--clap-color)', gain: 0.7, muted: false, decay: 0.1 },
            hihat: { pattern: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], color: 'var(--hh-color)', gain: 0.7, muted: false, decay: 0.05 },
            openhat: { pattern: [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], color: 'var(--oh-color)', gain: 0.7, muted: false, decay: 0.3 },
            perc: { pattern: [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], color: 'var(--perc-color)', gain: 0.7, muted: false, decay: 0.1 },
        };

        // --- Utility Functions ---

        function ensureTrackSampleState(track) {
            if (!track) return;
            if (!track.sample) {
                track.sample = {
                    mode: 'preset',
                    presetId: null,
                    fileName: null,
                    url: null,
                    audioBuffer: null,
                };
            } else {
                track.sample.mode = track.sample.mode || 'preset';
                track.sample.presetId = track.sample.presetId || null;
                track.sample.fileName = track.sample.fileName || null;
                track.sample.url = track.sample.url || null;
                track.sample.audioBuffer = track.sample.audioBuffer || null;
            }
        }

        async function fetchSampleBuffer(url) {
            if (!url) {
                throw new Error('Sample URL missing.');
            }

            if (customSampleCache.has(url)) {
                return customSampleCache.get(url);
            }

            if (customSampleLoads.has(url)) {
                return customSampleLoads.get(url);
            }

            initAudio();

            if (!audioContext) {
                throw new Error('Audio context unavailable while restoring custom sample.');
            }

            const pendingLoad = fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status} while fetching sample.`);
                    }
                    return response.arrayBuffer();
                })
                .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer.slice(0)))
                .then(decoded => {
                    customSampleCache.set(url, decoded);
                    customSampleLoads.delete(url);
                    return decoded;
                })
                .catch(error => {
                    customSampleLoads.delete(url);
                    throw error;
                });

            customSampleLoads.set(url, pendingLoad);
            return pendingLoad;
        }

        function applyTrackSnapshot(trackId, snapshot) {
            const track = sequencer[trackId];
            if (!track || !snapshot) return Promise.resolve();

            if (Array.isArray(snapshot.pattern)) {
                for (let i = 0; i < NUM_STEPS; i++) {
                    track.pattern[i] = snapshot.pattern[i] ? 1 : 0;
                }
            }

            if (typeof snapshot.gain === 'number') {
                track.gain = snapshot.gain;
            }

            if (typeof snapshot.decay === 'number') {
                track.decay = snapshot.decay;
            }

            if (snapshot.params && track.params) {
                track.params.value = snapshot.params.value ?? track.params.value;
            }

            if (!snapshot.sample) {
                return Promise.resolve();
            }

            ensureTrackSampleState(track);

            if (snapshot.sample.presetId) {
                track.sample.presetId = snapshot.sample.presetId;
            }

            if (snapshot.sample.mode === 'custom' && snapshot.sample.url) {
                track.sample.mode = 'custom';
                track.sample.fileName = snapshot.sample.fileName || null;
                track.sample.url = snapshot.sample.url;
                track.sample.audioBuffer = null;

                return fetchSampleBuffer(snapshot.sample.url)
                    .then(buffer => {
                        track.sample.audioBuffer = buffer;
                        return true;
                    })
                    .catch(error => {
                        console.warn(`Failed to restore custom sample for ${trackId}. Falling back to preset.`, error);
                        track.sample.mode = 'preset';
                        track.sample.fileName = null;
                        track.sample.url = null;
                        track.sample.audioBuffer = null;
                        return false;
                    });
            }

            track.sample.mode = 'preset';
            track.sample.fileName = null;
            track.sample.url = null;
            track.sample.audioBuffer = null;

            return Promise.resolve();
        }

        window.applyTrackSnapshot = applyTrackSnapshot;

        function midiToFreq(midiNote) {
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }

        function getSliderValue(id) {
            const el = document.getElementById(id);
            return el ? parseFloat(el.value) : 0; 
        }
        
        function getSelectValue(id) {
            const el = document.getElementById(id);
            return el ? el.value : null;
        }

        function createDistortionCurve(amount) {
            const k = amount * 0.1; 
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            for (let i = 0; i < n_samples; i++) {
                const x = i * 2 / n_samples - 1; 
                curve[i] = Math.tanh(x * k); 
            }
            return curve;
        }
        
        // Converts global slider (1-100) to audio gain (0-2.0)
        function getDrumVolume() {
            // New range: 1 to 100 maps to 0 to 2.0 (2x power)
            return (getSliderValue('drumVolumeSlider') - 1) / 99 * 2.0; 
        }

        // Converts global slider (1-100) to decay multiplier (0.1 - 2.0)
        function getDrumDecayMultiplier() {
            // New range: 1 to 100 maps to 0.1 to 2.0
            return 0.1 + (getSliderValue('drumDecaySlider') - 1) / 99 * 1.9;
        }

        // --- Audio Instrument Generators ---

        function playDrumHit(time) {
            const track = sequencer.drumHit;
            if (track.muted) return;

            const drumType = getSelectValue('drumHit-type-select');
            const selectedOption = drumHitOptions.find(opt => opt.value === drumType);
            
            const globalVolume = getDrumVolume();
            const globalDecayMult = getDrumDecayMultiplier();
            
            // Normalized gain factor * Global Volume Slider
            const volume = track.gain * (selectedOption.gainMult || 1.0) * globalVolume; 
            
            const gain = audioContext.createGain();
            gain.connect(distortionNode); 
            gain.gain.setValueAtTime(volume, time);
            
            let basePitch = 50; 
            // Base decay from selected option * Global Decay Slider
            let finalDecay = (selectedOption.baseDecay || 0.1) * globalDecayMult;

            // Define common nodes used for all sounds
            let osc = null;
            let noise = null;
            let filter = null;
            let sourceNode = null;

            switch (drumType) {
                case 'deepKick':
                case 'taikoDrum':
                    // Tonal, low-frequency sounds
                    osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    basePitch = (drumType === 'deepKick') ? 45 : 35; 
                    
                    filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(basePitch * 10, time);
                    filter.Q.setValueAtTime(2, time);
                    
                    osc.connect(filter);
                    sourceNode = osc;

                    osc.frequency.setValueAtTime(midiToFreq(basePitch), time);
                    osc.frequency.exponentialRampToValueAtTime(30, time + 0.15); 
                    break;
                    
                case 'snareHit':
                    // Snare (Mix of noise and a short tone)
                    noise = audioContext.createBufferSource();
                    const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.5, audioContext.sampleRate);
                    const output = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseBuffer.length; i++) { output[i] = Math.random() * 2 - 1; }
                    noise.buffer = noiseBuffer;
                    
                    filter = audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.setValueAtTime(800, time); 
                    filter.Q.setValueAtTime(1, time);
                    
                    noise.connect(filter);
                    sourceNode = noise;
                    break;

                case 'rimShot':
                    // Rim Shot/Clave (High, short tone)
                    osc = audioContext.createOscillator();
                    osc.type = 'square';
                    basePitch = 90; // High tone
                    
                    filter = audioContext.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(midiToFreq(basePitch) * 0.5, time);
                    filter.Q.setValueAtTime(10, time);

                    osc.connect(filter);
                    sourceNode = osc;
                    osc.frequency.setValueAtTime(midiToFreq(basePitch), time);
                    break;

                case 'cymbalSiz':
                    // Cymbal (Washed highpass noise)
                    noise = audioContext.createBufferSource();
                    const cymbalNoiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 2.0, audioContext.sampleRate);
                    const cymbalOutput = cymbalNoiseBuffer.getChannelData(0);
                    for (let i = 0; i < cymbalNoiseBuffer.length; i++) { cymbalOutput[i] = Math.random() * 2 - 1; }
                    noise.buffer = cymbalNoiseBuffer;
                    
                    filter = audioContext.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.setValueAtTime(6000, time); 
                    filter.Q.setValueAtTime(1, time);

                    noise.connect(filter);
                    sourceNode = noise;
                    break;

                default:
                    return; // Should not happen with current options
            }
            
            // Connect and play
            sourceNode.connect(gain);
            
            gain.gain.exponentialRampToValueAtTime(0.001, time + finalDecay); 
            sourceNode.start(time);
            sourceNode.stop(time + finalDecay);
        }

        // Play functions simplified to use global controls
        function playClap(time) {
            const track = sequencer.clap;
            if (track.muted) return;
            const volume = track.gain * getDrumVolume(); 
            const decay = track.decay * getDrumDecayMultiplier();

            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * CLAP_NOISE_DURATION, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = noiseBuffer;
            const gain = audioContext.createGain();

            noise.connect(gain);
            gain.connect(distortionNode); 
            
            gain.gain.setValueAtTime(volume, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + decay);

            noise.start(time);
            noise.stop(time + decay);
        }
        
        // This track should probably be renamed if we remove the bassline entirely
        // Renaming to SINE/SAW LEAD since it's the only oscillator left
        function playSynth(time) { 
            // NOTE: This function remains as a placeholder and is not called by the scheduler.
        }


        function playHiHat(time, isClosed) {
            const track = isClosed ? sequencer.hihat : sequencer.openhat;
            if (track.muted) return;

            const globalVolume = getDrumVolume();
            const globalDecayMult = getDrumDecayMultiplier();
            const volume = track.gain * globalVolume;
            const decay = track.decay * globalDecayMult;

            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * DECAY_RANGE, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = noiseBuffer;
            
            const bandpass = audioContext.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.setValueAtTime(8000, time);
            bandpass.Q.setValueAtTime(10, time);

            const gain = audioContext.createGain();
            noise.connect(bandpass);
            bandpass.connect(gain);
            gain.connect(distortionNode);

            const finalDecay = isClosed ? decay : Math.max(decay, 0.2);
            gain.gain.setValueAtTime(volume, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + finalDecay);

            noise.start(time);
            noise.stop(time + finalDecay);
        }

        function playPercussion(time) {
            const track = sequencer.perc;
            if (track.muted) return;
            
            const globalVolume = getDrumVolume();
            const globalDecayMult = getDrumDecayMultiplier();
            const volume = track.gain * globalVolume;
            const decay = track.decay * globalDecayMult;

            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                output[i] = Math.random() * 2 - 1;
            }
            noise.buffer = noiseBuffer;

            const bandpass = audioContext.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.setValueAtTime(4000, time); 
            bandpass.Q.setValueAtTime(5, time);

            const gain = audioContext.createGain();
            noise.connect(bandpass);
            bandpass.connect(gain);
            gain.connect(distortionNode); 
            
            gain.gain.setValueAtTime(volume, time); 
            gain.gain.exponentialRampToValueAtTime(0.001, time + decay); 

            noise.start(time);
            noise.stop(time + decay);
        }


        // --- Core Audio Setup ---

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();

                masterGainNode = audioContext.createGain();

                distortionNode = audioContext.createWaveShaper();
                distortionNode.curve = createDistortionCurve(getSliderValue('gritSlider'));

                backTrackGain = audioContext.createGain();
                backTrackGain.gain.setValueAtTime(0.5, audioContext.currentTime);
                backTrackGain.connect(masterGainNode);

                distortionNode.connect(masterGainNode);

                recordingDestination = audioContext.createMediaStreamDestination();
                masterGainNode.connect(audioContext.destination);
                masterGainNode.connect(recordingDestination);
            }

            if (audioContext && !recordingDestination) {
                recordingDestination = audioContext.createMediaStreamDestination();
                masterGainNode.connect(recordingDestination);
            }

            if (typeof MediaRecorder === 'undefined') {
                if (!recorderSupportLogged) {
                    console.warn('MediaRecorder API is not supported in this browser. Recording features will be disabled.');
                    recorderSupportLogged = true;
                }
                const status = document.getElementById('recordingPreviewStatus');
                if (status) {
                    status.textContent = 'Recording unavailable in this browser.';
                }
                setRecordTimecode('No REC');
                setRecordStatusLabel('Unavailable');
                return;
            }

            if (recordingDestination && !mediaRecorder) {
                try {
                    mediaRecorder = new MediaRecorder(recordingDestination.stream);
                    mediaRecorder.addEventListener('dataavailable', handleRecordingData);
                    mediaRecorder.addEventListener('stop', handleRecordingStop);
                } catch (error) {
                    reportRecorderIssue('Unable to initialize recording in this browser. See console for details.', error);
                    mediaRecorder = null;
                }
            }
        }

        function setRecordTimecode(value) {
            const timeEl = document.getElementById('recordTimecode');
            if (timeEl) {
                timeEl.textContent = value;
            }
        }

        function setRecordStatusLabel(value) {
            const statusEl = document.getElementById('recordStatusLabel');
            if (statusEl) {
                statusEl.textContent = value;
            }
        }

        function formatTimecode(durationMs) {
            const totalSeconds = Math.max(0, Math.floor(durationMs / 1000));
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }

        function updateRecordingTimecode() {
            if (!recordingStartTime) return;
            const elapsed = Date.now() - recordingStartTime;
            setRecordTimecode(formatTimecode(elapsed));
        }

        function setRecordingUiState(active) {
            const recordButton = document.getElementById('toggleRecord');
            const recordIcon = document.getElementById('recordIcon');
            const led = document.getElementById('recordLed');

            if (!recordButton) return;

            if (active) {
                recordButton.classList.add('recording-active');
                setRecordStatusLabel('Recording');
                if (recordIcon) recordIcon.textContent = 'STOP';
                if (led) {
                    led.classList.remove('bg-gray-500');
                    led.classList.add('bg-red-500');
                }
            } else {
                recordButton.classList.remove('recording-active');
                if (recordIcon) recordIcon.textContent = 'REC';
                if (led) {
                    led.classList.remove('bg-red-500');
                    led.classList.add('bg-gray-500');
                }
                setRecordStatusLabel('Standby');
            }
        }

        function clearRecordingPreview() {
            const previewCard = document.getElementById('recordingPreviewCard');
            const audioEl = document.getElementById('recordingPreviewAudio');
            const status = document.getElementById('recordingPreviewStatus');

            if (audioEl) {
                audioEl.pause();
                audioEl.removeAttribute('src');
                audioEl.load();
            }

            if (previewCard) {
                previewCard.classList.add('hidden');
            }

            if (status) {
                status.textContent = '';
            }

            if (recordingPreviewUrl) {
                URL.revokeObjectURL(recordingPreviewUrl);
                recordingPreviewUrl = null;
            }

            setRecordTimecode('00:00');
            setRecordStatusLabel('Standby');
        }

        function reportRecorderIssue(message, error) {
            if (error) {
                console.warn(message, error);
            } else {
                console.warn(message);
            }
            const status = document.getElementById('recordingPreviewStatus');
            if (status) {
                status.textContent = message;
            }
            setRecordTimecode('No REC');
            setRecordStatusLabel('Unavailable');
            if (!recorderWarningShown) {
                if (typeof alert === 'function') {
                    alert(message);
                }
                recorderWarningShown = true;
            }
        }

        function handleRecordingData(event) {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        }

        function handleRecordingStop() {
            if (recordingTimerId) {
                clearInterval(recordingTimerId);
                recordingTimerId = null;
            }

            recordingStartTime = null;
            isRecording = false;
            setRecordingUiState(false);

            if (!recordedChunks.length) {
                const status = document.getElementById('recordingPreviewStatus');
                if (status) {
                    status.textContent = 'No audio captured.';
                }
                setRecordTimecode('00:00');
                setRecordStatusLabel('Standby');
                return;
            }

            const mimeType = mediaRecorder && mediaRecorder.mimeType ? mediaRecorder.mimeType : 'audio/webm';
            const blob = new Blob(recordedChunks, { type: mimeType });

            if (recordingPreviewUrl) {
                URL.revokeObjectURL(recordingPreviewUrl);
            }
            recordingPreviewUrl = URL.createObjectURL(blob);

            const audioEl = document.getElementById('recordingPreviewAudio');
            const previewCard = document.getElementById('recordingPreviewCard');
            const status = document.getElementById('recordingPreviewStatus');

            if (audioEl) {
                audioEl.src = recordingPreviewUrl;
                audioEl.load();
            }

            if (previewCard) {
                previewCard.classList.remove('hidden');
            }

            if (status) {
                status.textContent = 'Take ready for review.';
            }

            setRecordTimecode('00:00');
            setRecordStatusLabel('Preview');
        }

        function stopActiveRecording() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                return;
            }

            isRecording = false;
            recordingStartTime = null;

            if (recordingTimerId) {
                clearInterval(recordingTimerId);
                recordingTimerId = null;
            }

            setRecordingUiState(false);
            setRecordStatusLabel('Finalizing');

            const status = document.getElementById('recordingPreviewStatus');
            if (status) {
                status.textContent = 'Finalizing take...';
            }

            try {
                mediaRecorder.stop();
            } catch (error) {
                reportRecorderIssue('An error occurred while stopping the recording. See console for details.', error);
            }
        }

        function ensureRecorderAvailable() {
            if (mediaRecorder) {
                return true;
            }

            reportRecorderIssue('Recording is unavailable because MediaRecorder could not be initialized.');
            return false;
        }

        function handleSaveRecording() {
            if (!ensureRecorderAvailable()) {
                return;
            }

            if (!recordedChunks.length) {
                const status = document.getElementById('recordingPreviewStatus');
                if (status) {
                    status.textContent = 'Nothing to save yet.';
                }
                return;
            }

            const mimeType = mediaRecorder && mediaRecorder.mimeType ? mediaRecorder.mimeType : 'audio/webm';
            const blob = new Blob(recordedChunks, { type: mimeType });
            const downloadUrl = URL.createObjectURL(blob);

            const timestamp = new Date();
            const filename = `raw-house-take-${timestamp.getFullYear()}${String(timestamp.getMonth() + 1).padStart(2, '0')}${String(timestamp.getDate()).padStart(2, '0')}-${String(timestamp.getHours()).padStart(2, '0')}${String(timestamp.getMinutes()).padStart(2, '0')}${String(timestamp.getSeconds()).padStart(2, '0')}.webm`;

            const anchor = document.createElement('a');
            anchor.href = downloadUrl;
            anchor.download = filename;
            document.body.appendChild(anchor);
            anchor.click();
            document.body.removeChild(anchor);

            setTimeout(() => URL.revokeObjectURL(downloadUrl), 1000);

            const status = document.getElementById('recordingPreviewStatus');
            if (status) {
                status.textContent = 'Download started.';
            }
        }

        function handleDiscardRecording() {
            clearRecordingPreview();
            recordedChunks = [];

            const status = document.getElementById('recordingPreviewStatus');
            if (status) {
                status.textContent = 'Recording discarded.';
            }
        }

        // --- Control Handlers ---

        function updateDistortion() {
            const grit = getSliderValue('gritSlider');
            document.getElementById('gritValue').textContent = grit;
            if (distortionNode) {
                distortionNode.curve = createDistortionCurve(grit); 
            }
        }
        
        function updateBPMDisplay() {
            document.getElementById('bpmValue').textContent = getSliderValue('bpmSlider');
        }
        
        function updateDrumVolumeDisplay() {
            document.getElementById('drumVolumeValue').textContent = getSliderValue('drumVolumeSlider');
        }

        function updateDrumDecayDisplay() {
            document.getElementById('drumDecayValue').textContent = getSliderValue('drumDecaySlider');
        }


        // --- Scheduling Logic ---

        function scheduler() {
            const bpm = getSliderValue('bpmSlider');
            const secondsPerBeat = 60.0 / bpm; 
            const secondsPerStep = secondsPerBeat / 4; 
            const lookAhead = 0.1; 
            const currentTime = audioContext.currentTime;

            while (nextNoteTime < currentTime + lookAhead) {
                const time = nextNoteTime;
                
                // Play instrument sounds
                if (sequencer.drumHit.pattern[currentStep] === 1) playDrumHit(time);
                if (sequencer.clap.pattern[currentStep] === 1) playClap(time);
                // BASS TRACK REMOVED
                if (sequencer.hihat.pattern[currentStep] === 1) playHiHat(time, true);
                if (sequencer.openhat.pattern[currentStep] === 1) playHiHat(time, false);
                if (sequencer.perc.pattern[currentStep] === 1) playPercussion(time);
                
                // Log event for 'Recording' (Conceptual)
                if (isRecording) {
                    console.log(`[REC] Step ${currentStep} played at ${time.toFixed(3)}s`);
                }

                // Visual Update 
                const visualStep = currentStep;
                document.querySelectorAll('.step-button').forEach(btn => btn.classList.remove('step-active'));
                
                Object.keys(sequencer).forEach(id => {
                    const btn = document.getElementById(`${id}-step-${visualStep}`);
                    if (btn) btn.classList.add('step-active');
                });

                // Advance to the next step
                nextNoteTime += secondsPerStep;
                currentStep = (currentStep + 1) % NUM_STEPS;
            }

            // Loop the scheduler
            if (isPlaying) {
                timerID = setTimeout(scheduler, 25.0); 
            } else {
                document.querySelectorAll('.step-button').forEach(btn => btn.classList.remove('step-active'));
            }
        }

        function togglePlay() {
            initAudio();

            const button = document.getElementById('togglePlay');

            if (!isPlaying) {
                // FIX: Ensures audio context resumes correctly before starting the beat.
                audioContext.resume().then(() => {
                    isPlaying = true;
                    currentStep = 0;
                    // Set nextNoteTime slightly ahead of the current time (increased to 0.1 for stability)
                    nextNoteTime = audioContext.currentTime + 0.1; 
                    scheduler();
                    button.textContent = 'STOP';
                    button.classList.remove('glow-shadow');

                    if (backTrackSource && backTrackSource.buffer) {
                        playBackTrack(audioContext.currentTime);
                    }
                }).catch(e => console.error("Error resuming audio context:", e));


            } else {
                // STOP
                isPlaying = false;
                clearTimeout(timerID);
                button.textContent = 'START';
                button.classList.add('glow-shadow');

                stopActiveRecording();

                if (backTrackSource && backTrackSource.source) {
                    try {
                        backTrackSource.source.stop();
                    } catch (e) {
                        console.error("Backing track already stopped or error:", e);
                    }
                    backTrackSource.source = null;
                }
            }
        }
        
        function toggleRecord() {
            initAudio();

            if (!ensureRecorderAvailable()) {
                return;
            }

            const status = document.getElementById('recordingPreviewStatus');

            if (mediaRecorder.state === 'recording') {
                stopActiveRecording();
                return;
            }

            clearRecordingPreview();
            recordedChunks = [];

            if (status) {
                status.textContent = 'Arming recorder...';
            }

            setRecordStatusLabel('Arming');

            const resumePromise = audioContext ? audioContext.resume() : Promise.resolve();
            resumePromise.catch((error) => {
                console.warn('Unable to resume audio context before recording start.', error);
            }).finally(() => {
                try {
                    mediaRecorder.start();
                    recordingStartTime = Date.now();
                    isRecording = true;
                    setRecordingUiState(true);
                    setRecordTimecode('00:00');
                    updateRecordingTimecode();
                    if (recordingTimerId) clearInterval(recordingTimerId);
                    recordingTimerId = setInterval(updateRecordingTimecode, 250);
                    if (status) {
                        status.textContent = 'Recording...';
                    }
                } catch (error) {
                    isRecording = false;
                    recordingStartTime = null;
                    if (recordingTimerId) {
                        clearInterval(recordingTimerId);
                        recordingTimerId = null;
                    }
                    setRecordingUiState(false);
                    reportRecorderIssue('Recording could not be started. See console for details.', error);
                }
            });
        }

        // --- Backing Track Loading Logic (Omitted for brevity, unchanged) ---

        function calculatePlaybackRate() {
            const mode = document.querySelector('input[name="backtrackMode"]:checked').value;
            
            if (mode === 'original') {
                return 1.0;
            }

            // Tempo Sync Mode (Assumes track is a 4-bar loop)
            if (backTrackSource && backTrackSource.buffer) {
                const ASSUMED_BARS = 4;
                const currentBPM = getSliderValue('bpmSlider');
                const originalDuration = backTrackSource.buffer.duration;
                const targetDuration = (60 / currentBPM) * 4 * ASSUMED_BARS;
                
                const rate = originalDuration / targetDuration;
                return rate;
            }
            return 1.0; 
        }

        function playBackTrack(time) {
            if (!backTrackSource || !backTrackSource.buffer) return;

            if (backTrackSource.source) {
                try { backTrackSource.source.stop(); } catch (e) {}
            }

            const source = audioContext.createBufferSource();
            source.buffer = backTrackSource.buffer;
            source.loop = true; 
            source.connect(backTrackGain);
            
            source.playbackRate.value = calculatePlaybackRate();
            
            backTrackSource.source = source; 

            source.start(time);
        }

        async function loadAudio(audioData, isUrl) {
            const statusDiv = document.getElementById('backTrackStatus');
            statusDiv.textContent = isUrl ? "Status: Loading audio from URL..." : "Status: Loading audio from file...";
            
            try {
                let arrayBuffer;
                
                if (isUrl) {
                    const response = await fetch(audioData);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    arrayBuffer = await response.arrayBuffer();
                } else {
                    arrayBuffer = audioData;
                }
                
                initAudio();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                backTrackSource = { buffer: audioBuffer, source: null }; 
                
                statusDiv.textContent = `Status: Track loaded (${(audioBuffer.duration).toFixed(1)}s, looped).`;
                document.getElementById('backtrackLabel').textContent = "Track Loaded (VIOLET)";

            } catch (error) {
                console.error("Error loading or decoding audio:", error);
                statusDiv.textContent = `Status: ERROR loading track.`;
                backTrackSource = null;
                document.getElementById('backtrackLabel').textContent = "Load Backing Track";
            }
        }
        
        // --- UI Generation and Setup ---

        function generateTrackUI(id, data) {
            const trackName = id.toUpperCase().replace('DRUMHIT', 'DRUM HIT'); 
            const specialParam = data.params;
            const container = document.getElementById('sequencerContainer');

            const isDrumHit = id === 'drumHit';
            
            let paramControlHTML = `<div class="simplified-control-spacer"></div>`;
            let volumeControlHTML = `<div class="simplified-control-spacer"></div>`;

            if (isDrumHit) {
                // DRUM HIT track: Decay slider + Sound pulldown
                const optionsHTML = specialParam.options.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
                
                // Volume/Decay sliders removed, replaced with spacer
                volumeControlHTML = `<div class="simplified-control-spacer"></div>`; 

                paramControlHTML = `
                    <!-- Sound Pulldown -->
                    <div class="flex items-center space-x-2 w-1/4">
                        <label for="${id}-type-select" class="text-gray-400 text-xs flex-shrink-0">SOUND</label>
                        <select id="${id}-type-select" class="w-full text-xs bg-gray-700 text-white rounded-md p-1 border border-gray-600">
                            ${optionsHTML}
                        </select>
                    </div>
                `;
            } else {
                // All other tracks: No parameter controls, just spacers for alignment
                volumeControlHTML = `<div class="simplified-control-spacer"></div>`;
                paramControlHTML = `<div class="simplified-control-spacer"></div>`;
            }
            
            // Build the main track element
            const trackElement = document.createElement('div');
            trackElement.className = "flex flex-col space-y-2 mb-4";
            trackElement.innerHTML = `
                <!-- Top Row: Label, Mute, Volume, Special Parameter -->
                <div class="flex items-center space-x-4">
                    <span id="${id}-label" class="text-xs sm:text-sm font-bold text-white track-label text-center rounded-lg py-1 hover:opacity-80 transition-opacity" 
                          style="background-color: ${data.color};">
                          ${trackName}
                    </span>
                    
                    ${volumeControlHTML}
                    ${paramControlHTML}
                    
                </div>

                <!-- Bottom Row: Step Sequencer -->
                <div id="${id}Track" class="flex flex-grow space-x-1 sm:space-x-2 pl-4">
                    <!-- Step buttons injected here -->
                </div>
            `;
            container.appendChild(trackElement);

            // Mute/Unmute Logic - CRITICAL FIX
            document.getElementById(`${id}-label`).addEventListener('click', (e) => {
                // Directly reference the global sequencer object
                sequencer[id].muted = !sequencer[id].muted;
                e.target.classList.toggle('track-muted', sequencer[id].muted);
            });

            // Generate Step Buttons
            const stepContainer = document.getElementById(`${id}Track`);
            for (let i = 0; i < NUM_STEPS; i++) {
                const button = document.createElement('button');
                button.id = `${id}-step-${i}`;
                button.className = `step-button flex-grow rounded-md`;
                button.style.backgroundColor = data.pattern[i] === 1 ? data.color : 'rgba(107, 114, 128, 0.3)';
                button.onclick = () => {
                    data.pattern[i] = 1 - data.pattern[i]; 
                    button.style.backgroundColor = data.pattern[i] === 1 ? data.color : 'rgba(107, 114, 128, 0.3)';
                };
                stepContainer.appendChild(button);
            }
        }


        window.onload = function() {
            // 1. Generate Track UIs Dynamically
            Object.keys(sequencer).forEach(id => {
                generateTrackUI(id, sequencer[id]);
            });

            // 2. Setup Main Controls
            document.getElementById('togglePlay').addEventListener('click', togglePlay);
            document.getElementById('toggleRecord').addEventListener('click', toggleRecord);

            document.getElementById('saveRecording').addEventListener('click', handleSaveRecording);
            document.getElementById('discardRecording').addEventListener('click', handleDiscardRecording);
            
            // BPM Slider Control
            document.getElementById('bpmSlider').addEventListener('input', () => {
                updateBPMDisplay();
                if (isPlaying && backTrackSource && backTrackSource.source) {
                    backTrackSource.source.playbackRate.value = calculatePlaybackRate();
                }
            });
            
            // Global Drum Volume Control
            document.getElementById('drumVolumeSlider').addEventListener('input', updateDrumVolumeDisplay);
            
            // Global Drum Decay Control
            document.getElementById('drumDecaySlider').addEventListener('input', updateDrumDecayDisplay);
            
            // Grit Slider Control
            document.getElementById('gritSlider').addEventListener('input', updateDistortion);
            
            // 3. Backing Track Panel Toggle
            const backtrackPanel = document.getElementById('backtrackPanel');
            document.getElementById('toggleBacktrackPanel').addEventListener('click', () => {
                backtrackPanel.classList.toggle('hidden');
            });

            // 4. Backing Track Loaders (Listeners unchanged)
            document.getElementById('audioUrlInput').addEventListener('change', (e) => {
                const url = e.target.value.trim();
                if (url) {
                    if (isPlaying) togglePlay();
                    loadAudio(url, true);
                    document.getElementById('audioFileInput').value = '';
                }
            });

            document.getElementById('audioFileInput').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (isPlaying) togglePlay();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        loadAudio(event.target.result, false);
                    };
                    reader.readAsArrayBuffer(file);
                    document.getElementById('audioUrlInput').value = '';
                }
            });

            // 5. Sync Mode Listeners 
            document.querySelectorAll('input[name="backtrackMode"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    if (isPlaying && backTrackSource && backTrackSource.source) {
                        backTrackSource.source.playbackRate.value = calculatePlaybackRate();
                    }
                });
            });
            
            // Initial setup
            updateDistortion(); 
            updateBPMDisplay();
            updateDrumVolumeDisplay();
            updateDrumDecayDisplay();

            // Initialize audio context on first user interaction with a click listener
            document.body.addEventListener('click', initAudio, { once: true });

            // Set the default selected value for the DRUM HIT track
            const drumHitSelect = document.getElementById('drumHit-type-select');
            if(drumHitSelect) {
                drumHitSelect.value = 'deepKick'; // Defaulting to the KICK sound
            }

        };
    </script>
</body>
</html>

