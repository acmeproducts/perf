<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Review Viewer</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      --bg: #f7f8fc;
      --bg-dark: #151922;
      --panel: #ffffff;
      --panel-dark: #1f2430;
      --border: #dde1ee;
      --border-dark: #2e3445;
      --muted: #6b7280;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.12);
      --success: #16a34a;
      --danger: #dc2626;
      line-height: 1.6;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, rgba(79, 70, 229, 0.12), transparent 320px) var(--bg);
      color: #111827;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(180deg, rgba(99, 102, 241, 0.32), transparent 320px) var(--bg-dark);
        color: #e5e7eb;
      }
    }

    header {
      padding: 32px clamp(20px, 4vw, 48px) 12px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 5vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    header p {
      margin: 8px 0 0;
      max-width: 720px;
      color: var(--muted);
    }

    .app-shell {
      padding: 0 clamp(20px, 4vw, 48px) 48px;
    }

    .tab-bar {
      display: flex;
      gap: 8px;
      border-bottom: 1px solid var(--border);
    }

    .tab-button {
      position: relative;
      appearance: none;
      background: none;
      border: none;
      font: inherit;
      padding: 12px 18px;
      border-radius: 12px 12px 0 0;
      cursor: pointer;
      color: var(--muted);
      transition: color 0.2s ease, background-color 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent);
      background: var(--panel);
      box-shadow: 0 -8px 24px rgba(15, 23, 42, 0.08);
    }

    .tab-panel {
      display: none;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 0 16px 16px 16px;
      padding: 24px;
      margin-top: -1px;
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.08);
    }

    .tab-panel.active {
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .tab-button.active {
        background: var(--panel-dark);
        color: #c7d2fe;
        box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.35);
      }

      .tab-panel {
        background: var(--panel-dark);
        border-color: var(--border-dark);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.35);
      }
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 20px;
    }

    .toolbar button,
    .toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(79, 70, 229, 0.06);
      color: var(--accent);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .toolbar button:hover,
    .toolbar label:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .toolbar label input {
      display: none;
    }

    #status-bar {
      min-height: 24px;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 20px;
    }

    .entries {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .entry {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.85);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }

    .entry.open {
      box-shadow: 0 20px 44px rgba(15, 23, 42, 0.12);
    }

    .entry.excluded {
      opacity: 0.55;
    }

    @media (prefers-color-scheme: dark) {
      .entry {
        background: rgba(31, 36, 48, 0.9);
        border-color: var(--border-dark);
      }

      .entry.open {
        box-shadow: 0 20px 44px rgba(0, 0, 0, 0.55);
      }
    }

    .entry-header {
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: default;
    }

    .entry-toggle {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .entry.open .entry-toggle {
      transform: rotate(90deg);
    }

    .entry-header-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-weight: 600;
    }

    .entry-header-meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.95rem;
    }

    .separator::before {
      content: "Â·";
      color: var(--muted);
      margin: 0 4px;
    }

    .editable-text {
      position: relative;
      padding: 2px 4px;
      border-radius: 6px;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .editable-text:hover {
      background: rgba(79, 70, 229, 0.08);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.18);
      cursor: text;
    }

    .editable-text.editing {
      background: rgba(79, 70, 229, 0.12);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.35);
    }

    .include-toggle {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .include-toggle input {
      width: 44px;
      height: 24px;
      appearance: none;
      background: rgba(79, 70, 229, 0.25);
      border-radius: 999px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .include-toggle input::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 4px;
      width: 18px;
      height: 18px;
      background: #ffffff;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
      transition: transform 0.2s ease;
    }

    .include-toggle input:not(:checked) {
      background: rgba(148, 163, 184, 0.35);
    }

    .include-toggle input:checked::after {
      transform: translateX(18px);
    }

    .entry-body {
      margin-top: 16px;
      border-top: 1px solid var(--border);
      padding-top: 16px;
      display: none;
      gap: 12px;
      flex-direction: column;
    }

    .entry.open .entry-body {
      display: flex;
    }

    .detail-line {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.95rem;
    }

    .detail-line .pipe {
      color: var(--muted);
    }

    .link-button {
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid transparent;
      background: rgba(79, 70, 229, 0.08);
      color: var(--accent);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      font-size: 0.85rem;
    }

    .link-button:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .section-title {
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .section-title.editable-text:hover {
      cursor: text;
    }

    .section-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .entry-line {
      position: relative;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 0.93rem;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .entry-line:hover {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.3);
      cursor: text;
    }

    .entry-line .line-text {
      display: inline;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .entry-line .file-links {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-left: 12px;
    }

    .entry-line .file-link {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }

    .entry-line .file-link:hover {
      text-decoration: underline;
    }

    .entry-line .open-link {
      margin-left: 8px;
      border: 1px solid rgba(79, 70, 229, 0.2);
      background: rgba(79, 70, 229, 0.12);
      color: var(--accent);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .entry-line .open-link:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .inline-editor,
    .inline-editor-area {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
      resize: vertical;
    }

    .inline-editor-area {
      min-height: 56px;
    }

    .link-editor {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .link-editor input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
    }

    .link-editor .editor-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .link-editor button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 600;
    }

    .link-editor .save {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .link-editor .cancel {
      background: rgba(248, 113, 113, 0.12);
      color: var(--danger);
    }

    .link-editor .save:hover {
      background: rgba(34, 197, 94, 0.25);
    }

    .link-editor .cancel:hover {
      background: rgba(248, 113, 113, 0.2);
    }

    @media (max-width: 920px) {
      .entry-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .include-toggle {
        margin-left: 0;
      }

      .detail-line {
        flex-direction: column;
        align-items: flex-start;
      }

      .detail-line .pipe {
        display: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Codex Review Viewer</h1>
    <p>Track review artefacts, toggle inclusion, and edit contextual notes inline. Double-click any line to update it.</p>
  </header>
  <div class="app-shell">
    <nav class="tab-bar" role="tablist">
      <button class="tab-button active" id="tab-view" role="tab" aria-selected="true" aria-controls="panel-view">View</button>
    </nav>
    <section class="tab-panel active" id="panel-view" role="tabpanel" aria-labelledby="tab-view">
      <div class="toolbar">
        <button type="button" id="refresh-button">â†» Refresh</button>
        <label for="import-input">â¬† Import JSON<input id="import-input" type="file" accept="application/json" /></label>
        <button type="button" id="export-json-button">â¬‡ Export JSON</button>
        <button type="button" id="export-txt-button">â¬‡ Export TXT</button>
        <button type="button" id="export-md-button">â¬‡ Export Markdown</button>
        <button type="button" id="export-csv-button">â¬‡ Export CSV</button>
        <button type="button" id="export-pdf-button">â¬‡ Export PDF</button>
        <button type="button" id="save-button">ðŸ’¾ Save JSON</button>
      </div>
      <div id="status-bar" role="status" aria-live="polite"></div>
      <div class="entries" id="entry-list"></div>
    </section>
  </div>
  <script>
    const STORAGE_KEY = 'viewer_entries_state_v1';
    const SHARED_STORAGE_KEYS = [
      'codexrecall.combinedChecklist',
      'codexrecall.sharedChecklist',
      'codexrecall.viewerCombined'
    ];
    const DEFAULT_REPO_CONTEXT = { owner: '', repo: '', branch: 'main' };

    const defaultEntries = [
      {
        id: 76,
        title: 'Adjust touch end handling for drag gestures',
        summary: 'Ensure release events stay smooth for cross-browser sync scenarios.',
        timestamp: '9/27/2025, 6:05:13 PM',
        docRef: 'codex/review-analysis-v9-cross-browser-sync.md-77an0q',
        pr: {
          label: 'View PR',
          url: 'https://github.com/user/repo/pull/76'
        },
        include: true,
        sections: [
          {
            title: '------ live links',
            lines: [
              'https://chatgpt.com/codex/tasks/task_e_68d7b9a3f380832db7d50f1434ad43a8',
              'Filename: ui-v9a.htnl',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>',
              'Filename: ui-v9b.html',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>'
            ]
          },
          {
            title: '------- item metadata',
            lines: [
              'Tags',
              'Add tag and press Enter',
              '',
              'Notes',
              'Add checklist notesâ€¦',
              '',
              'Status:'
            ]
          }
        ]
      }
    ];

    const dom = {
      entryList: document.getElementById('entry-list'),
      refreshButton: document.getElementById('refresh-button'),
      exportJsonButton: document.getElementById('export-json-button'),
      exportTxtButton: document.getElementById('export-txt-button'),
      exportMarkdownButton: document.getElementById('export-md-button'),
      exportCsvButton: document.getElementById('export-csv-button'),
      exportPdfButton: document.getElementById('export-pdf-button'),
      saveButton: document.getElementById('save-button'),
      importInput: document.getElementById('import-input'),
      statusBar: document.getElementById('status-bar')
    };

    let repoContext = { ...DEFAULT_REPO_CONTEXT };
    let stateSource = 'default';
    let jsPdfLoader = null;

    let entries = loadState();
    const openEntries = new Set();

    function loadState() {
      const shared = loadSharedChecklistState();
      if (shared) {
        applyRepoContext(shared.repoContext);
        stateSource = 'shared';
        return cloneEntries(shared.entries);
      }

      try {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) {
            stateSource = 'local';
            applyRepoContext(null);
            return cloneEntries(parsed);
          }
          if (parsed && typeof parsed === 'object') {
            if (Array.isArray(parsed.entries)) {
              stateSource = parsed.stateSource || 'local';
              applyRepoContext(parsed.repoContext || null);
              return cloneEntries(parsed.entries);
            }
          }
        }
      } catch (error) {
        console.warn('Failed to load saved state', error);
      }

      stateSource = 'default';
      applyRepoContext(null);
      return cloneEntries(defaultEntries);
    }

    function saveState() {
      try {
        const payload = {
          entries,
          repoContext,
          stateSource: 'local',
          savedAt: new Date().toISOString()
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
        stateSource = 'local';
        const repoLabel = formatRepoContextLabel();
        setStatus(`Saved current entries to local storage${repoLabel ? ` for ${repoLabel}.` : '.'}`);
      } catch (error) {
        console.error('Unable to save state', error);
        setStatus('Unable to save state. Check storage availability.', true);
      }
    }

    function loadSharedChecklistState() {
      for (const key of SHARED_STORAGE_KEYS) {
        const raw = localStorage.getItem(key);
        if (!raw) continue;
        try {
          const parsed = JSON.parse(raw);
          const entries = findEntriesInCandidate(parsed);
          if (!Array.isArray(entries) || !entries.length) continue;
          const repo = findRepoContext(parsed);
          return {
            key,
            entries,
            repoContext: repo
          };
        } catch (error) {
          console.warn(`Failed to parse shared checklist state for ${key}`, error);
        }
      }
      return null;
    }

    function findEntriesInCandidate(candidate, depth = 0) {
      if (!candidate || depth > 4) return null;
      if (Array.isArray(candidate)) {
        const entryLike = candidate.some(item => item && typeof item === 'object' && (Array.isArray(item.sections) || 'sections' in item || 'summary' in item || 'title' in item));
        return entryLike ? candidate : null;
      }
      if (typeof candidate !== 'object') return null;
      if (Array.isArray(candidate.entries) && candidate.entries.length) {
        return candidate.entries;
      }
      const prioritizedKeys = ['data', 'payload', 'state', 'value', 'content', 'combined', 'checklist'];
      for (const key of prioritizedKeys) {
        if (candidate[key]) {
          const result = findEntriesInCandidate(candidate[key], depth + 1);
          if (result) return result;
        }
      }
      for (const value of Object.values(candidate)) {
        if (typeof value === 'object' && value) {
          const result = findEntriesInCandidate(value, depth + 1);
          if (result) return result;
        }
      }
      return null;
    }

    function findRepoContext(candidate, depth = 0) {
      if (!candidate || depth > 4) return null;
      if (typeof candidate === 'string') {
        return interpretRepoDescriptor(candidate);
      }
      if (Array.isArray(candidate)) {
        for (const value of candidate) {
          const result = findRepoContext(value, depth + 1);
          if (result) return result;
        }
        return null;
      }
      if (typeof candidate !== 'object') {
        return null;
      }

      const direct = interpretRepoDescriptor(candidate);
      if (direct && direct.owner && direct.repo) {
        return direct;
      }

      const prioritizedKeys = ['selected', 'selectedRepo', 'selectedRepository', 'selection', 'activeRepo', 'currentRepo', 'repoContext', 'repository', 'meta', 'context', 'source', 'config', 'settings'];
      for (const key of prioritizedKeys) {
        if (candidate[key]) {
          const result = findRepoContext(candidate[key], depth + 1);
          if (result) return result;
        }
      }
      for (const value of Object.values(candidate)) {
        if (typeof value === 'object' || typeof value === 'string') {
          const result = findRepoContext(value, depth + 1);
          if (result) return result;
        }
      }
      return null;
    }

    function interpretRepoDescriptor(value) {
      if (!value) return null;
      if (typeof value === 'string') {
        return parseRepoString(value);
      }
      if (typeof value !== 'object') return null;

      if (typeof value.repoFullName === 'string') {
        const parsed = parseRepoString(value.repoFullName);
        if (parsed) return parsed;
      }
      if (typeof value.repositoryFullName === 'string') {
        const parsed = parseRepoString(value.repositoryFullName);
        if (parsed) return parsed;
      }
      if (typeof value.fullName === 'string') {
        const parsed = parseRepoString(value.fullName);
        if (parsed) return parsed;
      }
      if (typeof value.slug === 'string') {
        const parsed = parseRepoString(value.slug);
        if (parsed) return parsed;
      }

      const ownerRaw = value.owner || value.org || value.organization || value.user || value.username || (value.account && (value.account.login || value.account.name));
      const repoRaw = value.repo || value.repository || value.name || value.project || value.repoName;
      let branchRaw = value.branch || value.ref || value.head || value.headRef || value.headRefName || value.defaultBranch || value.default_branch || value.branchName || value.selectedBranch || value.branchRef;

      const owner = typeof ownerRaw === 'object' ? (ownerRaw && (ownerRaw.login || ownerRaw.name)) : ownerRaw;
      let repo = typeof repoRaw === 'object' ? (repoRaw && (repoRaw.name || repoRaw.repo || repoRaw.repository)) : repoRaw;
      if (!repo && typeof value.repository === 'string') {
        const parsed = parseRepoString(value.repository);
        if (parsed) {
          if (!branchRaw && parsed.branch) branchRaw = parsed.branch;
          return parsed;
        }
      }

      if (typeof branchRaw === 'object' && branchRaw) {
        branchRaw = branchRaw.name || branchRaw.ref || branchRaw.value;
      }

      if (owner && repo) {
        return {
          owner: String(owner).trim(),
          repo: String(repo).trim(),
          branch: branchRaw ? String(branchRaw).trim() : undefined
        };
      }

      return null;
    }

    function parseRepoString(value) {
      if (!value || typeof value !== 'string') return null;
      const trimmed = value.trim();
      if (!trimmed || !trimmed.includes('/')) return null;
      let repoPart = trimmed;
      let branch = '';
      const separators = ['@', '#', ':'];
      for (const sep of separators) {
        const index = trimmed.indexOf(sep);
        if (index > -1) {
          repoPart = trimmed.slice(0, index);
          branch = trimmed.slice(index + 1);
          break;
        }
      }
      const [owner, repo] = repoPart.split('/', 2);
      if (!owner || !repo) return null;
      return {
        owner: owner.trim(),
        repo: repo.trim(),
        branch: branch.trim() || undefined
      };
    }

    function cloneEntries(source) {
      return JSON.parse(JSON.stringify(source || []));
    }

    function applyRepoContext(next) {
      if (!next || (!next.owner && !next.repo)) {
        repoContext = { ...DEFAULT_REPO_CONTEXT };
        return;
      }
      const owner = (next.owner || '').trim();
      const repo = (next.repo || '').trim();
      const branch = (next.branch || '').trim();
      repoContext = {
        owner,
        repo,
        branch: branch || DEFAULT_REPO_CONTEXT.branch
      };
    }

    function formatRepoContextLabel(context = repoContext) {
      if (!context || !context.owner || !context.repo) return '';
      const branch = context.branch ? `@${context.branch}` : '';
      return `${context.owner}/${context.repo}${branch}`;
    }

    function setStatus(message, isError = false) {
      dom.statusBar.textContent = message || '';
      dom.statusBar.style.color = isError ? 'var(--danger)' : 'var(--muted)';
      if (message) {
        clearTimeout(setStatus.timeoutId);
        setStatus.timeoutId = setTimeout(() => {
          dom.statusBar.textContent = '';
        }, 4000);
      }
    }

    function renderEntries() {
      dom.entryList.innerHTML = '';
      if (!entries.length) {
        const emptyState = document.createElement('div');
        emptyState.className = 'entry';
        emptyState.innerHTML = '<strong>No entries yet.</strong> Use Import JSON to bring in existing review data.';
        dom.entryList.appendChild(emptyState);
        return;
      }

      entries.forEach((entry, index) => {
        const entryEl = document.createElement('article');
        entryEl.className = 'entry';
        entryEl.dataset.index = index;
        if (openEntries.has(index)) {
          entryEl.classList.add('open');
        }
        if (!entry.include) {
          entryEl.classList.add('excluded');
        }

        const header = document.createElement('div');
        header.className = 'entry-header';

        const toggleButton = document.createElement('button');
        toggleButton.type = 'button';
        toggleButton.className = 'entry-toggle';
        toggleButton.setAttribute('aria-label', 'Toggle entry details');
        toggleButton.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 5l8 7-8 7"></path></svg>';
        header.appendChild(toggleButton);

        const meta = document.createElement('div');
        meta.className = 'entry-header-meta';
        meta.innerHTML = `
          <span class="entry-id">#${entry.id}</span>
          <span class="separator"></span>
          <span class="entry-title editable-text" data-editable data-field="title" data-entry-index="${index}">${escapeHtml(entry.title)}</span>
          <span class="separator"></span>
          <span class="entry-date editable-text" data-editable data-field="timestamp" data-entry-index="${index}">${escapeHtml(entry.timestamp)}</span>
          <span class="separator"></span>
          <span class="entry-summary editable-text" data-editable data-field="summary" data-entry-index="${index}">${escapeHtml(entry.summary)}</span>
        `;
        header.appendChild(meta);

        const includeWrap = document.createElement('label');
        includeWrap.className = 'include-toggle';
        includeWrap.innerHTML = `
          <span>${entry.include ? 'Include' : 'Exclude'}</span>
          <input type="checkbox" data-role="include-toggle" data-entry-index="${index}" ${entry.include ? 'checked' : ''} aria-label="Toggle include for entry ${entry.id}">
        `;
        header.appendChild(includeWrap);

        entryEl.appendChild(header);

        const body = document.createElement('div');
        body.className = 'entry-body';

        const detailLine = document.createElement('div');
        detailLine.className = 'detail-line';

        const tsSpan = document.createElement('span');
        tsSpan.className = 'editable-text';
        tsSpan.dataset.editable = '';
        tsSpan.dataset.field = 'timestamp';
        tsSpan.dataset.entryIndex = index;
        tsSpan.textContent = entry.timestamp;

        const docSpan = document.createElement('span');
        docSpan.className = 'editable-text';
        docSpan.dataset.editable = '';
        docSpan.dataset.field = 'docRef';
        docSpan.dataset.entryIndex = index;
        docSpan.textContent = entry.docRef;

        const prSpan = document.createElement('span');
        prSpan.className = 'editable-text';
        prSpan.dataset.editable = '';
        prSpan.dataset.field = 'prLink';
        prSpan.dataset.entryIndex = index;
        prSpan.textContent = entry.pr.label;

        const prButton = document.createElement('button');
        prButton.type = 'button';
        prButton.className = 'link-button';
        prButton.dataset.url = entry.pr.url;
        prButton.textContent = 'â†—';
        prButton.title = 'Open PR in new tab';

        detailLine.appendChild(tsSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(docSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(prSpan);
        detailLine.appendChild(prButton);

        body.appendChild(detailLine);

        entry.sections.forEach((section, sectionIndex) => {
          const sectionTitle = document.createElement('div');
          sectionTitle.className = 'section-title editable-text';
          sectionTitle.dataset.editable = '';
          sectionTitle.dataset.field = 'sectionTitle';
          sectionTitle.dataset.entryIndex = index;
          sectionTitle.dataset.sectionIndex = sectionIndex;
          sectionTitle.textContent = section.title;
          body.appendChild(sectionTitle);

          const sectionBody = document.createElement('div');
          sectionBody.className = 'section-body';

          section.lines.forEach((line, lineIndex) => {
            const lineEl = document.createElement('div');
            lineEl.className = 'entry-line editable-text';
            lineEl.dataset.editable = '';
            lineEl.dataset.field = 'sectionLine';
            lineEl.dataset.entryIndex = index;
            lineEl.dataset.sectionIndex = sectionIndex;
            lineEl.dataset.lineIndex = lineIndex;

            const textSpan = document.createElement('span');
            textSpan.className = 'line-text';
            textSpan.textContent = line || '';
            lineEl.appendChild(textSpan);

            const fileInfo = parseFileLine(line);
            if (fileInfo) {
              const linkGroup = createFileLinkElements(fileInfo.path);
              if (linkGroup) {
                lineEl.appendChild(linkGroup);
              }
            }

            findUrls(line).forEach(url => {
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'open-link';
              openButton.dataset.url = url;
              openButton.textContent = 'â†—';
              openButton.title = 'Open link in new tab';
              lineEl.appendChild(openButton);
            });

            sectionBody.appendChild(lineEl);
          });

          body.appendChild(sectionBody);
        });

        entryEl.appendChild(body);
        dom.entryList.appendChild(entryEl);
      });
    }

    function pipeSeparator() {
      const span = document.createElement('span');
      span.className = 'pipe';
      span.textContent = '|';
      return span;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function parseFileLine(text) {
      if (!text) return null;
      const match = /^Filename:\s*(.+)$/i.exec(text.trim());
      if (!match) return null;
      const rawPath = match[1].trim();
      if (!rawPath || /<.*>/.test(rawPath)) return null;
      return { path: rawPath };
    }

    function createFileLinkElements(path) {
      if (!repoContext || !repoContext.owner || !repoContext.repo) return null;
      const normalizedPath = normalizeFilePath(path);
      if (!normalizedPath) return null;
      const encodedPath = encodePathForUrl(normalizedPath);
      const branchName = (repoContext.branch || DEFAULT_REPO_CONTEXT.branch || 'main').trim();
      const encodedBranch = encodeURIComponent(branchName);

      const container = document.createElement('span');
      container.className = 'file-links';

      const githubLink = document.createElement('a');
      githubLink.className = 'file-link';
      githubLink.href = `https://github.com/${repoContext.owner}/${repoContext.repo}/blob/${encodedBranch}/${encodedPath}`;
      githubLink.target = '_blank';
      githubLink.rel = 'noopener noreferrer';
      githubLink.textContent = 'GitHub â†—';
      githubLink.title = `Open ${normalizedPath} on GitHub (${branchName})`;

      const pagesLink = document.createElement('a');
      pagesLink.className = 'file-link';
      pagesLink.href = `https://${repoContext.owner}.github.io/${repoContext.repo}/${encodedPath}`;
      pagesLink.target = '_blank';
      pagesLink.rel = 'noopener noreferrer';
      pagesLink.textContent = 'Pages â†—';
      pagesLink.title = `Open ${normalizedPath} on GitHub Pages`;

      const swallowDoubleClick = event => {
        event.preventDefault();
        event.stopPropagation();
      };
      container.addEventListener('dblclick', swallowDoubleClick);
      githubLink.addEventListener('dblclick', swallowDoubleClick);
      pagesLink.addEventListener('dblclick', swallowDoubleClick);

      container.appendChild(githubLink);
      container.appendChild(pagesLink);
      return container;
    }

    function normalizeFilePath(path) {
      if (!path) return '';
      return String(path)
        .trim()
        .replace(/^[\\/]+/, '')
        .replace(/\\+/g, '/');
    }

    function encodePathForUrl(path) {
      return normalizeFilePath(path)
        .split('/')
        .filter(segment => segment.length)
        .map(segment => encodeURIComponent(segment))
        .join('/');
    }

    function findUrls(text) {
      if (!text) return [];
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      const matches = [];
      let match;
      while ((match = urlRegex.exec(text)) !== null) {
        matches.push(match[0]);
      }
      return matches;
    }

    function ensureEntriesAvailable() {
      if (entries && entries.length) {
        return true;
      }
      setStatus('No entries available to export yet.', true);
      return false;
    }

    function formatExportStatus(label) {
      const repoLabel = formatRepoContextLabel();
      return `Exported entries as ${label}${repoLabel ? ` for ${repoLabel}` : ''}.`;
    }

    function buildFilename(prefix, extension) {
      const repoPart = repoContext && repoContext.owner && repoContext.repo
        ? `${repoContext.owner}-${repoContext.repo}`
        : '';
      const sanitizedRepo = repoPart.replace(/[^a-zA-Z0-9-_]+/g, '-');
      const prefixPart = sanitizedRepo ? `${prefix}-${sanitizedRepo}` : prefix;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      return `${prefixPart}-${timestamp}.${extension}`;
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function formatEntriesAsPlainText(entriesList) {
      const lines = [];
      const repoLabel = formatRepoContextLabel();
      if (repoLabel) {
        lines.push(`Repository: ${repoLabel}`);
        lines.push('');
      }
      entriesList.forEach(entry => {
        const idPart = entry.id !== undefined && entry.id !== null ? `#${entry.id}` : '';
        const titlePart = entry.title || '';
        const heading = [idPart, titlePart].filter(Boolean).join(' ').trim() || 'Untitled entry';
        lines.push(heading);
        if (entry.summary) lines.push(`Summary: ${entry.summary}`);
        if (entry.timestamp) lines.push(`Timestamp: ${entry.timestamp}`);
        if (entry.docRef) lines.push(`Doc: ${entry.docRef}`);
        if (entry.pr && (entry.pr.label || entry.pr.url)) {
          const prLabel = entry.pr.label || 'PR link';
          const prUrl = entry.pr.url ? ` (${entry.pr.url})` : '';
          lines.push(`PR: ${prLabel}${prUrl}`);
        }
        lines.push(`Include: ${entry.include ? 'Yes' : 'No'}`);
        if (entry.sections && entry.sections.length) {
          entry.sections.forEach(section => {
            lines.push('');
            lines.push(section.title || '(untitled section)');
            (section.lines || []).forEach(line => {
              lines.push(`  â€¢ ${line || ''}`);
            });
          });
        }
        lines.push('');
      });
      const output = lines.join('\n').trim();
      return output.length ? output : 'No entries available.';
    }

    function formatEntriesAsMarkdown(entriesList) {
      const lines = [];
      const repoLabel = formatRepoContextLabel();
      if (repoLabel) {
        lines.push(`# Checklist for ${repoLabel}`);
      } else {
        lines.push('# Checklist Entries');
      }
      lines.push('');
      entriesList.forEach(entry => {
        const idPart = entry.id !== undefined && entry.id !== null ? `#${entry.id}` : '';
        const titlePart = entry.title || '';
        const heading = [idPart, titlePart].filter(Boolean).join(' Â· ') || '(untitled entry)';
        lines.push(`## ${heading}`);
        if (entry.summary) lines.push(`- **Summary:** ${entry.summary}`);
        if (entry.timestamp) lines.push(`- **Timestamp:** ${entry.timestamp}`);
        if (entry.docRef) lines.push(`- **Doc:** ${entry.docRef}`);
        if (entry.pr && (entry.pr.label || entry.pr.url)) {
          if (entry.pr.url) {
            const label = entry.pr.label || 'View PR';
            lines.push(`- **PR:** [${label}](${entry.pr.url})`);
          } else {
            lines.push(`- **PR:** ${entry.pr.label}`);
          }
        }
        lines.push(`- **Include:** ${entry.include ? 'Include' : 'Exclude'}`);
        lines.push('');
        if (entry.sections && entry.sections.length) {
          entry.sections.forEach(section => {
            lines.push(`### ${section.title || '(untitled section)'}`);
            (section.lines || []).forEach(line => {
              lines.push(`- ${line || ''}`);
            });
            lines.push('');
          });
        }
      });
      return lines.join('\n').trim();
    }

    function formatEntriesAsCsv(entriesList) {
      const repoLabel = formatRepoContextLabel();
      const header = ['Repository', 'Entry ID', 'Title', 'Section', 'Line', 'Included', 'Timestamp'];
      const rows = [header];
      if (!entriesList.length) {
        rows.push([repoLabel || '', '', '', '', '', '', '']);
      } else {
        entriesList.forEach(entry => {
          const base = [repoLabel || '', entry.id ?? '', entry.title || '', '', '', entry.include ? 'Include' : 'Exclude', entry.timestamp || ''];
          if (entry.sections && entry.sections.length) {
            entry.sections.forEach(section => {
              const sectionTitle = section.title || '';
              if (section.lines && section.lines.length) {
                section.lines.forEach(line => {
                  const row = [...base];
                  row[3] = sectionTitle;
                  row[4] = line || '';
                  rows.push(row);
                });
              } else {
                const row = [...base];
                row[3] = sectionTitle;
                rows.push(row);
              }
            });
          } else {
            rows.push(base);
          }
        });
      }
      return rows.map(columns => columns.map(escapeCsv).join(',')).join('\n');
    }

    function escapeCsv(value) {
      if (value === null || value === undefined) return '';
      const stringValue = String(value);
      return /[",\n]/.test(stringValue) ? `"${stringValue.replace(/"/g, '""')}"` : stringValue;
    }

    function handleExportJson() {
      if (!ensureEntriesAvailable()) return;
      const payload = {
        exportedAt: new Date().toISOString(),
        stateSource,
        repoContext,
        entries
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      downloadBlob(blob, buildFilename('viewer-entries', 'json'));
      setStatus(formatExportStatus('JSON bundle'));
    }

    function handleExportTxt() {
      if (!ensureEntriesAvailable()) return;
      const text = formatEntriesAsPlainText(entries);
      const blob = new Blob([text], { type: 'text/plain' });
      downloadBlob(blob, buildFilename('viewer-entries', 'txt'));
      setStatus(formatExportStatus('plain text file'));
    }

    function handleExportMarkdown() {
      if (!ensureEntriesAvailable()) return;
      const markdown = formatEntriesAsMarkdown(entries);
      const blob = new Blob([markdown], { type: 'text/markdown' });
      downloadBlob(blob, buildFilename('viewer-entries', 'md'));
      setStatus(formatExportStatus('Markdown document'));
    }

    function handleExportCsv() {
      if (!ensureEntriesAvailable()) return;
      const csv = formatEntriesAsCsv(entries);
      const blob = new Blob([csv], { type: 'text/csv' });
      downloadBlob(blob, buildFilename('viewer-entries', 'csv'));
      setStatus(formatExportStatus('CSV file'));
    }

    async function handleExportPdf() {
      if (!ensureEntriesAvailable()) return;
      try {
        const jsPDF = await loadJsPdf();
        const doc = new jsPDF({ unit: 'pt', format: 'letter' });
        const text = formatEntriesAsPlainText(entries);
        const maxWidth = doc.internal.pageSize.getWidth() - 80;
        const lines = doc.splitTextToSize(text, maxWidth);
        let y = 60;
        const lineHeight = 16;
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(12);
        lines.forEach(line => {
          if (y > doc.internal.pageSize.getHeight() - 40) {
            doc.addPage();
            y = 60;
          }
          doc.text(line, 40, y);
          y += lineHeight;
        });
        doc.save(buildFilename('viewer-entries', 'pdf'));
        setStatus(formatExportStatus('PDF document'));
      } catch (error) {
        console.error('PDF export failed', error);
        setStatus(`PDF export failed: ${error.message}`, true);
      }
    }

    function loadJsPdf() {
      if (window.jspdf && window.jspdf.jsPDF) {
        return Promise.resolve(window.jspdf.jsPDF);
      }
      if (!jsPdfLoader) {
        jsPdfLoader = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          script.onload = () => {
            if (window.jspdf && window.jspdf.jsPDF) {
              resolve(window.jspdf.jsPDF);
            } else {
              reject(new Error('jsPDF library unavailable after load.'));
            }
          };
          script.onerror = () => reject(new Error('Failed to load jsPDF library.'));
          document.head.appendChild(script);
        }).catch(error => {
          jsPdfLoader = null;
          throw error;
        });
      }
      return jsPdfLoader;
    }

    function handleEntryClick(event) {
      const toggle = event.target.closest('.entry-toggle');
      if (toggle) {
        const entryEl = toggle.closest('.entry');
        if (!entryEl) return;
        const index = Number(entryEl.dataset.index);
        if (openEntries.has(index)) {
          openEntries.delete(index);
        } else {
          openEntries.add(index);
        }
        renderEntries();
        event.preventDefault();
        return;
      }

      const includeToggle = event.target.closest('input[data-role="include-toggle"]');
      if (includeToggle) {
        const index = Number(includeToggle.dataset.entryIndex);
        entries[index].include = includeToggle.checked;
        renderEntries();
        setStatus(`Entry #${entries[index].id} marked as ${includeToggle.checked ? 'included' : 'excluded'}.`);
        return;
      }

      const linkButton = event.target.closest('[data-url]');
      if (linkButton && linkButton.dataset.url) {
        window.open(linkButton.dataset.url, '_blank');
        return;
      }
    }

    function handleDoubleClick(event) {
      const editable = event.target.closest('[data-editable]');
      if (!editable) return;
      event.preventDefault();
      event.stopPropagation();

      const entryIndex = Number(editable.dataset.entryIndex);
      const field = editable.dataset.field;
      const sectionIndex = editable.dataset.sectionIndex ? Number(editable.dataset.sectionIndex) : null;
      const lineIndex = editable.dataset.lineIndex ? Number(editable.dataset.lineIndex) : null;

      if (field === 'prLink') {
        const currentLink = entries[entryIndex].pr;
        startLinkEditing(editable, currentLink, updatedLink => {
          entries[entryIndex].pr = updatedLink;
          renderEntries();
          setStatus('Updated PR link.');
        });
        return;
      }

      if (field === 'sectionTitle' || field === 'sectionLine' || field === 'summary' || field === 'title' || field === 'docRef' || field === 'timestamp') {
        startTextEditing(editable, getValue(entryIndex, field, sectionIndex, lineIndex), newValue => {
          setValue(entryIndex, field, newValue, sectionIndex, lineIndex);
        });
        return;
      }
    }

    function getValue(entryIndex, field, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      switch (field) {
        case 'title':
          return entry.title;
        case 'summary':
          return entry.summary;
        case 'timestamp':
          return entry.timestamp;
        case 'docRef':
          return entry.docRef;
        case 'sectionTitle':
          return entry.sections[sectionIndex].title;
        case 'sectionLine':
          return entry.sections[sectionIndex].lines[lineIndex];
        default:
          return '';
      }
    }

    function setValue(entryIndex, field, value, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      const trimmed = typeof value === 'string' ? value.trim() : value;
      switch (field) {
        case 'title':
          entry.title = trimmed;
          break;
        case 'summary':
          entry.summary = trimmed;
          break;
        case 'timestamp':
          entry.timestamp = trimmed;
          break;
        case 'docRef':
          entry.docRef = trimmed;
          break;
        case 'sectionTitle':
          entry.sections[sectionIndex].title = trimmed;
          break;
        case 'sectionLine':
          entry.sections[sectionIndex].lines[lineIndex] = value;
          break;
      }
      renderEntries();
      setStatus('Updated entry content.');
    }

    function startLinkEditing(element, currentLink, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');

      const wrapper = document.createElement('div');
      wrapper.className = 'link-editor';

      const labelInput = document.createElement('input');
      labelInput.type = 'text';
      labelInput.placeholder = 'Link label';
      labelInput.value = currentLink.label || '';

      const urlInput = document.createElement('input');
      urlInput.type = 'url';
      urlInput.placeholder = 'https://example.com';
      urlInput.value = currentLink.url || '';

      const actions = document.createElement('div');
      actions.className = 'editor-actions';

      const cancelButton = document.createElement('button');
      cancelButton.type = 'button';
      cancelButton.className = 'cancel';
      cancelButton.textContent = 'Cancel';

      const saveButton = document.createElement('button');
      saveButton.type = 'button';
      saveButton.className = 'save';
      saveButton.textContent = 'Save';

      actions.appendChild(cancelButton);
      actions.appendChild(saveButton);

      wrapper.appendChild(labelInput);
      wrapper.appendChild(urlInput);
      wrapper.appendChild(actions);

      element.textContent = '';
      element.appendChild(wrapper);
      labelInput.focus();
      labelInput.setSelectionRange(labelInput.value.length, labelInput.value.length);

      const commit = () => {
        const nextLabel = labelInput.value.trim() || 'Link';
        const nextUrl = urlInput.value.trim();
        element.classList.remove('editing');
        onSave({ label: nextLabel, url: nextUrl });
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      cancelButton.addEventListener('click', cancel);
      saveButton.addEventListener('click', commit);

      [labelInput, urlInput].forEach(input => {
        input.addEventListener('keydown', event => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (input === labelInput) {
              urlInput.focus();
              urlInput.setSelectionRange(urlInput.value.length, urlInput.value.length);
            } else {
              commit();
            }
          } else if (event.key === 'Escape') {
            event.preventDefault();
            cancel();
          }
        });
      });

      urlInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
      labelInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
    }

    function startTextEditing(element, currentValue, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');
      const isMultiline = currentValue && currentValue.length > 60;
      const input = document.createElement(isMultiline ? 'textarea' : 'input');
      if (isMultiline) {
        input.className = 'inline-editor-area';
        input.rows = Math.min(6, Math.max(2, Math.ceil(currentValue.length / 60)));
      } else {
        input.className = 'inline-editor';
      }
      input.value = currentValue || '';
      element.textContent = '';
      element.appendChild(input);
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);

      const commit = () => {
        const newValue = isMultiline ? input.value : input.value;
        element.classList.remove('editing');
        onSave(newValue);
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', event => {
        if (event.key === 'Enter' && !event.shiftKey && !isMultiline) {
          event.preventDefault();
          commit();
        } else if (event.key === 'Escape') {
          event.preventDefault();
          cancel();
        }
      });
    }

    function handleRefresh({ silent = false } = {}) {
      entries = loadState();
      openEntries.clear();
      renderEntries();
      if (silent) return;
      let message;
      const repoLabel = formatRepoContextLabel();
      if (stateSource === 'shared') {
        message = `Reloaded entries from shared checklist${repoLabel ? ` for ${repoLabel}` : ''}.`;
      } else if (stateSource === 'local') {
        message = `Reloaded entries from local storage${repoLabel ? ` for ${repoLabel}` : ''}.`;
      } else if (stateSource === 'import') {
        message = `Reloaded imported entries${repoLabel ? ` for ${repoLabel}` : ''}.`;
      } else {
        message = 'Loaded default checklist sample.';
      }
      setStatus(message);
    }

    function handleImport(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const parsed = JSON.parse(e.target.result);
          let importedEntries;
          let importedRepoContext = null;
          if (Array.isArray(parsed)) {
            importedEntries = parsed;
          } else if (parsed && typeof parsed === 'object' && Array.isArray(parsed.entries)) {
            importedEntries = parsed.entries;
            importedRepoContext = parsed.repoContext || findRepoContext(parsed);
          } else {
            throw new Error('JSON must be an array of entries or an object with an "entries" array.');
          }
          entries = cloneEntries(importedEntries);
          applyRepoContext(importedRepoContext);
          stateSource = 'import';
          openEntries.clear();
          renderEntries();
          const repoLabel = formatRepoContextLabel();
          setStatus(`Imported ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'}${repoLabel ? ` for ${repoLabel}` : ''}.`);
        } catch (error) {
          console.error('Import failed', error);
          setStatus('Import failed: ' + error.message, true);
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    dom.entryList.addEventListener('click', handleEntryClick);
    dom.entryList.addEventListener('dblclick', handleDoubleClick);
    dom.refreshButton.addEventListener('click', () => handleRefresh());
    dom.exportJsonButton.addEventListener('click', handleExportJson);
    dom.exportTxtButton.addEventListener('click', handleExportTxt);
    dom.exportMarkdownButton.addEventListener('click', handleExportMarkdown);
    dom.exportCsvButton.addEventListener('click', handleExportCsv);
    dom.exportPdfButton.addEventListener('click', handleExportPdf);
    dom.saveButton.addEventListener('click', saveState);
    dom.importInput.addEventListener('change', handleImport);

    window.addEventListener('storage', event => {
      if (event.key === STORAGE_KEY || SHARED_STORAGE_KEYS.includes(event.key)) {
        handleRefresh({ silent: true });
      }
    });

    renderEntries();
  </script>
</body>
</html>
