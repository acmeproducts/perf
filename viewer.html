<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Review Viewer</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      --bg: #f7f8fc;
      --bg-dark: #151922;
      --panel: #ffffff;
      --panel-dark: #1f2430;
      --border: #dde1ee;
      --border-dark: #2e3445;
      --muted: #6b7280;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.12);
      --success: #16a34a;
      --danger: #dc2626;
      line-height: 1.6;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, rgba(79, 70, 229, 0.12), transparent 320px) var(--bg);
      color: #111827;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(180deg, rgba(99, 102, 241, 0.32), transparent 320px) var(--bg-dark);
        color: #e5e7eb;
      }
    }

    header {
      padding: 32px clamp(20px, 4vw, 48px) 12px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 5vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    header p {
      margin: 8px 0 0;
      max-width: 720px;
      color: var(--muted);
    }

    .app-shell {
      padding: 0 clamp(20px, 4vw, 48px) 48px;
    }

    .tab-bar {
      display: flex;
      gap: 8px;
      border-bottom: 1px solid var(--border);
    }

    .tab-button {
      position: relative;
      appearance: none;
      background: none;
      border: none;
      font: inherit;
      padding: 12px 18px;
      border-radius: 12px 12px 0 0;
      cursor: pointer;
      color: var(--muted);
      transition: color 0.2s ease, background-color 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent);
      background: var(--panel);
      box-shadow: 0 -8px 24px rgba(15, 23, 42, 0.08);
    }

    .tab-panel {
      display: none;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 0 16px 16px 16px;
      padding: 24px;
      margin-top: -1px;
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.08);
    }

    .tab-panel.active {
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .tab-button.active {
        background: var(--panel-dark);
        color: #c7d2fe;
        box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.35);
      }

      .tab-panel {
        background: var(--panel-dark);
        border-color: var(--border-dark);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.35);
      }
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 20px;
    }

    .toolbar button,
    .toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(79, 70, 229, 0.06);
      color: var(--accent);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .toolbar button:hover,
    .toolbar label:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .toolbar label input {
      display: none;
    }

    #status-bar {
      min-height: 24px;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 20px;
    }

    .entries {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .entry {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.85);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }

    .entry.open {
      box-shadow: 0 20px 44px rgba(15, 23, 42, 0.12);
    }

    .entry.excluded {
      opacity: 0.55;
    }

    @media (prefers-color-scheme: dark) {
      .entry {
        background: rgba(31, 36, 48, 0.9);
        border-color: var(--border-dark);
      }

      .entry.open {
        box-shadow: 0 20px 44px rgba(0, 0, 0, 0.55);
      }
    }

    .entry-header {
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: default;
    }

    .entry-toggle {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .entry.open .entry-toggle {
      transform: rotate(90deg);
    }

    .entry-header-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-weight: 600;
    }

    .entry-header-meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.95rem;
    }

    .separator::before {
      content: "Â·";
      color: var(--muted);
      margin: 0 4px;
    }

    .editable-text {
      position: relative;
      padding: 2px 4px;
      border-radius: 6px;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .editable-text:hover {
      background: rgba(79, 70, 229, 0.08);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.18);
      cursor: text;
    }

    .editable-text.editing {
      background: rgba(79, 70, 229, 0.12);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.35);
    }

    .include-toggle {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .include-toggle input {
      width: 44px;
      height: 24px;
      appearance: none;
      background: rgba(79, 70, 229, 0.25);
      border-radius: 999px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .include-toggle input::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 4px;
      width: 18px;
      height: 18px;
      background: #ffffff;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
      transition: transform 0.2s ease;
    }

    .include-toggle input:not(:checked) {
      background: rgba(148, 163, 184, 0.35);
    }

    .include-toggle input:checked::after {
      transform: translateX(18px);
    }

    .entry-body {
      margin-top: 16px;
      border-top: 1px solid var(--border);
      padding-top: 16px;
      display: none;
      gap: 12px;
      flex-direction: column;
    }

    .entry.open .entry-body {
      display: flex;
    }

    .detail-line {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.95rem;
    }

    .detail-line .pipe {
      color: var(--muted);
    }

    .link-button {
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid transparent;
      background: rgba(79, 70, 229, 0.08);
      color: var(--accent);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      font-size: 0.85rem;
    }

    .link-button:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .section-title {
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .section-title.editable-text:hover {
      cursor: text;
    }

    .section-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .entry-line {
      position: relative;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 0.93rem;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .entry-line:hover {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.3);
      cursor: text;
    }

    .entry-line .line-text {
      display: inline;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .entry-line .open-link {
      margin-left: 8px;
      border: 1px solid rgba(79, 70, 229, 0.2);
      background: rgba(79, 70, 229, 0.12);
      color: var(--accent);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .entry-line .open-link:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .file-links {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-left: 8px;
      font-size: 0.82rem;
    }

    .file-links a {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(79, 70, 229, 0.18);
      background: rgba(79, 70, 229, 0.1);
      color: var(--accent);
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .file-links a:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .inline-editor,
    .inline-editor-area {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
      resize: vertical;
    }

    .inline-editor-area {
      min-height: 56px;
    }

    .link-editor {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .link-editor input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
    }

    .link-editor .editor-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .link-editor button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 600;
    }

    .link-editor .save {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .link-editor .cancel {
      background: rgba(248, 113, 113, 0.12);
      color: var(--danger);
    }

    .link-editor .save:hover {
      background: rgba(34, 197, 94, 0.25);
    }

    .link-editor .cancel:hover {
      background: rgba(248, 113, 113, 0.2);
    }

    @media (max-width: 920px) {
      .entry-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .include-toggle {
        margin-left: 0;
      }

      .detail-line {
        flex-direction: column;
        align-items: flex-start;
      }

      .detail-line .pipe {
        display: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Codex Review Viewer</h1>
    <p>Track review artefacts, toggle inclusion, and edit contextual notes inline. Double-click any line to update it.</p>
  </header>
  <div class="app-shell">
    <nav class="tab-bar" role="tablist">
      <button class="tab-button active" id="tab-view" role="tab" aria-selected="true" aria-controls="panel-view">View</button>
    </nav>
    <section class="tab-panel active" id="panel-view" role="tabpanel" aria-labelledby="tab-view">
      <div class="toolbar">
        <button type="button" id="refresh-button">â†» Refresh</button>
        <label for="import-input">â¬† Import JSON<input id="import-input" type="file" accept="application/json" /></label>
        <button type="button" id="export-button">â¬‡ Export JSON</button>
        <button type="button" id="export-text-button">â¬‡ Export TXT</button>
        <button type="button" id="export-markdown-button">â¬‡ Export Markdown</button>
        <button type="button" id="export-csv-button">â¬‡ Export CSV</button>
        <button type="button" id="export-pdf-button">â¬‡ Export PDF</button>
        <button type="button" id="save-button">ðŸ’¾ Save JSON</button>
      </div>
      <div id="status-bar" role="status" aria-live="polite"></div>
      <div class="entries" id="entry-list"></div>
    </section>
  </div>
  <script src="codex-checklist-shared.js"></script>
  <script>

    const defaultEntries = [
      {
        id: 76,
        title: 'Adjust touch end handling for drag gestures',
        summary: 'Ensure release events stay smooth for cross-browser sync scenarios.',
        timestamp: '9/27/2025, 6:05:13 PM',
        docRef: 'codex/review-analysis-v9-cross-browser-sync.md-77an0q',
        pr: {
          label: 'View PR',
          url: 'https://github.com/user/repo/pull/76'
        },
        include: true,
        sections: [
          {
            title: '------ live links',
            lines: [
              'https://chatgpt.com/codex/tasks/task_e_68d7b9a3f380832db7d50f1434ad43a8',
              'Filename: ui-v9a.htnl',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>',
              'Filename: ui-v9b.html',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>'
            ]
          },
          {
            title: '------- item metadata',
            lines: [
              'Tags',
              'Add tag and press Enter',
              '',
              'Notes',
              'Add checklist notesâ€¦',
              '',
              'Status:'
            ]
          }
        ]
      }
    ];

    const codex = window.CodexChecklist;

    const dom = {
      entryList: document.getElementById('entry-list'),
      refreshButton: document.getElementById('refresh-button'),
      exportButton: document.getElementById('export-button'),
      exportTextButton: document.getElementById('export-text-button'),
      exportMarkdownButton: document.getElementById('export-markdown-button'),
      exportCsvButton: document.getElementById('export-csv-button'),
      exportPdfButton: document.getElementById('export-pdf-button'),
      saveButton: document.getElementById('save-button'),
      importInput: document.getElementById('import-input'),
      statusBar: document.getElementById('status-bar')
    };

    const openEntries = new Set();

    const derivedState = {
      repoContext: null,
      normalizedEntries: [],
      jsonPayload: null,
      textContent: '',
      markdownContent: '',
      csvContent: '',
      pdfBlob: null
    };

    let currentChecklist = initializeCurrentChecklist();
    let entries = cloneEntries(currentChecklist?.payload?.entries || defaultEntries);
    if (!entries.length) {
      entries = cloneEntries(defaultEntries);
    }

    let pendingSaveKey = null;

    function initializeCurrentChecklist() {
      if (!codex) return null;
      if (codex.current) return codex.current;
      const latest = codex.loadLatest();
      if (latest) {
        codex.setCurrent(latest, { dispatchEvent: false, bubble: false });
        return codex.current;
      }
      return null;
    }

    function formatLabel(info) {
      if (!info) return 'unknown repository';
      return `${info.owner}/${info.repo}`;
    }

    function cloneEntries(data) {
      try {
        return JSON.parse(JSON.stringify(Array.isArray(data) ? data : []));
      } catch (error) {
        console.warn('Failed to clone entries', error);
        return Array.isArray(data) ? data.slice() : [];
      }
    }

    function normalizeEntriesForExport(data) {
      return cloneEntries(data).map(entry => {
        const normalized = {
          id: entry?.id ?? '',
          title: entry?.title ?? '',
          summary: entry?.summary ?? '',
          timestamp: entry?.timestamp ?? '',
          docRef: entry?.docRef ?? '',
          include: entry?.include !== false,
          pr: {
            label: entry?.pr?.label ?? '',
            url: entry?.pr?.url ?? ''
          },
          sections: []
        };
        if (Array.isArray(entry?.sections)) {
          normalized.sections = entry.sections.map(section => ({
            title: section?.title ?? '',
            lines: Array.isArray(section?.lines) ? section.lines.map(line => line ?? '') : []
          }));
        }
        return normalized;
      });
    }

    function deriveRepoContext(normalizedEntries) {
      let owner = currentChecklist?.owner || null;
      let repo = currentChecklist?.repo || null;
      let branch = currentChecklist?.payload?.branch
        || currentChecklist?.payload?.defaultBranch
        || currentChecklist?.payload?.branchName
        || currentChecklist?.payload?.currentBranch
        || null;

      if ((!owner || !repo) && Array.isArray(normalizedEntries)) {
        for (const entry of normalizedEntries) {
          const prUrl = entry?.pr?.url;
          if (!prUrl) continue;
          try {
            const parsed = new URL(prUrl);
            const parts = parsed.pathname.split('/').filter(Boolean);
            if (parts.length >= 2) {
              owner = owner || parts[0];
              repo = repo || parts[1];
            }
            if (owner && repo) break;
          } catch (error) {
            console.warn('Unable to parse PR URL for repo context', prUrl, error);
          }
        }
      }

      if (!branch) {
        branch = 'main';
      }

      if (!owner || !repo) {
        return null;
      }

      return {
        owner,
        repo,
        branch,
        pagesHost: `${owner.toLowerCase()}.github.io`
      };
    }

    function buildTextExport(normalizedEntries, repoContext) {
      const lines = [];
      if (repoContext) {
        lines.push(`Repository: ${repoContext.owner}/${repoContext.repo}`);
        lines.push(`Branch: ${repoContext.branch}`);
        lines.push('');
      }
      normalizedEntries.forEach(entry => {
        lines.push(`#${entry.id || 'N/A'} ${entry.title || ''}`.trim());
        lines.push(`Summary: ${entry.summary || ''}`);
        lines.push(`Timestamp: ${entry.timestamp || ''}`);
        lines.push(`Doc: ${entry.docRef || ''}`);
        lines.push(`Include: ${entry.include ? 'Yes' : 'No'}`);
        if (entry.pr?.url || entry.pr?.label) {
          const label = entry.pr.label ? `${entry.pr.label}: ` : '';
          lines.push(`PR: ${label}${entry.pr.url || ''}`.trim());
        }
        entry.sections.forEach(section => {
          if (!section.title && !section.lines.length) return;
          lines.push(`  ${section.title || 'Section'}`.trim());
          section.lines.forEach(line => {
            lines.push('    - ' + (line || ''));
          });
        });
        lines.push('');
      });
      return lines.join('\n');
    }

    function buildMarkdownExport(normalizedEntries, repoContext) {
      const lines = [];
      if (repoContext) {
        lines.push(`# Checklist for ${repoContext.owner}/${repoContext.repo}`);
        lines.push(`*Branch:* \`${repoContext.branch}\``);
        lines.push('');
      }
      normalizedEntries.forEach(entry => {
        lines.push(`## #${entry.id || 'N/A'} ${entry.title || ''}`.trim());
        lines.push(`- **Include:** ${entry.include ? 'Yes' : 'No'}`);
        if (entry.summary) {
          lines.push(`- **Summary:** ${entry.summary}`);
        }
        if (entry.timestamp) {
          lines.push(`- **Timestamp:** ${entry.timestamp}`);
        }
        if (entry.docRef) {
          lines.push(`- **Doc:** ${entry.docRef}`);
        }
        if (entry.pr?.url || entry.pr?.label) {
          const label = entry.pr.label || entry.pr.url;
          const url = entry.pr.url || '';
          if (url) {
            lines.push(`- **PR:** [${label}](${url})`);
          } else if (label) {
            lines.push(`- **PR:** ${label}`);
          }
        }
        if (entry.sections.length) {
          lines.push('');
          entry.sections.forEach(section => {
            if (section.title) {
              lines.push(`### ${section.title}`);
            }
            section.lines.forEach(line => {
              lines.push(`- ${line || ''}`);
            });
            lines.push('');
          });
        }
        lines.push('');
      });
      return lines.join('\n').replace(/\n{3,}/g, '\n\n');
    }

    function csvEscape(value) {
      const stringValue = String(value ?? '');
      if (/[",\n]/.test(stringValue)) {
        return '"' + stringValue.replace(/"/g, '""') + '"';
      }
      return stringValue;
    }

    function buildCsvExport(normalizedEntries) {
      const headers = ['Entry ID', 'Include', 'Title', 'Summary', 'Timestamp', 'Doc Ref', 'PR Label', 'PR URL', 'Section', 'Line Index', 'Line'];
      const rows = [headers.join(',')];
      normalizedEntries.forEach(entry => {
        if (!entry.sections.length) {
          rows.push([
            csvEscape(entry.id),
            csvEscape(entry.include ? 'Yes' : 'No'),
            csvEscape(entry.title),
            csvEscape(entry.summary),
            csvEscape(entry.timestamp),
            csvEscape(entry.docRef),
            csvEscape(entry.pr?.label || ''),
            csvEscape(entry.pr?.url || ''),
            csvEscape(''),
            csvEscape(''),
            csvEscape('')
          ].join(','));
          return;
        }
        entry.sections.forEach(section => {
          const sectionTitle = section.title || '';
          if (!section.lines.length) {
            rows.push([
              csvEscape(entry.id),
              csvEscape(entry.include ? 'Yes' : 'No'),
              csvEscape(entry.title),
              csvEscape(entry.summary),
              csvEscape(entry.timestamp),
              csvEscape(entry.docRef),
              csvEscape(entry.pr?.label || ''),
              csvEscape(entry.pr?.url || ''),
              csvEscape(sectionTitle),
              csvEscape(''),
              csvEscape('')
            ].join(','));
            return;
          }
          section.lines.forEach((line, index) => {
            rows.push([
              csvEscape(entry.id),
              csvEscape(entry.include ? 'Yes' : 'No'),
              csvEscape(entry.title),
              csvEscape(entry.summary),
              csvEscape(entry.timestamp),
              csvEscape(entry.docRef),
              csvEscape(entry.pr?.label || ''),
              csvEscape(entry.pr?.url || ''),
              csvEscape(sectionTitle),
              csvEscape(index + 1),
              csvEscape(line || '')
            ].join(','));
          });
        });
      });
      return rows.join('\n');
    }

    function escapePdfText(value) {
      return String(value ?? '').replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
    }

    function createPdfBlob(textContent) {
      const sanitized = String(textContent || '').replace(/\r\n?/g, '\n');
      const lines = sanitized.split('\n');
      const contentParts = ['BT', '/F1 10 Tf', '50 780 Td'];
      lines.forEach((line, index) => {
        if (index === 0) {
          contentParts.push(`(${escapePdfText(line)}) Tj`);
        } else {
          contentParts.push('0 -14 Td');
          contentParts.push(`(${escapePdfText(line)}) Tj`);
        }
      });
      contentParts.push('ET');
      const contentStream = contentParts.join('\n');
      const encoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
      const contentLength = encoder ? encoder.encode(contentStream).length : contentStream.length;
      const objects = [
        '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n',
        '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n',
        '3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n',
        `4 0 obj\n<< /Length ${contentLength} >>\nstream\n${contentStream}\nendstream\nendobj\n`,
        '5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n'
      ];
      const pdfParts = ['%PDF-1.4\n'];
      const offsets = [];
      const measure = value => encoder ? encoder.encode(value).length : value.length;
      let byteLength = measure(pdfParts[0]);
      objects.forEach(obj => {
        offsets.push(byteLength);
        pdfParts.push(obj);
        byteLength += measure(obj);
      });
      const xrefPosition = byteLength;
      let xref = `xref\n0 ${objects.length + 1}\n`;
      xref += '0000000000 65535 f \n';
      offsets.forEach(offset => {
        xref += offset.toString().padStart(10, '0') + ' 00000 n \n';
      });
      pdfParts.push(xref);
      byteLength += measure(xref);
      const trailer = `trailer\n<< /Size ${objects.length + 1} /Root 1 0 R >>\nstartxref\n${xrefPosition}\n%%EOF`;
      pdfParts.push(trailer);
      return new Blob(pdfParts, { type: 'application/pdf' });
    }

    function sanitizeForFilename(value) {
      return String(value ?? '').replace(/[^A-Za-z0-9._-]+/g, '-');
    }

    function getDownloadLabel() {
      if (currentChecklist) {
        const owner = sanitizeForFilename(currentChecklist.owner);
        const repo = sanitizeForFilename(currentChecklist.repo);
        const branchValue = derivedState.repoContext?.branch ? `-${sanitizeForFilename(derivedState.repoContext.branch)}` : '';
        return `${owner}-${repo}${branchValue}`;
      }
      return 'viewer-entries';
    }

    function downloadFile(content, { type, extension }) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const label = getDownloadLabel();
      const blob = content instanceof Blob ? content : new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `checklist-${label}-${timestamp}.${extension}`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function encodePathSegments(path) {
      return path.split('/').map(segment => encodeURIComponent(segment)).join('/');
    }

    function extractFileReferences(text) {
      if (!text) return [];
      const found = new Set();
      const matches = text.matchAll(/(?:File(?:name)?|Path|Page|Asset)[:\s]+([^|\n]+)/gi);
      for (const match of matches) {
        const candidate = match[1].trim();
        if (candidate) {
          candidate.split(/[,\s]+/).forEach(item => {
            const cleaned = item.replace(/^[`'"(\[]+/, '').replace(/[`'"),\]]+$/, '');
            if (isValidFileReference(cleaned)) {
              found.add(cleaned);
            }
          });
        }
      }
      text.split(/\s+/).forEach(token => {
        const cleaned = token.replace(/^[`'"(\[]+/, '').replace(/[`'"),.;:>\]]+$/, '');
        if (isValidFileReference(cleaned)) {
          found.add(cleaned);
        }
      });
      return Array.from(found);
    }

    function isValidFileReference(candidate) {
      if (!candidate) return false;
      if (candidate.includes('://')) return false;
      if (candidate.includes('<') || candidate.includes('>')) return false;
      if (!/\./.test(candidate)) return false;
      return /^[A-Za-z0-9_.\/\-]+$/.test(candidate);
    }

    function createFileLinks(path, repoContext) {
      if (!repoContext) return [];
      const normalizedPath = path.replace(/^[./]+/, '');
      if (!normalizedPath) return [];
      const encodedPath = encodePathSegments(normalizedPath);
      const githubUrl = `https://github.com/${repoContext.owner}/${repoContext.repo}/blob/${encodeURIComponent(repoContext.branch)}/${encodedPath}`;
      const pagesUrl = `https://${repoContext.pagesHost}/${repoContext.repo}/${encodedPath}`;
      const githubLink = document.createElement('a');
      githubLink.href = githubUrl;
      githubLink.target = '_blank';
      githubLink.rel = 'noopener noreferrer';
      githubLink.textContent = 'GitHub';
      githubLink.title = `Open ${normalizedPath} on GitHub (${repoContext.branch})`;

      const pagesLink = document.createElement('a');
      pagesLink.href = pagesUrl;
      pagesLink.target = '_blank';
      pagesLink.rel = 'noopener noreferrer';
      pagesLink.textContent = 'Pages';
      pagesLink.title = `Open ${normalizedPath} on GitHub Pages`;
      return [githubLink, pagesLink];
    }

    function updateDerivedState() {
      derivedState.normalizedEntries = normalizeEntriesForExport(entries);
      derivedState.repoContext = deriveRepoContext(derivedState.normalizedEntries);
      const repoContext = derivedState.repoContext;
      const normalizedEntries = derivedState.normalizedEntries;
      const payload = currentChecklist ? {
        owner: currentChecklist.owner,
        repo: currentChecklist.repo,
        branch: repoContext?.branch,
        savedAt: currentChecklist.payload?.savedAt || new Date().toISOString(),
        entries: cloneEntries(normalizedEntries)
      } : { entries: cloneEntries(normalizedEntries) };
      derivedState.jsonPayload = payload;
      derivedState.textContent = buildTextExport(normalizedEntries, repoContext);
      derivedState.markdownContent = buildMarkdownExport(normalizedEntries, repoContext);
      derivedState.csvContent = buildCsvExport(normalizedEntries);
      derivedState.pdfBlob = createPdfBlob(derivedState.textContent);
    }

    function adoptChecklist(update) {
      if (!update || !update.payload || !Array.isArray(update.payload.entries)) {
        return false;
      }
      const key = codex?.keyFor ? codex.keyFor(update.owner, update.repo) : update.key;
      currentChecklist = {
        owner: update.owner,
        repo: update.repo,
        key: key || update.key,
        payload: {
          savedAt: update.payload.savedAt,
          entries: cloneEntries(update.payload.entries)
        },
        source: update.source || null
      };
      entries = cloneEntries(update.payload.entries);
      openEntries.clear();
      renderEntries();
      return true;
    }

    function saveState() {
      if (!codex) {
        setStatus('Shared checklist utilities unavailable. Cannot save.', true);
        return;
      }
      if (!currentChecklist) {
        setStatus('No checklist selected. Load data in the checklist view first.', true);
        return;
      }
      const key = codex.keyFor(currentChecklist.owner, currentChecklist.repo);
      const payload = {
        savedAt: new Date().toISOString(),
        entries: cloneEntries(entries)
      };
      try {
        localStorage.setItem(key, JSON.stringify(payload));
        currentChecklist = {
          owner: currentChecklist.owner,
          repo: currentChecklist.repo,
          key,
          payload
        };
        pendingSaveKey = key;
        codex.broadcastUpdate({
          owner: currentChecklist.owner,
          repo: currentChecklist.repo,
          payload,
          source: 'viewer'
        });
        setStatus(`Saved checklist for ${formatLabel(currentChecklist)}.`);
      } catch (error) {
        console.error('Unable to save state', error);
        setStatus('Unable to save state. Check storage availability.', true);
      } finally {
        pendingSaveKey = null;
      }
    }

    function setStatus(message, isError = false) {
      dom.statusBar.textContent = message || '';
      dom.statusBar.style.color = isError ? 'var(--danger)' : 'var(--muted)';
      if (message) {
        clearTimeout(setStatus.timeoutId);
        setStatus.timeoutId = setTimeout(() => {
          dom.statusBar.textContent = '';
        }, 4000);
      }
    }

    function renderEntries() {
      updateDerivedState();
      const repoContext = derivedState.repoContext;
      dom.entryList.innerHTML = '';
      if (!entries.length) {
        const emptyState = document.createElement('div');
        emptyState.className = 'entry';
        emptyState.innerHTML = '<strong>No entries yet.</strong> Use Import JSON to bring in existing review data.';
        dom.entryList.appendChild(emptyState);
        return;
      }

      entries.forEach((entry, index) => {
        const entryEl = document.createElement('article');
        entryEl.className = 'entry';
        entryEl.dataset.index = index;
        if (openEntries.has(index)) {
          entryEl.classList.add('open');
        }
        if (!entry.include) {
          entryEl.classList.add('excluded');
        }

        const header = document.createElement('div');
        header.className = 'entry-header';

        const toggleButton = document.createElement('button');
        toggleButton.type = 'button';
        toggleButton.className = 'entry-toggle';
        toggleButton.setAttribute('aria-label', 'Toggle entry details');
        toggleButton.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 5l8 7-8 7"></path></svg>';
        header.appendChild(toggleButton);

        const meta = document.createElement('div');
        meta.className = 'entry-header-meta';
        meta.innerHTML = `
          <span class="entry-id">#${entry.id}</span>
          <span class="separator"></span>
          <span class="entry-title editable-text" data-editable data-field="title" data-entry-index="${index}">${escapeHtml(entry.title)}</span>
          <span class="separator"></span>
          <span class="entry-date editable-text" data-editable data-field="timestamp" data-entry-index="${index}">${escapeHtml(entry.timestamp)}</span>
          <span class="separator"></span>
          <span class="entry-summary editable-text" data-editable data-field="summary" data-entry-index="${index}">${escapeHtml(entry.summary)}</span>
        `;
        header.appendChild(meta);

        const includeWrap = document.createElement('label');
        includeWrap.className = 'include-toggle';
        includeWrap.innerHTML = `
          <span>${entry.include ? 'Include' : 'Exclude'}</span>
          <input type="checkbox" data-role="include-toggle" data-entry-index="${index}" ${entry.include ? 'checked' : ''} aria-label="Toggle include for entry ${entry.id}">
        `;
        header.appendChild(includeWrap);

        entryEl.appendChild(header);

        const body = document.createElement('div');
        body.className = 'entry-body';

        const detailLine = document.createElement('div');
        detailLine.className = 'detail-line';

        const tsSpan = document.createElement('span');
        tsSpan.className = 'editable-text';
        tsSpan.dataset.editable = '';
        tsSpan.dataset.field = 'timestamp';
        tsSpan.dataset.entryIndex = index;
        tsSpan.textContent = entry.timestamp;

        const docSpan = document.createElement('span');
        docSpan.className = 'editable-text';
        docSpan.dataset.editable = '';
        docSpan.dataset.field = 'docRef';
        docSpan.dataset.entryIndex = index;
        docSpan.textContent = entry.docRef;

        const prSpan = document.createElement('span');
        prSpan.className = 'editable-text';
        prSpan.dataset.editable = '';
        prSpan.dataset.field = 'prLink';
        prSpan.dataset.entryIndex = index;
        prSpan.textContent = entry.pr.label;

        const prButton = document.createElement('button');
        prButton.type = 'button';
        prButton.className = 'link-button';
        prButton.dataset.url = entry.pr.url;
        prButton.textContent = 'â†—';
        prButton.title = 'Open PR in new tab';

        detailLine.appendChild(tsSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(docSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(prSpan);
        detailLine.appendChild(prButton);

        body.appendChild(detailLine);

        entry.sections.forEach((section, sectionIndex) => {
          const sectionTitle = document.createElement('div');
          sectionTitle.className = 'section-title editable-text';
          sectionTitle.dataset.editable = '';
          sectionTitle.dataset.field = 'sectionTitle';
          sectionTitle.dataset.entryIndex = index;
          sectionTitle.dataset.sectionIndex = sectionIndex;
          sectionTitle.textContent = section.title;
          body.appendChild(sectionTitle);

          const sectionBody = document.createElement('div');
          sectionBody.className = 'section-body';

          section.lines.forEach((line, lineIndex) => {
            const lineEl = document.createElement('div');
            lineEl.className = 'entry-line editable-text';
            lineEl.dataset.editable = '';
            lineEl.dataset.field = 'sectionLine';
            lineEl.dataset.entryIndex = index;
            lineEl.dataset.sectionIndex = sectionIndex;
            lineEl.dataset.lineIndex = lineIndex;

            const textSpan = document.createElement('span');
            textSpan.className = 'line-text';
            textSpan.textContent = line || '';
            lineEl.appendChild(textSpan);

            findUrls(line).forEach(url => {
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'open-link';
              openButton.dataset.url = url;
              openButton.textContent = 'â†—';
              openButton.title = 'Open link in new tab';
              lineEl.appendChild(openButton);
            });

            if (repoContext) {
              const fileRefs = extractFileReferences(line);
              if (fileRefs.length) {
                const linksWrapper = document.createElement('span');
                linksWrapper.className = 'file-links';
                fileRefs.forEach(path => {
                  createFileLinks(path, repoContext).forEach(link => {
                    linksWrapper.appendChild(link);
                  });
                });
                if (linksWrapper.childNodes.length) {
                  lineEl.appendChild(linksWrapper);
                }
              }
            }

            sectionBody.appendChild(lineEl);
          });

          body.appendChild(sectionBody);
        });

        entryEl.appendChild(body);
        dom.entryList.appendChild(entryEl);
      });
    }

    function pipeSeparator() {
      const span = document.createElement('span');
      span.className = 'pipe';
      span.textContent = '|';
      return span;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function findUrls(text) {
      if (!text) return [];
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      const matches = [];
      let match;
      while ((match = urlRegex.exec(text)) !== null) {
        matches.push(match[0]);
      }
      return matches;
    }

    function handleEntryClick(event) {
      const toggle = event.target.closest('.entry-toggle');
      if (toggle) {
        const entryEl = toggle.closest('.entry');
        if (!entryEl) return;
        const index = Number(entryEl.dataset.index);
        if (openEntries.has(index)) {
          openEntries.delete(index);
        } else {
          openEntries.add(index);
        }
        renderEntries();
        event.preventDefault();
        return;
      }

      const includeToggle = event.target.closest('input[data-role="include-toggle"]');
      if (includeToggle) {
        const index = Number(includeToggle.dataset.entryIndex);
        entries[index].include = includeToggle.checked;
        renderEntries();
        setStatus(`Entry #${entries[index].id} marked as ${includeToggle.checked ? 'included' : 'excluded'}.`);
        return;
      }

      const linkButton = event.target.closest('[data-url]');
      if (linkButton && linkButton.dataset.url) {
        window.open(linkButton.dataset.url, '_blank');
        return;
      }
    }

    function handleDoubleClick(event) {
      const editable = event.target.closest('[data-editable]');
      if (!editable) return;
      event.preventDefault();
      event.stopPropagation();

      const entryIndex = Number(editable.dataset.entryIndex);
      const field = editable.dataset.field;
      const sectionIndex = editable.dataset.sectionIndex ? Number(editable.dataset.sectionIndex) : null;
      const lineIndex = editable.dataset.lineIndex ? Number(editable.dataset.lineIndex) : null;

      if (field === 'prLink') {
        const currentLink = entries[entryIndex].pr;
        startLinkEditing(editable, currentLink, updatedLink => {
          entries[entryIndex].pr = updatedLink;
          renderEntries();
          setStatus('Updated PR link.');
        });
        return;
      }

      if (field === 'sectionTitle' || field === 'sectionLine' || field === 'summary' || field === 'title' || field === 'docRef' || field === 'timestamp') {
        startTextEditing(editable, getValue(entryIndex, field, sectionIndex, lineIndex), newValue => {
          setValue(entryIndex, field, newValue, sectionIndex, lineIndex);
        });
        return;
      }
    }

    function getValue(entryIndex, field, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      switch (field) {
        case 'title':
          return entry.title;
        case 'summary':
          return entry.summary;
        case 'timestamp':
          return entry.timestamp;
        case 'docRef':
          return entry.docRef;
        case 'sectionTitle':
          return entry.sections[sectionIndex].title;
        case 'sectionLine':
          return entry.sections[sectionIndex].lines[lineIndex];
        default:
          return '';
      }
    }

    function setValue(entryIndex, field, value, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      const trimmed = typeof value === 'string' ? value.trim() : value;
      switch (field) {
        case 'title':
          entry.title = trimmed;
          break;
        case 'summary':
          entry.summary = trimmed;
          break;
        case 'timestamp':
          entry.timestamp = trimmed;
          break;
        case 'docRef':
          entry.docRef = trimmed;
          break;
        case 'sectionTitle':
          entry.sections[sectionIndex].title = trimmed;
          break;
        case 'sectionLine':
          entry.sections[sectionIndex].lines[lineIndex] = value;
          break;
      }
      renderEntries();
      setStatus('Updated entry content.');
    }

    function startLinkEditing(element, currentLink, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');

      const wrapper = document.createElement('div');
      wrapper.className = 'link-editor';

      const labelInput = document.createElement('input');
      labelInput.type = 'text';
      labelInput.placeholder = 'Link label';
      labelInput.value = currentLink.label || '';

      const urlInput = document.createElement('input');
      urlInput.type = 'url';
      urlInput.placeholder = 'https://example.com';
      urlInput.value = currentLink.url || '';

      const actions = document.createElement('div');
      actions.className = 'editor-actions';

      const cancelButton = document.createElement('button');
      cancelButton.type = 'button';
      cancelButton.className = 'cancel';
      cancelButton.textContent = 'Cancel';

      const saveButton = document.createElement('button');
      saveButton.type = 'button';
      saveButton.className = 'save';
      saveButton.textContent = 'Save';

      actions.appendChild(cancelButton);
      actions.appendChild(saveButton);

      wrapper.appendChild(labelInput);
      wrapper.appendChild(urlInput);
      wrapper.appendChild(actions);

      element.textContent = '';
      element.appendChild(wrapper);
      labelInput.focus();
      labelInput.setSelectionRange(labelInput.value.length, labelInput.value.length);

      const commit = () => {
        const nextLabel = labelInput.value.trim() || 'Link';
        const nextUrl = urlInput.value.trim();
        element.classList.remove('editing');
        onSave({ label: nextLabel, url: nextUrl });
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      cancelButton.addEventListener('click', cancel);
      saveButton.addEventListener('click', commit);

      [labelInput, urlInput].forEach(input => {
        input.addEventListener('keydown', event => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (input === labelInput) {
              urlInput.focus();
              urlInput.setSelectionRange(urlInput.value.length, urlInput.value.length);
            } else {
              commit();
            }
          } else if (event.key === 'Escape') {
            event.preventDefault();
            cancel();
          }
        });
      });

      urlInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
      labelInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
    }

    function startTextEditing(element, currentValue, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');
      const isMultiline = currentValue && currentValue.length > 60;
      const input = document.createElement(isMultiline ? 'textarea' : 'input');
      if (isMultiline) {
        input.className = 'inline-editor-area';
        input.rows = Math.min(6, Math.max(2, Math.ceil(currentValue.length / 60)));
      } else {
        input.className = 'inline-editor';
      }
      input.value = currentValue || '';
      element.textContent = '';
      element.appendChild(input);
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);

      const commit = () => {
        const newValue = isMultiline ? input.value : input.value;
        element.classList.remove('editing');
        onSave(newValue);
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', event => {
        if (event.key === 'Enter' && !event.shiftKey && !isMultiline) {
          event.preventDefault();
          commit();
        } else if (event.key === 'Escape') {
          event.preventDefault();
          cancel();
        }
      });
    }

    function handleRefresh() {
      if (!codex || !currentChecklist) {
        setStatus('No saved checklist available. Load data in the checklist view first.', true);
        return;
      }
      const reloaded = codex.loadChecklist(currentChecklist.owner, currentChecklist.repo);
      if (reloaded && adoptChecklist(reloaded)) {
        setStatus(`Reloaded ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from ${formatLabel(reloaded)}.`);
      } else {
        setStatus('No saved data found for the current repository.', true);
      }
    }

    function handleExportJson() {
      updateDerivedState();
      const payload = derivedState.jsonPayload;
      downloadFile(JSON.stringify(payload, null, 2), { type: 'application/json', extension: 'json' });
      setStatus('Exported checklist as JSON.');
    }

    function handleExportText() {
      updateDerivedState();
      downloadFile(derivedState.textContent, { type: 'text/plain', extension: 'txt' });
      setStatus('Exported checklist as plain text.');
    }

    function handleExportMarkdown() {
      updateDerivedState();
      downloadFile(derivedState.markdownContent, { type: 'text/markdown', extension: 'md' });
      setStatus('Exported checklist as Markdown.');
    }

    function handleExportCsv() {
      updateDerivedState();
      downloadFile(derivedState.csvContent, { type: 'text/csv', extension: 'csv' });
      setStatus('Exported checklist as CSV.');
    }

    function handleExportPdf() {
      updateDerivedState();
      downloadFile(derivedState.pdfBlob, { type: 'application/pdf', extension: 'pdf' });
      setStatus('Exported checklist as PDF.');
    }

    function handleImport(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const parsed = JSON.parse(e.target.result);
          let importedEntries;
          let importedChecklist = null;
          if (Array.isArray(parsed)) {
            importedEntries = parsed;
          } else if (parsed && Array.isArray(parsed.entries)) {
            importedEntries = parsed.entries;
            if (parsed.owner && parsed.repo) {
              importedChecklist = {
                owner: parsed.owner,
                repo: parsed.repo,
                payload: {
                  savedAt: parsed.savedAt || new Date().toISOString(),
                  entries: cloneEntries(parsed.entries)
                },
                source: 'import'
              };
            }
          } else {
            throw new Error('JSON must be an array or object containing an entries array.');
          }
          entries = cloneEntries(importedEntries);
          openEntries.clear();
          renderEntries();
          if (importedChecklist) {
            currentChecklist = {
              owner: importedChecklist.owner,
              repo: importedChecklist.repo,
              key: codex ? codex.keyFor(importedChecklist.owner, importedChecklist.repo) : null,
              payload: importedChecklist.payload
            };
            setStatus(`Imported ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} for ${formatLabel(importedChecklist)}. Save to persist.`, false);
          } else {
            setStatus(`Imported ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from JSON. Save to persist changes.`, false);
          }
        } catch (error) {
          console.error('Import failed', error);
          setStatus('Import failed: ' + error.message, true);
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    if (codex) {
      window.addEventListener('codexrecall:checklist-updated', event => {
        const update = event.detail;
        if (!update || !update.payload || !Array.isArray(update.payload.entries)) return;
        if (pendingSaveKey && update.key === pendingSaveKey) return;
        const wasAdopted = adoptChecklist(update);
        if (!wasAdopted) return;
        const isSameRepo = currentChecklist && update.owner === currentChecklist.owner && update.repo === currentChecklist.repo;
        if (isSameRepo) {
          setStatus(`Checklist refreshed with ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'}.`);
        } else {
          setStatus(`Switched to ${formatLabel(update)} (${entries.length} entr${entries.length === 1 ? 'y' : 'ies'}).`);
        }
      });
    }

    if (currentChecklist && entries.length) {
      setStatus(`Loaded ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from ${formatLabel(currentChecklist)}.`);
    } else {
      setStatus('No checklist loaded yet. Use the Codex checklist view or import JSON to begin.');
    }

    dom.entryList.addEventListener('click', handleEntryClick);
    dom.entryList.addEventListener('dblclick', handleDoubleClick);
    dom.refreshButton.addEventListener('click', handleRefresh);
    dom.exportButton.addEventListener('click', handleExportJson);
    dom.exportTextButton.addEventListener('click', handleExportText);
    dom.exportMarkdownButton.addEventListener('click', handleExportMarkdown);
    dom.exportCsvButton.addEventListener('click', handleExportCsv);
    dom.exportPdfButton.addEventListener('click', handleExportPdf);
    dom.saveButton.addEventListener('click', saveState);
    dom.importInput.addEventListener('change', handleImport);

    renderEntries();
  </script>
</body>
</html>
