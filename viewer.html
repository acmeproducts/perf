<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Review Viewer</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Helvetica Neue", Arial, sans-serif;
      --bg: #f7f8fc;
      --bg-dark: #151922;
      --panel: #ffffff;
      --panel-dark: #1f2430;
      --border: #dde1ee;
      --border-dark: #2e3445;
      --muted: #6b7280;
      --accent: #4f46e5;
      --accent-soft: rgba(79, 70, 229, 0.12);
      --success: #16a34a;
      --danger: #dc2626;
      line-height: 1.6;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, rgba(79, 70, 229, 0.12), transparent 320px) var(--bg);
      color: #111827;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(180deg, rgba(99, 102, 241, 0.32), transparent 320px) var(--bg-dark);
        color: #e5e7eb;
      }
    }

    header {
      padding: 32px clamp(20px, 4vw, 48px) 12px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.6rem, 5vw, 2.4rem);
      letter-spacing: -0.02em;
    }

    header p {
      margin: 8px 0 0;
      max-width: 720px;
      color: var(--muted);
    }

    .app-shell {
      padding: 0 clamp(20px, 4vw, 48px) 48px;
    }

    .tab-bar {
      display: flex;
      gap: 8px;
      border-bottom: 1px solid var(--border);
    }

    .tab-button {
      position: relative;
      appearance: none;
      background: none;
      border: none;
      font: inherit;
      padding: 12px 18px;
      border-radius: 12px 12px 0 0;
      cursor: pointer;
      color: var(--muted);
      transition: color 0.2s ease, background-color 0.2s ease;
    }

    .tab-button.active {
      color: var(--accent);
      background: var(--panel);
      box-shadow: 0 -8px 24px rgba(15, 23, 42, 0.08);
    }

    .tab-panel {
      display: none;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 0 16px 16px 16px;
      padding: 24px;
      margin-top: -1px;
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.08);
    }

    .tab-panel.active {
      display: block;
    }

    @media (prefers-color-scheme: dark) {
      .tab-button.active {
        background: var(--panel-dark);
        color: #c7d2fe;
        box-shadow: 0 -8px 24px rgba(0, 0, 0, 0.35);
      }

      .tab-panel {
        background: var(--panel-dark);
        border-color: var(--border-dark);
        box-shadow: 0 24px 48px rgba(0, 0, 0, 0.35);
      }
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-bottom: 20px;
    }

    .toolbar button,
    .toolbar label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--border);
      background: rgba(79, 70, 229, 0.06);
      color: var(--accent);
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .toolbar button:hover,
    .toolbar label:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .toolbar label input {
      display: none;
    }

    .snapshot-form {
      display: flex;
      flex-direction: column;
      gap: 16px;
      margin-top: 16px;
      padding: 18px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(79, 70, 229, 0.06);
    }

    .snapshot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    .snapshot-grid label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.76rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }

    .snapshot-grid input {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      font: inherit;
      background: rgba(255, 255, 255, 0.9);
      color: inherit;
    }

    @media (prefers-color-scheme: dark) {
      .snapshot-form {
        background: rgba(99, 102, 241, 0.16);
        border-color: var(--border-dark);
      }

      .snapshot-grid input {
        background: rgba(31, 36, 48, 0.9);
        border-color: var(--border-dark);
      }
    }

    .snapshot-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .snapshot-actions button {
      border: 1px solid var(--border);
      background: rgba(79, 70, 229, 0.12);
      color: var(--accent);
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .snapshot-actions button:hover {
      background: rgba(79, 70, 229, 0.2);
      transform: translateY(-1px);
    }

    .snapshot-status {
      margin: 18px 0 10px;
      min-height: 24px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .snapshot-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 0.88rem;
      margin-bottom: 12px;
    }

    .snapshot-action-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 16px;
    }

    .snapshot-action-row button {
      border: 1px solid var(--border);
      background: rgba(34, 197, 94, 0.14);
      color: var(--success);
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .snapshot-action-row button.secondary {
      background: rgba(59, 130, 246, 0.12);
      color: var(--accent);
    }

    .snapshot-action-row button.danger {
      background: rgba(220, 38, 38, 0.12);
      color: var(--danger);
    }

    .snapshot-action-row button:hover {
      transform: translateY(-1px);
    }

    .snapshot-preview {
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      min-height: 420px;
      background: #ffffff;
    }

    .snapshot-preview iframe {
      width: 100%;
      min-height: 420px;
      border: none;
      background: #ffffff;
    }

    .snapshot-raw {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
    }

    .snapshot-raw textarea {
      width: 100%;
      min-height: 200px;
      resize: vertical;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace;
      font-size: 0.85rem;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.9);
      color: inherit;
    }

    .snapshot-recent {
      margin: 18px 0 10px;
    }

    .history-commit-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .snapshot-recent h4 {
      margin: 0 0 8px;
      font-size: 0.9rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .history-chip-button {
      display: inline-flex;
      flex-direction: column;
      gap: 2px;
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(148, 163, 184, 0.12);
      cursor: pointer;
      min-width: 180px;
      transition: transform 0.18s ease, border 0.18s ease;
    }

    .history-chip-button strong {
      font-size: 0.88rem;
    }

    .history-chip-button span {
      font-size: 0.78rem;
      color: var(--muted);
    }

    .history-chip-button:hover {
      transform: translateY(-2px);
      border-color: var(--accent);
    }

    #status-bar {
      min-height: 24px;
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 20px;
    }

    .entries {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .entry {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.85);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }

    .entry.open {
      box-shadow: 0 20px 44px rgba(15, 23, 42, 0.12);
    }

    .entry.excluded {
      opacity: 0.55;
    }

    @media (prefers-color-scheme: dark) {
      .entry {
        background: rgba(31, 36, 48, 0.9);
        border-color: var(--border-dark);
      }

      .entry.open {
        box-shadow: 0 20px 44px rgba(0, 0, 0, 0.55);
      }
    }

    .entry-header {
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: default;
    }

    .entry-toggle {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: transparent;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .entry.open .entry-toggle {
      transform: rotate(90deg);
    }

    .entry-header-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-weight: 600;
    }

    .entry-header-meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.95rem;
    }

    .separator::before {
      content: "Â·";
      color: var(--muted);
      margin: 0 4px;
    }

    .editable-text {
      position: relative;
      padding: 2px 4px;
      border-radius: 6px;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .editable-text:hover {
      background: rgba(79, 70, 229, 0.08);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.18);
      cursor: text;
    }

    .editable-text.editing {
      background: rgba(79, 70, 229, 0.12);
      box-shadow: inset 0 0 0 1px rgba(79, 70, 229, 0.35);
    }

    .include-toggle {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .include-toggle input {
      width: 44px;
      height: 24px;
      appearance: none;
      background: rgba(79, 70, 229, 0.25);
      border-radius: 999px;
      position: relative;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .include-toggle input::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 4px;
      width: 18px;
      height: 18px;
      background: #ffffff;
      border-radius: 50%;
      box-shadow: 0 2px 6px rgba(15, 23, 42, 0.18);
      transition: transform 0.2s ease;
    }

    .include-toggle input:not(:checked) {
      background: rgba(148, 163, 184, 0.35);
    }

    .include-toggle input:checked::after {
      transform: translateX(18px);
    }

    .entry-body {
      margin-top: 16px;
      border-top: 1px solid var(--border);
      padding-top: 16px;
      display: none;
      gap: 12px;
      flex-direction: column;
    }

    .entry.open .entry-body {
      display: flex;
    }

    .detail-line {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.95rem;
    }

    .detail-line .pipe {
      color: var(--muted);
    }

    .link-button {
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid transparent;
      background: rgba(79, 70, 229, 0.08);
      color: var(--accent);
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
      font-size: 0.85rem;
    }

    .link-button:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .section-title {
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .section-title.editable-text:hover {
      cursor: text;
    }

    .section-body {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .entry-line {
      position: relative;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 0.93rem;
      transition: background 0.2s ease, box-shadow 0.2s ease;
    }

    .entry-line:hover {
      background: rgba(148, 163, 184, 0.12);
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.3);
      cursor: text;
    }

    .entry-line .line-text {
      display: inline;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .entry-line .open-link {
      margin-left: 8px;
      border: 1px solid rgba(79, 70, 229, 0.2);
      background: rgba(79, 70, 229, 0.12);
      color: var(--accent);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .entry-line .open-link:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .file-links {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-left: 8px;
      font-size: 0.82rem;
    }

    .file-links a {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(79, 70, 229, 0.18);
      background: rgba(79, 70, 229, 0.1);
      color: var(--accent);
      text-decoration: none;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .file-links a:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
    }

    .inline-editor,
    .inline-editor-area {
      width: 100%;
      box-sizing: border-box;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
      resize: vertical;
    }

    .inline-editor-area {
      min-height: 56px;
    }

    .link-editor {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .link-editor input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--accent);
      font: inherit;
      background: rgba(79, 70, 229, 0.08);
      color: inherit;
    }

    .link-editor .editor-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .link-editor button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid transparent;
      cursor: pointer;
      font-weight: 600;
    }

    .link-editor .save {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .link-editor .cancel {
      background: rgba(248, 113, 113, 0.12);
      color: var(--danger);
    }

    .link-editor .save:hover {
      background: rgba(34, 197, 94, 0.25);
    }

    .link-editor .cancel:hover {
      background: rgba(248, 113, 113, 0.2);
    }

    @media (max-width: 920px) {
      .entry-header {
        flex-direction: column;
        align-items: flex-start;
      }

      .include-toggle {
        margin-left: 0;
      }

      .detail-line {
        flex-direction: column;
        align-items: flex-start;
      }

      .detail-line .pipe {
        display: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Codex Review Viewer</h1>
    <p>Track review artefacts, toggle inclusion, and edit contextual notes inline. Double-click any line to update it.</p>
  </header>
  <div class="app-shell">
    <nav class="tab-bar" role="tablist">
      <button class="tab-button active" id="tab-view" role="tab" aria-selected="true" aria-controls="panel-view">View</button>
      <button class="tab-button" id="tab-preview" role="tab" aria-selected="false" aria-controls="panel-preview">Snapshot preview</button>
    </nav>
    <section class="tab-panel active" id="panel-view" role="tabpanel" aria-labelledby="tab-view">
      <div class="toolbar">
        <button type="button" id="refresh-button">â†» Refresh</button>
        <label for="import-input">â¬† Import JSON<input id="import-input" type="file" accept="application/json" /></label>
        <button type="button" id="export-button">â¬‡ Export JSON</button>
        <button type="button" id="export-text-button">â¬‡ Export TXT</button>
        <button type="button" id="export-markdown-button">â¬‡ Export Markdown</button>
        <button type="button" id="export-csv-button">â¬‡ Export CSV</button>
        <button type="button" id="export-pdf-button">â¬‡ Export PDF</button>
        <button type="button" id="save-button">ðŸ’¾ Save JSON</button>
      </div>
      <div id="status-bar" role="status" aria-live="polite"></div>
      <div class="entries" id="entry-list"></div>
    </section>
    <section class="tab-panel" id="panel-preview" role="tabpanel" aria-labelledby="tab-preview">
      <form class="snapshot-form" id="snapshotForm">
        <div class="snapshot-grid">
          <label>Owner
            <input id="snapshotOwner" type="text" placeholder="acme" required />
          </label>
          <label>Repository
            <input id="snapshotRepo" type="text" placeholder="perf" required />
          </label>
          <label>Commit SHA or ref
            <input id="snapshotSha" type="text" placeholder="abcdef1" required />
          </label>
          <label>Repository path
            <input id="snapshotPath" type="text" placeholder="index.html" required />
          </label>
          <label>New branch name
            <input id="snapshotBranch" type="text" placeholder="history/abcdef1" />
          </label>
          <label>Compare against
            <input id="snapshotBase" type="text" placeholder="main" />
          </label>
          <label>Download as
            <input id="snapshotFileName" type="text" placeholder="index-history.html" />
          </label>
        </div>
        <div class="snapshot-actions">
          <button type="submit" id="snapshotFetchButton">Load snapshot</button>
          <button type="button" id="snapshotResetButton">Reset form</button>
        </div>
      </form>
      <div id="snapshotStatus" class="snapshot-status" role="status" aria-live="polite"></div>
      <div id="snapshotMeta" class="snapshot-meta" hidden></div>
      <div id="snapshotActionRow" class="snapshot-action-row" hidden>
        <button type="button" id="snapshotDownloadButton">Download HTML</button>
        <button type="button" id="snapshotCopyButton" class="secondary">Copy to clipboard</button>
        <button type="button" id="snapshotOpenRawButton" class="secondary">Open raw on GitHub</button>
        <button type="button" id="snapshotPromoteButton" class="secondary">Create branch &amp; open compare</button>
      </div>
      <div id="snapshotRecent" class="snapshot-recent" hidden>
        <h4>Recent snapshots</h4>
        <div id="snapshotRecentList" class="history-commit-list"></div>
      </div>
      <div id="snapshotPreviewShell" class="snapshot-preview" hidden>
        <iframe id="snapshotFrame" sandbox="allow-scripts allow-forms allow-popups" title="Snapshot preview"></iframe>
      </div>
      <div id="snapshotRawShell" class="snapshot-raw" hidden>
        <label for="snapshotRaw">Raw content</label>
        <textarea id="snapshotRaw" readonly></textarea>
      </div>
    </section>
  </div>
  <script src="codex-checklist-shared.js"></script>
  <script>

    const defaultEntries = [
      {
        id: 76,
        title: 'Adjust touch end handling for drag gestures',
        summary: 'Ensure release events stay smooth for cross-browser sync scenarios.',
        timestamp: '9/27/2025, 6:05:13 PM',
        docRef: 'codex/review-analysis-v9-cross-browser-sync.md-77an0q',
        pr: {
          label: 'View PR',
          url: 'https://github.com/user/repo/pull/76'
        },
        include: true,
        sections: [
          {
            title: '------ live links',
            lines: [
              'https://chatgpt.com/codex/tasks/task_e_68d7b9a3f380832db7d50f1434ad43a8',
              'Filename: ui-v9a.htnl',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>',
              'Filename: ui-v9b.html',
              'repo: https://GitHub.com/user/repo/<filename> |  pages : http://username.github.io/repo/<filename>'
            ]
          },
          {
            title: '------- item metadata',
            lines: [
              'Tags',
              'Add tag and press Enter',
              '',
              'Notes',
              'Add checklist notesâ€¦',
              '',
              'Status:'
            ]
          }
        ]
      }
    ];

    const codex = window.CodexChecklist;
    const TOKEN_KEY = 'codexrecall.pat';
    const SNAPSHOT_HISTORY_KEY = 'codexrecall.snapshotHistory';

    const dom = {
      entryList: document.getElementById('entry-list'),
      refreshButton: document.getElementById('refresh-button'),
      exportButton: document.getElementById('export-button'),
      exportTextButton: document.getElementById('export-text-button'),
      exportMarkdownButton: document.getElementById('export-markdown-button'),
      exportCsvButton: document.getElementById('export-csv-button'),
      exportPdfButton: document.getElementById('export-pdf-button'),
      saveButton: document.getElementById('save-button'),
      importInput: document.getElementById('import-input'),
      statusBar: document.getElementById('status-bar')
    };

    const tabButtons = Array.from(document.querySelectorAll('.tab-button'));
    const tabPanels = Array.from(document.querySelectorAll('.tab-panel'));

    const previewDom = {
      form: document.getElementById('snapshotForm'),
      owner: document.getElementById('snapshotOwner'),
      repo: document.getElementById('snapshotRepo'),
      sha: document.getElementById('snapshotSha'),
      path: document.getElementById('snapshotPath'),
      branch: document.getElementById('snapshotBranch'),
      base: document.getElementById('snapshotBase'),
      fileName: document.getElementById('snapshotFileName'),
      fetchButton: document.getElementById('snapshotFetchButton'),
      resetButton: document.getElementById('snapshotResetButton'),
      status: document.getElementById('snapshotStatus'),
      meta: document.getElementById('snapshotMeta'),
      actionRow: document.getElementById('snapshotActionRow'),
      downloadButton: document.getElementById('snapshotDownloadButton'),
      copyButton: document.getElementById('snapshotCopyButton'),
      openRawButton: document.getElementById('snapshotOpenRawButton'),
      promoteButton: document.getElementById('snapshotPromoteButton'),
      previewShell: document.getElementById('snapshotPreviewShell'),
      frame: document.getElementById('snapshotFrame'),
      rawShell: document.getElementById('snapshotRawShell'),
      raw: document.getElementById('snapshotRaw'),
      recentShell: document.getElementById('snapshotRecent'),
      recentList: document.getElementById('snapshotRecentList')
    };

    const openEntries = new Set();

    const derivedState = {
      repoContext: null,
      normalizedEntries: [],
      jsonPayload: null,
      textContent: '',
      markdownContent: '',
      csvContent: '',
      pdfBlob: null
    };

    const snapshotState = {
      owner: '',
      repo: '',
      sha: '',
      path: '',
      branch: '',
      base: '',
      fileName: '',
      committedAt: '',
      author: '',
      message: '',
      commitUrl: '',
      content: '',
      rawUrl: ''
    };

    tabPanels.forEach(panel => {
      panel.hidden = !panel.classList.contains('active');
    });

    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        activateTab(button.id);
      });
    });

    function activateTab(buttonId) {
      const panelId = buttonId.replace('tab-', 'panel-');
      tabButtons.forEach(button => {
        const isActive = button.id === buttonId;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', isActive ? 'true' : 'false');
      });
      tabPanels.forEach(panel => {
        const isActive = panel.id === panelId;
        panel.classList.toggle('active', isActive);
        panel.hidden = !isActive;
      });
    }

    let currentChecklist = initializeCurrentChecklist();
    let entries = cloneEntries(currentChecklist?.payload?.entries || defaultEntries);
    if (!entries.length) {
      entries = cloneEntries(defaultEntries);
    }

    let pendingSaveKey = null;

    function initializeCurrentChecklist() {
      if (!codex) return null;
      if (codex.current) return codex.current;
      const latest = codex.loadLatest();
      if (latest) {
        codex.setCurrent(latest, { dispatchEvent: false, bubble: false });
        return codex.current;
      }
      return null;
    }

    function formatLabel(info) {
      if (!info) return 'unknown repository';
      return `${info.owner}/${info.repo}`;
    }

    function cloneEntries(data) {
      try {
        return JSON.parse(JSON.stringify(Array.isArray(data) ? data : []));
      } catch (error) {
        console.warn('Failed to clone entries', error);
        return Array.isArray(data) ? data.slice() : [];
      }
    }

    function normalizeEntriesForExport(data) {
      return cloneEntries(data).map(entry => {
        const normalized = {
          id: entry?.id ?? '',
          title: entry?.title ?? '',
          summary: entry?.summary ?? '',
          timestamp: entry?.timestamp ?? '',
          docRef: entry?.docRef ?? '',
          include: entry?.include !== false,
          pr: {
            label: entry?.pr?.label ?? '',
            url: entry?.pr?.url ?? ''
          },
          sections: []
        };
        if (Array.isArray(entry?.sections)) {
          normalized.sections = entry.sections.map(section => ({
            title: section?.title ?? '',
            lines: Array.isArray(section?.lines) ? section.lines.map(line => line ?? '') : []
          }));
        }
        return normalized;
      });
    }

    function deriveRepoContext(normalizedEntries) {
      let owner = currentChecklist?.owner || null;
      let repo = currentChecklist?.repo || null;
      let branch = currentChecklist?.payload?.branch
        || currentChecklist?.payload?.defaultBranch
        || currentChecklist?.payload?.branchName
        || currentChecklist?.payload?.currentBranch
        || null;

      if ((!owner || !repo) && Array.isArray(normalizedEntries)) {
        for (const entry of normalizedEntries) {
          const prUrl = entry?.pr?.url;
          if (!prUrl) continue;
          try {
            const parsed = new URL(prUrl);
            const parts = parsed.pathname.split('/').filter(Boolean);
            if (parts.length >= 2) {
              owner = owner || parts[0];
              repo = repo || parts[1];
            }
            if (owner && repo) break;
          } catch (error) {
            console.warn('Unable to parse PR URL for repo context', prUrl, error);
          }
        }
      }

      if (!branch) {
        branch = 'main';
      }

      if (!owner || !repo) {
        return null;
      }

      return {
        owner,
        repo,
        branch,
        pagesHost: `${owner.toLowerCase()}.github.io`
      };
    }

    function buildTextExport(normalizedEntries, repoContext) {
      const lines = [];
      if (repoContext) {
        lines.push(`Repository: ${repoContext.owner}/${repoContext.repo}`);
        lines.push(`Branch: ${repoContext.branch}`);
        lines.push('');
      }
      normalizedEntries.forEach(entry => {
        lines.push(`#${entry.id || 'N/A'} ${entry.title || ''}`.trim());
        lines.push(`Summary: ${entry.summary || ''}`);
        lines.push(`Timestamp: ${entry.timestamp || ''}`);
        lines.push(`Doc: ${entry.docRef || ''}`);
        lines.push(`Include: ${entry.include ? 'Yes' : 'No'}`);
        if (entry.pr?.url || entry.pr?.label) {
          const label = entry.pr.label ? `${entry.pr.label}: ` : '';
          lines.push(`PR: ${label}${entry.pr.url || ''}`.trim());
        }
        entry.sections.forEach(section => {
          if (!section.title && !section.lines.length) return;
          lines.push(`  ${section.title || 'Section'}`.trim());
          section.lines.forEach(line => {
            lines.push('    - ' + (line || ''));
          });
        });
        lines.push('');
      });
      return lines.join('\n');
    }

    function buildMarkdownExport(normalizedEntries, repoContext) {
      const lines = [];
      if (repoContext) {
        lines.push(`# Checklist for ${repoContext.owner}/${repoContext.repo}`);
        lines.push(`*Branch:* \`${repoContext.branch}\``);
        lines.push('');
      }
      normalizedEntries.forEach(entry => {
        lines.push(`## #${entry.id || 'N/A'} ${entry.title || ''}`.trim());
        lines.push(`- **Include:** ${entry.include ? 'Yes' : 'No'}`);
        if (entry.summary) {
          lines.push(`- **Summary:** ${entry.summary}`);
        }
        if (entry.timestamp) {
          lines.push(`- **Timestamp:** ${entry.timestamp}`);
        }
        if (entry.docRef) {
          lines.push(`- **Doc:** ${entry.docRef}`);
        }
        if (entry.pr?.url || entry.pr?.label) {
          const label = entry.pr.label || entry.pr.url;
          const url = entry.pr.url || '';
          if (url) {
            lines.push(`- **PR:** [${label}](${url})`);
          } else if (label) {
            lines.push(`- **PR:** ${label}`);
          }
        }
        if (entry.sections.length) {
          lines.push('');
          entry.sections.forEach(section => {
            if (section.title) {
              lines.push(`### ${section.title}`);
            }
            section.lines.forEach(line => {
              lines.push(`- ${line || ''}`);
            });
            lines.push('');
          });
        }
        lines.push('');
      });
      return lines.join('\n').replace(/\n{3,}/g, '\n\n');
    }

    function csvEscape(value) {
      const stringValue = String(value ?? '');
      if (/[",\n]/.test(stringValue)) {
        return '"' + stringValue.replace(/"/g, '""') + '"';
      }
      return stringValue;
    }

    function buildCsvExport(normalizedEntries) {
      const headers = ['Entry ID', 'Include', 'Title', 'Summary', 'Timestamp', 'Doc Ref', 'PR Label', 'PR URL', 'Section', 'Line Index', 'Line'];
      const rows = [headers.join(',')];
      normalizedEntries.forEach(entry => {
        if (!entry.sections.length) {
          rows.push([
            csvEscape(entry.id),
            csvEscape(entry.include ? 'Yes' : 'No'),
            csvEscape(entry.title),
            csvEscape(entry.summary),
            csvEscape(entry.timestamp),
            csvEscape(entry.docRef),
            csvEscape(entry.pr?.label || ''),
            csvEscape(entry.pr?.url || ''),
            csvEscape(''),
            csvEscape(''),
            csvEscape('')
          ].join(','));
          return;
        }
        entry.sections.forEach(section => {
          const sectionTitle = section.title || '';
          if (!section.lines.length) {
            rows.push([
              csvEscape(entry.id),
              csvEscape(entry.include ? 'Yes' : 'No'),
              csvEscape(entry.title),
              csvEscape(entry.summary),
              csvEscape(entry.timestamp),
              csvEscape(entry.docRef),
              csvEscape(entry.pr?.label || ''),
              csvEscape(entry.pr?.url || ''),
              csvEscape(sectionTitle),
              csvEscape(''),
              csvEscape('')
            ].join(','));
            return;
          }
          section.lines.forEach((line, index) => {
            rows.push([
              csvEscape(entry.id),
              csvEscape(entry.include ? 'Yes' : 'No'),
              csvEscape(entry.title),
              csvEscape(entry.summary),
              csvEscape(entry.timestamp),
              csvEscape(entry.docRef),
              csvEscape(entry.pr?.label || ''),
              csvEscape(entry.pr?.url || ''),
              csvEscape(sectionTitle),
              csvEscape(index + 1),
              csvEscape(line || '')
            ].join(','));
          });
        });
      });
      return rows.join('\n');
    }

    function escapePdfText(value) {
      return String(value ?? '').replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
    }

    function createPdfBlob(textContent) {
      const sanitized = String(textContent || '').replace(/\r\n?/g, '\n');
      const lines = sanitized.split('\n');
      const contentParts = ['BT', '/F1 10 Tf', '50 780 Td'];
      lines.forEach((line, index) => {
        if (index === 0) {
          contentParts.push(`(${escapePdfText(line)}) Tj`);
        } else {
          contentParts.push('0 -14 Td');
          contentParts.push(`(${escapePdfText(line)}) Tj`);
        }
      });
      contentParts.push('ET');
      const contentStream = contentParts.join('\n');
      const encoder = typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
      const contentLength = encoder ? encoder.encode(contentStream).length : contentStream.length;
      const objects = [
        '1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n',
        '2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n',
        '3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 595 842] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n',
        `4 0 obj\n<< /Length ${contentLength} >>\nstream\n${contentStream}\nendstream\nendobj\n`,
        '5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n'
      ];
      const pdfParts = ['%PDF-1.4\n'];
      const offsets = [];
      const measure = value => encoder ? encoder.encode(value).length : value.length;
      let byteLength = measure(pdfParts[0]);
      objects.forEach(obj => {
        offsets.push(byteLength);
        pdfParts.push(obj);
        byteLength += measure(obj);
      });
      const xrefPosition = byteLength;
      let xref = `xref\n0 ${objects.length + 1}\n`;
      xref += '0000000000 65535 f \n';
      offsets.forEach(offset => {
        xref += offset.toString().padStart(10, '0') + ' 00000 n \n';
      });
      pdfParts.push(xref);
      byteLength += measure(xref);
      const trailer = `trailer\n<< /Size ${objects.length + 1} /Root 1 0 R >>\nstartxref\n${xrefPosition}\n%%EOF`;
      pdfParts.push(trailer);
      return new Blob(pdfParts, { type: 'application/pdf' });
    }

    function sanitizeForFilename(value) {
      return String(value ?? '').replace(/[^A-Za-z0-9._-]+/g, '-');
    }

    function getDownloadLabel() {
      if (currentChecklist) {
        const owner = sanitizeForFilename(currentChecklist.owner);
        const repo = sanitizeForFilename(currentChecklist.repo);
        const branchValue = derivedState.repoContext?.branch ? `-${sanitizeForFilename(derivedState.repoContext.branch)}` : '';
        return `${owner}-${repo}${branchValue}`;
      }
      return 'viewer-entries';
    }

    function downloadFile(content, { type, extension }) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const label = getDownloadLabel();
      const blob = content instanceof Blob ? content : new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `checklist-${label}-${timestamp}.${extension}`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function encodePathSegments(path) {
      return path.split('/').map(segment => encodeURIComponent(segment)).join('/');
    }

    function extractFileReferences(text) {
      if (!text) return [];
      const found = new Set();
      const matches = text.matchAll(/(?:File(?:name)?|Path|Page|Asset)[:\s]+([^|\n]+)/gi);
      for (const match of matches) {
        const candidate = match[1].trim();
        if (candidate) {
          candidate.split(/[,\s]+/).forEach(item => {
            const cleaned = item.replace(/^[`'"(\[]+/, '').replace(/[`'"),\]]+$/, '');
            if (isValidFileReference(cleaned)) {
              found.add(cleaned);
            }
          });
        }
      }
      text.split(/\s+/).forEach(token => {
        const cleaned = token.replace(/^[`'"(\[]+/, '').replace(/[`'"),.;:>\]]+$/, '');
        if (isValidFileReference(cleaned)) {
          found.add(cleaned);
        }
      });
      return Array.from(found);
    }

    function isValidFileReference(candidate) {
      if (!candidate) return false;
      if (candidate.includes('://')) return false;
      if (candidate.includes('<') || candidate.includes('>')) return false;
      if (!/\./.test(candidate)) return false;
      return /^[A-Za-z0-9_.\/\-]+$/.test(candidate);
    }

    function createFileLinks(path, repoContext) {
      if (!repoContext) return [];
      const normalizedPath = path.replace(/^[./]+/, '');
      if (!normalizedPath) return [];
      const encodedPath = encodePathSegments(normalizedPath);
      const githubUrl = `https://github.com/${repoContext.owner}/${repoContext.repo}/blob/${encodeURIComponent(repoContext.branch)}/${encodedPath}`;
      const pagesUrl = `https://${repoContext.pagesHost}/${repoContext.repo}/${encodedPath}`;
      const githubLink = document.createElement('a');
      githubLink.href = githubUrl;
      githubLink.target = '_blank';
      githubLink.rel = 'noopener noreferrer';
      githubLink.textContent = 'GitHub';
      githubLink.title = `Open ${normalizedPath} on GitHub (${repoContext.branch})`;

      const pagesLink = document.createElement('a');
      pagesLink.href = pagesUrl;
      pagesLink.target = '_blank';
      pagesLink.rel = 'noopener noreferrer';
      pagesLink.textContent = 'Pages';
      pagesLink.title = `Open ${normalizedPath} on GitHub Pages`;
      return [githubLink, pagesLink];
    }

    function updateDerivedState() {
      derivedState.normalizedEntries = normalizeEntriesForExport(entries);
      derivedState.repoContext = deriveRepoContext(derivedState.normalizedEntries);
      const repoContext = derivedState.repoContext;
      const normalizedEntries = derivedState.normalizedEntries;
      const payload = currentChecklist ? {
        owner: currentChecklist.owner,
        repo: currentChecklist.repo,
        branch: repoContext?.branch,
        savedAt: currentChecklist.payload?.savedAt || new Date().toISOString(),
        entries: cloneEntries(normalizedEntries)
      } : { entries: cloneEntries(normalizedEntries) };
      derivedState.jsonPayload = payload;
      derivedState.textContent = buildTextExport(normalizedEntries, repoContext);
      derivedState.markdownContent = buildMarkdownExport(normalizedEntries, repoContext);
      derivedState.csvContent = buildCsvExport(normalizedEntries);
      derivedState.pdfBlob = createPdfBlob(derivedState.textContent);
    }

    function adoptChecklist(update) {
      if (!update || !update.payload || !Array.isArray(update.payload.entries)) {
        return false;
      }
      const key = codex?.keyFor ? codex.keyFor(update.owner, update.repo) : update.key;
      currentChecklist = {
        owner: update.owner,
        repo: update.repo,
        key: key || update.key,
        payload: {
          savedAt: update.payload.savedAt,
          entries: cloneEntries(update.payload.entries)
        },
        source: update.source || null
      };
      entries = cloneEntries(update.payload.entries);
      openEntries.clear();
      renderEntries();
      return true;
    }

    function saveState() {
      if (!codex) {
        setStatus('Shared checklist utilities unavailable. Cannot save.', true);
        return;
      }
      if (!currentChecklist) {
        setStatus('No checklist selected. Load data in the checklist view first.', true);
        return;
      }
      const key = codex.keyFor(currentChecklist.owner, currentChecklist.repo);
      const payload = {
        savedAt: new Date().toISOString(),
        entries: cloneEntries(entries)
      };
      try {
        localStorage.setItem(key, JSON.stringify(payload));
        currentChecklist = {
          owner: currentChecklist.owner,
          repo: currentChecklist.repo,
          key,
          payload
        };
        pendingSaveKey = key;
        codex.broadcastUpdate({
          owner: currentChecklist.owner,
          repo: currentChecklist.repo,
          payload,
          source: 'viewer'
        });
        setStatus(`Saved checklist for ${formatLabel(currentChecklist)}.`);
      } catch (error) {
        console.error('Unable to save state', error);
        setStatus('Unable to save state. Check storage availability.', true);
      } finally {
        pendingSaveKey = null;
      }
    }

    function setStatus(message, isError = false) {
      dom.statusBar.textContent = message || '';
      dom.statusBar.style.color = isError ? 'var(--danger)' : 'var(--muted)';
      if (message) {
        clearTimeout(setStatus.timeoutId);
        setStatus.timeoutId = setTimeout(() => {
          dom.statusBar.textContent = '';
        }, 4000);
      }
    }

    function renderEntries() {
      updateDerivedState();
      const repoContext = derivedState.repoContext;
      dom.entryList.innerHTML = '';
      if (!entries.length) {
        const emptyState = document.createElement('div');
        emptyState.className = 'entry';
        emptyState.innerHTML = '<strong>No entries yet.</strong> Use Import JSON to bring in existing review data.';
        dom.entryList.appendChild(emptyState);
        return;
      }

      entries.forEach((entry, index) => {
        const entryEl = document.createElement('article');
        entryEl.className = 'entry';
        entryEl.dataset.index = index;
        if (openEntries.has(index)) {
          entryEl.classList.add('open');
        }
        if (!entry.include) {
          entryEl.classList.add('excluded');
        }

        const header = document.createElement('div');
        header.className = 'entry-header';

        const toggleButton = document.createElement('button');
        toggleButton.type = 'button';
        toggleButton.className = 'entry-toggle';
        toggleButton.setAttribute('aria-label', 'Toggle entry details');
        toggleButton.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 5l8 7-8 7"></path></svg>';
        header.appendChild(toggleButton);

        const meta = document.createElement('div');
        meta.className = 'entry-header-meta';
        meta.innerHTML = `
          <span class="entry-id">#${entry.id}</span>
          <span class="separator"></span>
          <span class="entry-title editable-text" data-editable data-field="title" data-entry-index="${index}">${escapeHtml(entry.title)}</span>
          <span class="separator"></span>
          <span class="entry-date editable-text" data-editable data-field="timestamp" data-entry-index="${index}">${escapeHtml(entry.timestamp)}</span>
          <span class="separator"></span>
          <span class="entry-summary editable-text" data-editable data-field="summary" data-entry-index="${index}">${escapeHtml(entry.summary)}</span>
        `;
        header.appendChild(meta);

        const includeWrap = document.createElement('label');
        includeWrap.className = 'include-toggle';
        includeWrap.innerHTML = `
          <span>${entry.include ? 'Include' : 'Exclude'}</span>
          <input type="checkbox" data-role="include-toggle" data-entry-index="${index}" ${entry.include ? 'checked' : ''} aria-label="Toggle include for entry ${entry.id}">
        `;
        header.appendChild(includeWrap);

        entryEl.appendChild(header);

        const body = document.createElement('div');
        body.className = 'entry-body';

        const detailLine = document.createElement('div');
        detailLine.className = 'detail-line';

        const tsSpan = document.createElement('span');
        tsSpan.className = 'editable-text';
        tsSpan.dataset.editable = '';
        tsSpan.dataset.field = 'timestamp';
        tsSpan.dataset.entryIndex = index;
        tsSpan.textContent = entry.timestamp;

        const docSpan = document.createElement('span');
        docSpan.className = 'editable-text';
        docSpan.dataset.editable = '';
        docSpan.dataset.field = 'docRef';
        docSpan.dataset.entryIndex = index;
        docSpan.textContent = entry.docRef;

        const prSpan = document.createElement('span');
        prSpan.className = 'editable-text';
        prSpan.dataset.editable = '';
        prSpan.dataset.field = 'prLink';
        prSpan.dataset.entryIndex = index;
        prSpan.textContent = entry.pr.label;

        const prButton = document.createElement('button');
        prButton.type = 'button';
        prButton.className = 'link-button';
        prButton.dataset.url = entry.pr.url;
        prButton.textContent = 'â†—';
        prButton.title = 'Open PR in new tab';

        detailLine.appendChild(tsSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(docSpan);
        detailLine.appendChild(pipeSeparator());
        detailLine.appendChild(prSpan);
        detailLine.appendChild(prButton);

        body.appendChild(detailLine);

        entry.sections.forEach((section, sectionIndex) => {
          const sectionTitle = document.createElement('div');
          sectionTitle.className = 'section-title editable-text';
          sectionTitle.dataset.editable = '';
          sectionTitle.dataset.field = 'sectionTitle';
          sectionTitle.dataset.entryIndex = index;
          sectionTitle.dataset.sectionIndex = sectionIndex;
          sectionTitle.textContent = section.title;
          body.appendChild(sectionTitle);

          const sectionBody = document.createElement('div');
          sectionBody.className = 'section-body';

          section.lines.forEach((line, lineIndex) => {
            const lineEl = document.createElement('div');
            lineEl.className = 'entry-line editable-text';
            lineEl.dataset.editable = '';
            lineEl.dataset.field = 'sectionLine';
            lineEl.dataset.entryIndex = index;
            lineEl.dataset.sectionIndex = sectionIndex;
            lineEl.dataset.lineIndex = lineIndex;

            const textSpan = document.createElement('span');
            textSpan.className = 'line-text';
            textSpan.textContent = line || '';
            lineEl.appendChild(textSpan);

            findUrls(line).forEach(url => {
              const openButton = document.createElement('button');
              openButton.type = 'button';
              openButton.className = 'open-link';
              openButton.dataset.url = url;
              openButton.textContent = 'â†—';
              openButton.title = 'Open link in new tab';
              lineEl.appendChild(openButton);
            });

            if (repoContext) {
              const fileRefs = extractFileReferences(line);
              if (fileRefs.length) {
                const linksWrapper = document.createElement('span');
                linksWrapper.className = 'file-links';
                fileRefs.forEach(path => {
                  createFileLinks(path, repoContext).forEach(link => {
                    linksWrapper.appendChild(link);
                  });
                });
                if (linksWrapper.childNodes.length) {
                  lineEl.appendChild(linksWrapper);
                }
              }
            }

            sectionBody.appendChild(lineEl);
          });

          body.appendChild(sectionBody);
        });

        entryEl.appendChild(body);
        dom.entryList.appendChild(entryEl);
      });
    }

    function pipeSeparator() {
      const span = document.createElement('span');
      span.className = 'pipe';
      span.textContent = '|';
      return span;
    }

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function findUrls(text) {
      if (!text) return [];
      const urlRegex = /(https?:\/\/[^\s]+)/g;
      const matches = [];
      let match;
      while ((match = urlRegex.exec(text)) !== null) {
        matches.push(match[0]);
      }
      return matches;
    }

    function handleEntryClick(event) {
      const toggle = event.target.closest('.entry-toggle');
      if (toggle) {
        const entryEl = toggle.closest('.entry');
        if (!entryEl) return;
        const index = Number(entryEl.dataset.index);
        if (openEntries.has(index)) {
          openEntries.delete(index);
        } else {
          openEntries.add(index);
        }
        renderEntries();
        event.preventDefault();
        return;
      }

      const includeToggle = event.target.closest('input[data-role="include-toggle"]');
      if (includeToggle) {
        const index = Number(includeToggle.dataset.entryIndex);
        entries[index].include = includeToggle.checked;
        renderEntries();
        setStatus(`Entry #${entries[index].id} marked as ${includeToggle.checked ? 'included' : 'excluded'}.`);
        return;
      }

      const linkButton = event.target.closest('[data-url]');
      if (linkButton && linkButton.dataset.url) {
        window.open(linkButton.dataset.url, '_blank');
        return;
      }
    }

    function handleDoubleClick(event) {
      const editable = event.target.closest('[data-editable]');
      if (!editable) return;
      event.preventDefault();
      event.stopPropagation();

      const entryIndex = Number(editable.dataset.entryIndex);
      const field = editable.dataset.field;
      const sectionIndex = editable.dataset.sectionIndex ? Number(editable.dataset.sectionIndex) : null;
      const lineIndex = editable.dataset.lineIndex ? Number(editable.dataset.lineIndex) : null;

      if (field === 'prLink') {
        const currentLink = entries[entryIndex].pr;
        startLinkEditing(editable, currentLink, updatedLink => {
          entries[entryIndex].pr = updatedLink;
          renderEntries();
          setStatus('Updated PR link.');
        });
        return;
      }

      if (field === 'sectionTitle' || field === 'sectionLine' || field === 'summary' || field === 'title' || field === 'docRef' || field === 'timestamp') {
        startTextEditing(editable, getValue(entryIndex, field, sectionIndex, lineIndex), newValue => {
          setValue(entryIndex, field, newValue, sectionIndex, lineIndex);
        });
        return;
      }
    }

    function getValue(entryIndex, field, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      switch (field) {
        case 'title':
          return entry.title;
        case 'summary':
          return entry.summary;
        case 'timestamp':
          return entry.timestamp;
        case 'docRef':
          return entry.docRef;
        case 'sectionTitle':
          return entry.sections[sectionIndex].title;
        case 'sectionLine':
          return entry.sections[sectionIndex].lines[lineIndex];
        default:
          return '';
      }
    }

    function setValue(entryIndex, field, value, sectionIndex, lineIndex) {
      const entry = entries[entryIndex];
      const trimmed = typeof value === 'string' ? value.trim() : value;
      switch (field) {
        case 'title':
          entry.title = trimmed;
          break;
        case 'summary':
          entry.summary = trimmed;
          break;
        case 'timestamp':
          entry.timestamp = trimmed;
          break;
        case 'docRef':
          entry.docRef = trimmed;
          break;
        case 'sectionTitle':
          entry.sections[sectionIndex].title = trimmed;
          break;
        case 'sectionLine':
          entry.sections[sectionIndex].lines[lineIndex] = value;
          break;
      }
      renderEntries();
      setStatus('Updated entry content.');
    }

    function startLinkEditing(element, currentLink, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');

      const wrapper = document.createElement('div');
      wrapper.className = 'link-editor';

      const labelInput = document.createElement('input');
      labelInput.type = 'text';
      labelInput.placeholder = 'Link label';
      labelInput.value = currentLink.label || '';

      const urlInput = document.createElement('input');
      urlInput.type = 'url';
      urlInput.placeholder = 'https://example.com';
      urlInput.value = currentLink.url || '';

      const actions = document.createElement('div');
      actions.className = 'editor-actions';

      const cancelButton = document.createElement('button');
      cancelButton.type = 'button';
      cancelButton.className = 'cancel';
      cancelButton.textContent = 'Cancel';

      const saveButton = document.createElement('button');
      saveButton.type = 'button';
      saveButton.className = 'save';
      saveButton.textContent = 'Save';

      actions.appendChild(cancelButton);
      actions.appendChild(saveButton);

      wrapper.appendChild(labelInput);
      wrapper.appendChild(urlInput);
      wrapper.appendChild(actions);

      element.textContent = '';
      element.appendChild(wrapper);
      labelInput.focus();
      labelInput.setSelectionRange(labelInput.value.length, labelInput.value.length);

      const commit = () => {
        const nextLabel = labelInput.value.trim() || 'Link';
        const nextUrl = urlInput.value.trim();
        element.classList.remove('editing');
        onSave({ label: nextLabel, url: nextUrl });
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      cancelButton.addEventListener('click', cancel);
      saveButton.addEventListener('click', commit);

      [labelInput, urlInput].forEach(input => {
        input.addEventListener('keydown', event => {
          if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            if (input === labelInput) {
              urlInput.focus();
              urlInput.setSelectionRange(urlInput.value.length, urlInput.value.length);
            } else {
              commit();
            }
          } else if (event.key === 'Escape') {
            event.preventDefault();
            cancel();
          }
        });
      });

      urlInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
      labelInput.addEventListener('blur', event => {
        if (!wrapper.contains(event.relatedTarget)) {
          commit();
        }
      });
    }

    function startTextEditing(element, currentValue, onSave) {
      if (element.classList.contains('editing')) return;
      element.classList.add('editing');
      const isMultiline = currentValue && currentValue.length > 60;
      const input = document.createElement(isMultiline ? 'textarea' : 'input');
      if (isMultiline) {
        input.className = 'inline-editor-area';
        input.rows = Math.min(6, Math.max(2, Math.ceil(currentValue.length / 60)));
      } else {
        input.className = 'inline-editor';
      }
      input.value = currentValue || '';
      element.textContent = '';
      element.appendChild(input);
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);

      const commit = () => {
        const newValue = isMultiline ? input.value : input.value;
        element.classList.remove('editing');
        onSave(newValue);
      };

      const cancel = () => {
        element.classList.remove('editing');
        renderEntries();
      };

      input.addEventListener('blur', commit);
      input.addEventListener('keydown', event => {
        if (event.key === 'Enter' && !event.shiftKey && !isMultiline) {
          event.preventDefault();
          commit();
        } else if (event.key === 'Escape') {
          event.preventDefault();
          cancel();
        }
      });
    }

    function handleRefresh() {
      if (!codex || !currentChecklist) {
        setStatus('No saved checklist available. Load data in the checklist view first.', true);
        return;
      }
      const reloaded = codex.loadChecklist(currentChecklist.owner, currentChecklist.repo);
      if (reloaded && adoptChecklist(reloaded)) {
        setStatus(`Reloaded ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from ${formatLabel(reloaded)}.`);
      } else {
        setStatus('No saved data found for the current repository.', true);
      }
    }

    function handleExportJson() {
      updateDerivedState();
      const payload = derivedState.jsonPayload;
      downloadFile(JSON.stringify(payload, null, 2), { type: 'application/json', extension: 'json' });
      setStatus('Exported checklist as JSON.');
    }

    function handleExportText() {
      updateDerivedState();
      downloadFile(derivedState.textContent, { type: 'text/plain', extension: 'txt' });
      setStatus('Exported checklist as plain text.');
    }

    function handleExportMarkdown() {
      updateDerivedState();
      downloadFile(derivedState.markdownContent, { type: 'text/markdown', extension: 'md' });
      setStatus('Exported checklist as Markdown.');
    }

    function handleExportCsv() {
      updateDerivedState();
      downloadFile(derivedState.csvContent, { type: 'text/csv', extension: 'csv' });
      setStatus('Exported checklist as CSV.');
    }

    function handleExportPdf() {
      updateDerivedState();
      downloadFile(derivedState.pdfBlob, { type: 'application/pdf', extension: 'pdf' });
      setStatus('Exported checklist as PDF.');
    }

    function handleImport(event) {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const parsed = JSON.parse(e.target.result);
          let importedEntries;
          let importedChecklist = null;
          if (Array.isArray(parsed)) {
            importedEntries = parsed;
          } else if (parsed && Array.isArray(parsed.entries)) {
            importedEntries = parsed.entries;
            if (parsed.owner && parsed.repo) {
              importedChecklist = {
                owner: parsed.owner,
                repo: parsed.repo,
                payload: {
                  savedAt: parsed.savedAt || new Date().toISOString(),
                  entries: cloneEntries(parsed.entries)
                },
                source: 'import'
              };
            }
          } else {
            throw new Error('JSON must be an array or object containing an entries array.');
          }
          entries = cloneEntries(importedEntries);
          openEntries.clear();
          renderEntries();
          if (importedChecklist) {
            currentChecklist = {
              owner: importedChecklist.owner,
              repo: importedChecklist.repo,
              key: codex ? codex.keyFor(importedChecklist.owner, importedChecklist.repo) : null,
              payload: importedChecklist.payload
            };
            setStatus(`Imported ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} for ${formatLabel(importedChecklist)}. Save to persist.`, false);
          } else {
            setStatus(`Imported ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from JSON. Save to persist changes.`, false);
          }
        } catch (error) {
          console.error('Import failed', error);
          setStatus('Import failed: ' + error.message, true);
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function setSnapshotStatus(message, tone = 'info') {
      if (!previewDom.status) return;
      if (!message) {
        previewDom.status.textContent = '';
        previewDom.status.removeAttribute('data-tone');
        previewDom.status.style.color = 'var(--muted)';
        return;
      }
      previewDom.status.textContent = message;
      let color = 'var(--muted)';
      if (tone === 'error') {
        color = 'var(--danger)';
      } else if (tone === 'success') {
        color = 'var(--success)';
      }
      previewDom.status.style.color = color;
      previewDom.status.dataset.tone = tone;
    }

    function clearSnapshotView() {
      if (!previewDom.previewShell) return;
      snapshotState.content = '';
      snapshotState.rawUrl = '';
      previewDom.previewShell.hidden = true;
      previewDom.frame.srcdoc = '';
      previewDom.rawShell.hidden = true;
      previewDom.raw.value = '';
      previewDom.actionRow.hidden = true;
      previewDom.meta.hidden = true;
    }

    function updateSnapshotMeta() {
      if (!previewDom.meta) return;
      const rows = [];
      if (snapshotState.owner && snapshotState.repo) {
        rows.push(`<div><strong>${escapeHtml(`${snapshotState.owner}/${snapshotState.repo}`)}</strong></div>`);
      }
      if (snapshotState.path) {
        rows.push(`<div>${escapeHtml(snapshotState.path)}</div>`);
      }
      if (snapshotState.sha) {
        rows.push(`<div>Commit: <code>${escapeHtml(snapshotState.sha.slice(0, 12))}</code></div>`);
      }
      if (snapshotState.message) {
        rows.push(`<div>${escapeHtml(snapshotState.message)}</div>`);
      }
      if (snapshotState.author || snapshotState.committedAt) {
        let timestamp = snapshotState.committedAt || '';
        if (timestamp) {
          try {
            timestamp = new Date(timestamp).toLocaleString();
          } catch (error) {
            timestamp = snapshotState.committedAt;
          }
        }
        const author = snapshotState.author ? escapeHtml(snapshotState.author) : 'Unknown author';
        rows.push(`<div>${author}${timestamp ? ` Â· ${escapeHtml(timestamp)}` : ''}</div>`);
      }
      if (snapshotState.commitUrl) {
        rows.push(`<div><a href="${escapeHtml(snapshotState.commitUrl)}" target="_blank" rel="noopener">View commit on GitHub â†—</a></div>`);
      }
      previewDom.meta.innerHTML = rows.join('');
      previewDom.meta.hidden = !rows.length;
    }

    function deriveDownloadNameFromPath(path, ref) {
      const safeRef = (ref || '').slice(0, 7) || 'snapshot';
      const baseName = (path || 'snapshot.html').split('/').pop() || 'snapshot.html';
      if (baseName.includes('.')) {
        const dotIndex = baseName.lastIndexOf('.');
        const namePart = baseName.slice(0, dotIndex) || 'snapshot';
        const ext = baseName.slice(dotIndex + 1) || 'html';
        return `${namePart}-${safeRef}.${ext}`;
      }
      return `${baseName}-${safeRef}.html`;
    }

    function getStoredToken() {
      try {
        return localStorage.getItem(TOKEN_KEY);
      } catch (error) {
        console.warn('Unable to read stored token', error);
        return null;
      }
    }

    async function githubRest(path, { method = 'GET', body, headers } = {}) {
      const token = getStoredToken();
      const requestHeaders = {
        'Accept': 'application/vnd.github+json',
        ...headers
      };
      if (body && !requestHeaders['Content-Type']) {
        requestHeaders['Content-Type'] = 'application/json';
      }
      if (token) {
        requestHeaders.Authorization = `Bearer ${token}`;
      }
      const response = await fetch(`https://api.github.com${path}`, {
        method,
        headers: requestHeaders,
        body
      });
      if (!response.ok) {
        const text = await response.text();
        let message = text;
        try {
          const parsed = JSON.parse(text);
          message = parsed.message || message;
        } catch (error) {
          // ignore JSON parse errors
        }
        const error = new Error(message || `GitHub API error ${response.status}`);
        error.status = response.status;
        throw error;
      }
      if (response.status === 204) {
        return null;
      }
      const text = await response.text();
      return text ? JSON.parse(text) : null;
    }

    async function fetchSnapshotContent({ owner, repo, ref, path }) {
      const token = getStoredToken();
      const normalizedPath = path.replace(/^\/+/, '');
      const encodedPath = encodePathSegments(normalizedPath);
      const url = `https://api.github.com/repos/${owner}/${repo}/contents/${encodedPath}?ref=${encodeURIComponent(ref)}`;
      const headers = { 'Accept': 'application/vnd.github.v3.raw' };
      if (token) {
        headers.Authorization = `Bearer ${token}`;
      }
      const response = await fetch(url, { headers });
      if (!response.ok) {
        const errorText = await response.text();
        let message = `GitHub returned ${response.status}`;
        try {
          const parsed = JSON.parse(errorText);
          message = parsed.message || message;
        } catch (error) {
          // ignore JSON parse errors
        }
        throw new Error(message);
      }
      return response.text();
    }

    async function fetchCommitMetadata({ owner, repo, ref }) {
      try {
        return await githubRest(`/repos/${owner}/${repo}/commits/${encodeURIComponent(ref)}`);
      } catch (error) {
        if (error.status !== 404) {
          console.warn('Failed to fetch commit metadata', error);
        }
        return null;
      }
    }

    function loadSnapshotHistory() {
      try {
        const raw = localStorage.getItem(SNAPSHOT_HISTORY_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        console.warn('Unable to parse snapshot history', error);
        return [];
      }
    }

    function rememberSnapshot() {
      const history = loadSnapshotHistory();
      const key = `${snapshotState.owner}/${snapshotState.repo}/${snapshotState.sha}/${snapshotState.path}`;
      const entry = {
        key,
        owner: snapshotState.owner,
        repo: snapshotState.repo,
        sha: snapshotState.sha,
        path: snapshotState.path,
        branch: snapshotState.branch,
        base: snapshotState.base,
        fileName: snapshotState.fileName,
        committedAt: snapshotState.committedAt,
        author: snapshotState.author,
        message: snapshotState.message,
        commitUrl: snapshotState.commitUrl
      };
      const filtered = history.filter(item => item.key !== key);
      filtered.unshift(entry);
      if (filtered.length > 8) {
        filtered.length = 8;
      }
      try {
        localStorage.setItem(SNAPSHOT_HISTORY_KEY, JSON.stringify(filtered));
      } catch (error) {
        console.warn('Unable to persist snapshot history', error);
      }
      renderRecentSnapshots(filtered);
    }

    function renderRecentSnapshots(history = null) {
      if (!previewDom.recentList) return;
      const snapshots = Array.isArray(history) ? history : loadSnapshotHistory();
      previewDom.recentList.innerHTML = '';
      if (!snapshots.length) {
        previewDom.recentShell.hidden = true;
        return;
      }
      snapshots.forEach(item => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'history-chip-button';
        button.innerHTML = `
          <strong>${escapeHtml(`${item.owner}/${item.repo}`)}</strong>
          <span>${escapeHtml(item.path || '')}</span>
          <span>${escapeHtml((item.sha || '').slice(0, 7))}</span>
        `;
        button.title = `${item.owner}/${item.repo}\n${item.path}\n${item.sha}`;
        button.addEventListener('click', () => {
          previewDom.owner.value = item.owner || '';
          previewDom.repo.value = item.repo || '';
          previewDom.sha.value = item.sha || '';
          previewDom.path.value = item.path || '';
          previewDom.branch.value = item.branch || '';
          previewDom.base.value = item.base || '';
          previewDom.fileName.value = item.fileName || deriveDownloadNameFromPath(item.path || '', item.sha || '');
          const seedMeta = {
            message: item.message || '',
            committedAt: item.committedAt || '',
            author: item.author || '',
            commitUrl: item.commitUrl || ''
          };
          activateTab('tab-preview');
          loadSnapshot({ remember: false, seedMeta });
        });
        previewDom.recentList.appendChild(button);
      });
      previewDom.recentShell.hidden = false;
    }

    function resetSnapshotForm() {
      if (!previewDom.form) return;
      previewDom.form.reset();
      Object.assign(snapshotState, {
        owner: '',
        repo: '',
        sha: '',
        path: '',
        branch: '',
        base: '',
        fileName: '',
        committedAt: '',
        author: '',
        message: '',
        commitUrl: '',
        content: '',
        rawUrl: ''
      });
      clearSnapshotView();
      setSnapshotStatus('');
    }

    async function loadSnapshot({ remember = true, seedMeta = null } = {}) {
      if (!previewDom.form) return;
      const owner = previewDom.owner.value.trim();
      const repo = previewDom.repo.value.trim();
      const refInput = previewDom.sha.value.trim();
      const pathInput = previewDom.path.value.trim();
      if (!owner || !repo || !refInput || !pathInput) {
        setSnapshotStatus('Fill out owner, repository, commit, and path to load a snapshot.', 'error');
        return;
      }
      const branchInput = previewDom.branch.value.trim();
      const baseInput = previewDom.base.value.trim();
      const normalizedPath = pathInput.replace(/^\/+/, '');
      const downloadName = previewDom.fileName.value.trim() || deriveDownloadNameFromPath(normalizedPath, refInput);
      previewDom.fileName.value = downloadName;
      const metaSeed = seedMeta || {};
      Object.assign(snapshotState, {
        owner,
        repo,
        sha: refInput,
        path: normalizedPath,
        branch: branchInput,
        base: baseInput,
        fileName: downloadName,
        content: '',
        rawUrl: '',
        message: metaSeed.message || '',
        committedAt: metaSeed.committedAt || '',
        author: metaSeed.author || '',
        commitUrl: metaSeed.commitUrl || ''
      });
      clearSnapshotView();
      setSnapshotStatus(`Loading ${normalizedPath} from ${refInput.slice(0, 12)}â€¦`);
      try {
        const content = await fetchSnapshotContent({ owner, repo, ref: refInput, path: normalizedPath });
        snapshotState.content = content;
        previewDom.raw.value = content;
        previewDom.rawShell.hidden = false;
        previewDom.previewShell.hidden = false;
        previewDom.frame.srcdoc = content;
        previewDom.actionRow.hidden = false;
        const commitData = await fetchCommitMetadata({ owner, repo, ref: refInput });
        if (commitData) {
          snapshotState.sha = commitData.sha || snapshotState.sha;
          previewDom.sha.value = commitData.sha || refInput;
          snapshotState.commitUrl = snapshotState.commitUrl || commitData.html_url || '';
          snapshotState.message = snapshotState.message || (commitData.commit?.message ? commitData.commit.message.split('\n')[0] : '');
          snapshotState.committedAt = snapshotState.committedAt || commitData.commit?.author?.date || commitData.commit?.committer?.date || '';
          snapshotState.author = snapshotState.author || commitData.commit?.author?.name || commitData.commit?.committer?.name || '';
        }
        const rawRef = snapshotState.sha || refInput;
        snapshotState.rawUrl = `https://raw.githubusercontent.com/${owner}/${repo}/${rawRef}/${encodePathSegments(normalizedPath)}`;
        updateSnapshotMeta();
        setSnapshotStatus(`Snapshot loaded for ${normalizedPath}.`, 'success');
        if (remember) {
          rememberSnapshot();
        } else {
          renderRecentSnapshots();
        }
      } catch (error) {
        console.error('Snapshot load failed', error);
        setSnapshotStatus(`Failed to load snapshot: ${error.message}`, 'error');
        clearSnapshotView();
      }
    }

    function downloadSnapshot() {
      if (!snapshotState.content) {
        setSnapshotStatus('Load a snapshot first.', 'error');
        return;
      }
      const desiredName = previewDom.fileName.value.trim() || deriveDownloadNameFromPath(snapshotState.path, snapshotState.sha);
      const safeName = desiredName.replace(/[\\/:*?"<>|]+/g, '-');
      const blob = new Blob([snapshotState.content], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = safeName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      setSnapshotStatus(`Downloaded ${safeName}.`, 'success');
    }

    async function copySnapshotToClipboard() {
      if (!snapshotState.content) {
        setSnapshotStatus('Load a snapshot first.', 'error');
        return;
      }
      if (!navigator.clipboard) {
        setSnapshotStatus('Clipboard access unavailable. Copy directly from the raw text area.', 'error');
        return;
      }
      try {
        await navigator.clipboard.writeText(snapshotState.content);
        setSnapshotStatus('Snapshot copied to clipboard.', 'success');
      } catch (error) {
        console.warn('Unable to copy snapshot', error);
        setSnapshotStatus('Unable to copy snapshot. Copy from the raw text area instead.', 'error');
      }
    }

    function openRawSnapshot() {
      if (!snapshotState.rawUrl) {
        setSnapshotStatus('Load a snapshot first.', 'error');
        return;
      }
      window.open(snapshotState.rawUrl, '_blank', 'noopener');
    }

    function encodeGitRef(ref) {
      return ref.split('/').map(segment => encodeURIComponent(segment)).join('/');
    }

    async function ensureSnapshotBranch({ owner, repo, branchName, sourceSha }) {
      const token = getStoredToken();
      if (!token) {
        throw new Error('Set a GitHub token in Codex Recall to promote snapshots.');
      }
      const encodedBranch = encodeGitRef(branchName);
      try {
        const existing = await githubRest(`/repos/${owner}/${repo}/git/refs/heads/${encodedBranch}`);
        if (existing?.object?.sha === sourceSha) {
          return { created: false, updated: false };
        }
        const confirmReset = confirm(`Branch ${branchName} already exists. Reset it to ${sourceSha.slice(0, 7)}?`);
        if (!confirmReset) {
          throw new Error('Branch promotion cancelled.');
        }
        await githubRest(`/repos/${owner}/${repo}/git/refs/heads/${encodedBranch}`, {
          method: 'PATCH',
          body: JSON.stringify({ sha: sourceSha, force: true })
        });
        return { created: false, updated: true };
      } catch (error) {
        if (error.status === 404) {
          await githubRest(`/repos/${owner}/${repo}/git/refs`, {
            method: 'POST',
            body: JSON.stringify({ ref: `refs/heads/${branchName}`, sha: sourceSha })
          });
          return { created: true, updated: false };
        }
        throw error;
      }
    }

    async function promoteSnapshot() {
      if (!snapshotState.content) {
        setSnapshotStatus('Load a snapshot first.', 'error');
        return;
      }
      const owner = snapshotState.owner;
      const repo = snapshotState.repo;
      if (!owner || !repo) {
        setSnapshotStatus('Owner and repository are required to promote a snapshot.', 'error');
        return;
      }
      const branchName = previewDom.branch.value.trim() || `history/${(snapshotState.sha || 'snapshot').slice(0, 7)}`;
      const baseBranch = previewDom.base.value.trim() || 'main';
      if (!snapshotState.sha) {
        setSnapshotStatus('Resolve the commit before promoting the snapshot.', 'error');
        return;
      }
      if (!/^[0-9a-f]{7,40}$/i.test(snapshotState.sha)) {
        setSnapshotStatus('The commit reference must resolve to a full commit SHA before promotion.', 'error');
        return;
      }
      try {
        setSnapshotStatus(`Preparing branch ${branchName}â€¦`);
        const result = await ensureSnapshotBranch({ owner, repo, branchName, sourceSha: snapshotState.sha });
        const action = result.created ? 'created' : (result.updated ? 'reset' : 'reused');
        setSnapshotStatus(`Branch ${branchName} ${action}. Opening compare viewâ€¦`, 'success');
        const compareUrl = `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(branchName)}?expand=1`;
        window.open(compareUrl, '_blank', 'noopener');
      } catch (error) {
        console.error('Snapshot promotion failed', error);
        setSnapshotStatus(`Promotion failed: ${error.message}`, 'error');
      }
    }

    function hydrateSnapshotFromQuery() {
      if (!previewDom.form) return;
      const params = new URLSearchParams(window.location.search);
      const owner = params.get('owner') || '';
      const repo = params.get('repo') || '';
      const path = params.get('path') || '';
      const shaParam = params.get('sha') || params.get('ref') || '';
      if (!owner || !repo || !path || !shaParam) {
        renderRecentSnapshots();
        return;
      }
      previewDom.owner.value = owner;
      previewDom.repo.value = repo;
      previewDom.sha.value = shaParam;
      previewDom.path.value = path;
      const branch = params.get('ref') || '';
      if (branch) {
        previewDom.branch.value = branch;
      }
      const base = params.get('default_branch') || '';
      if (base) {
        previewDom.base.value = base;
      }
      const downloadName = deriveDownloadNameFromPath(path, shaParam);
      previewDom.fileName.value = downloadName;
      const seedMeta = {
        message: params.get('message') || '',
        committedAt: params.get('committed_at') || '',
        author: params.get('author') || '',
        commitUrl: params.get('commit_url') || ''
      };
      activateTab('tab-preview');
      loadSnapshot({ remember: false, seedMeta });
    }

    previewDom.form?.addEventListener('submit', event => {
      event.preventDefault();
      loadSnapshot();
    });
    previewDom.resetButton?.addEventListener('click', resetSnapshotForm);
    previewDom.downloadButton?.addEventListener('click', downloadSnapshot);
    previewDom.copyButton?.addEventListener('click', copySnapshotToClipboard);
    previewDom.openRawButton?.addEventListener('click', openRawSnapshot);
    previewDom.promoteButton?.addEventListener('click', promoteSnapshot);

    resetSnapshotForm();
    hydrateSnapshotFromQuery();
    renderRecentSnapshots();

    if (codex) {
      window.addEventListener('codexrecall:checklist-updated', event => {
        const update = event.detail;
        if (!update || !update.payload || !Array.isArray(update.payload.entries)) return;
        if (pendingSaveKey && update.key === pendingSaveKey) return;
        const wasAdopted = adoptChecklist(update);
        if (!wasAdopted) return;
        const isSameRepo = currentChecklist && update.owner === currentChecklist.owner && update.repo === currentChecklist.repo;
        if (isSameRepo) {
          setStatus(`Checklist refreshed with ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'}.`);
        } else {
          setStatus(`Switched to ${formatLabel(update)} (${entries.length} entr${entries.length === 1 ? 'y' : 'ies'}).`);
        }
      });
    }

    if (currentChecklist && entries.length) {
      setStatus(`Loaded ${entries.length} entr${entries.length === 1 ? 'y' : 'ies'} from ${formatLabel(currentChecklist)}.`);
    } else {
      setStatus('No checklist loaded yet. Use the Codex checklist view or import JSON to begin.');
    }

    dom.entryList.addEventListener('click', handleEntryClick);
    dom.entryList.addEventListener('dblclick', handleDoubleClick);
    dom.refreshButton.addEventListener('click', handleRefresh);
    dom.exportButton.addEventListener('click', handleExportJson);
    dom.exportTextButton.addEventListener('click', handleExportText);
    dom.exportMarkdownButton.addEventListener('click', handleExportMarkdown);
    dom.exportCsvButton.addEventListener('click', handleExportCsv);
    dom.exportPdfButton.addEventListener('click', handleExportPdf);
    dom.saveButton.addEventListener('click', saveState);
    dom.importInput.addEventListener('change', handleImport);

    renderEntries();
  </script>
</body>
</html>
