<!-- orbital8-refactored - Modular Architecture -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital8 Refactored</title>
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        :root {
            --accent: #f59e0b;
            --glass: rgba(255, 255, 255, 0.1);
            --border: rgba(255, 255, 255, 0.3);
            --dark: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            --glow: 0.6;
            --ripple: 1500ms;
        }
        * { box-sizing: border-box; }
        body, html {
            margin: 0; padding: 0; height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden; background: #000; overscroll-behavior: none; touch-action: none;
        }
        .screen {
            position: fixed; inset: 0; background: var(--dark);
            display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .screen.hidden { display: none; }
        .card {
            background: var(--glass); backdrop-filter: blur(20px);
            border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 20px;
            padding: 40px; text-align: center; max-width: 500px; width: 90%;
        }
        .title { color: white; font-size: 24px; font-weight: 600; margin-bottom: 16px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .subtitle { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 24px; }
        .input, .notes-textarea, .tag-input {
            width: 100%; padding: 12px 16px; border: 1px solid var(--border); border-radius: 12px;
            background: var(--glass); color: white; font-size: 14px; margin-bottom: 16px; backdrop-filter: blur(10px);
        }
        .input::placeholder, .tag-input::placeholder { color: rgba(255, 255, 255, 0.5); }
        .input:focus, .notes-textarea:focus, .tag-input:focus {
            outline: none; border-color: var(--accent); box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }
        .notes-textarea { min-height: 120px; font-family: inherit; resize: vertical; }
        #action-modal .tag-input, #grid-modal .input {
            color: #1f2937; background: #f3f4f6; border-color: #d1d5db;
        }
        .button, .folder-button, .btn {
            background: linear-gradient(45deg, var(--accent), #d97706); border: none; border-radius: 15px;
            color: white; font-size: 18px; font-weight: 600; padding: 16px 32px; cursor: pointer;
            transition: all 0.3s ease; box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4); width: 100%; margin-bottom: 16px;
        }
        .button:hover:not(:disabled), .folder-button:hover, .btn:hover:not(:disabled) {
            transform: translateY(-2px); box-shadow: 0 6px 25px rgba(245, 158, 11, 0.6);
        }
        .button:disabled, .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .folder-button {
            flex: 1; padding: 12px 24px; border: 1px solid var(--border); background: var(--glass);
            font-size: 14px; backdrop-filter: blur(10px); width: auto;
        }
        .folder-button.danger { border-color: rgba(239, 68, 68, 0.3); color: #ef4444; }
        .folder-button.danger:hover { background: rgba(239, 68, 68, 0.1); }
        .btn { padding: 4px 12px; border-radius: 6px; font-size: 14px; font-weight: 500; margin-bottom: 0; width: auto; }
        .btn-primary { background-color: #3b82f6; }
        .btn-primary:hover:not(:disabled) { background-color: #2563eb; }
        .btn-danger { background-color: #ef4444; }
        .btn-danger:hover:not(:disabled) { background-color: #dc2626; }
        .btn-secondary { background-color: #e5e7eb; color: #4b5563; }
        .btn-secondary:hover:not(:disabled) { background-color: #d1d5db; }
        .provider-button {
            display: flex; align-items: center; justify-content: center; gap: 12px;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px; padding: 20px; margin-bottom: 16px; color: white;
            font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .provider-button:hover {
            background: rgba(255, 255, 255, 0.2); border-color: var(--accent);
            transform: translateY(-2px); box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        .settings-section {
            margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        .intensity-options { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
        .intensity-btn {
            padding: 8px 16px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; cursor: pointer; font-size: 12px;
            transition: all 0.2s ease;
        }
        .intensity-btn:hover { background: rgba(255, 255, 255, 0.2); }
        .intensity-btn.active { border-color: var(--accent); background: rgba(245, 158, 11, 0.2); color: var(--accent); }
        .checkbox-label {
            color: rgba(255, 255, 255, 0.9); font-size: 14px; display: flex;
            align-items: center; gap: 8px; cursor: pointer; justify-content: center;
        }
        .status {
            padding: 12px; border-radius: 8px; margin-top: 16px; font-size: 14px; font-weight: 500;
        }
        .status.success { background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); }
        .status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); }
        .status.info { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.3); }
        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8); color: white; padding: 12px 20px; border-radius: 8px;
            font-size: 14px; font-weight: 500; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; backdrop-filter: blur(10px);
        }
        .toast.show { opacity: 1; }
        .toast.success { background: rgba(16, 185, 129, 0.9); }
        .toast.info { background: rgba(59, 130, 246, 0.9); }
        .toast.error { background: rgba(239, 68, 68, 0.9); }
        .folder-list { flex: 1; overflow-y: auto; margin-bottom: 20px; max-height: 400px; }
        .folder-item {
            display: flex; align-items: center; padding: 12px 16px; margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; cursor: pointer; transition: all 0.2s ease; color: white; justify-content: space-between;
        }
        .folder-item:hover {
            background: rgba(255, 255, 255, 0.1); border-color: rgba(245, 158, 11, 0.3); transform: translateY(-1px);
        }
        .folder-icon { width: 20px; height: 20px; margin-right: 12px; color: var(--accent); }
        .folder-info { flex: 1; }
        .folder-name { font-weight: 500; margin-bottom: 2px; }
        .folder-date { font-size: 12px; color: rgba(255, 255, 255, 0.6); }
        .folder-actions { display: flex; gap: 8px; margin-left: 12px; }
        .folder-action-btn {
            padding: 6px 12px; border: 1px solid rgba(255, 255, 255, 0.3); border-radius: 8px;
            background: rgba(255, 255, 255, 0.1); color: white; font-size: 12px; cursor: pointer;
            transition: all 0.2s ease; backdrop-filter: blur(10px);
        }
        .folder-action-btn:hover { background: rgba(255, 255, 255, 0.2); transform: translateY(-1px); }
        .folder-action-btn.drill-btn { border-color: rgba(245, 158, 11, 0.4); color: var(--accent); }
        .folder-action-btn.drill-btn:hover { background: rgba(245, 158, 11, 0.2); }
        .folder-action-btn.select-btn { border-color: rgba(16, 185, 129, 0.4); color: #10b981; }
        .folder-action-btn.select-btn:hover { background: rgba(16, 185, 129, 0.2); }
        .spinner {
            width: 20px; height: 20px; border: 2px solid rgba(245, 158, 11, 0.3);
            border-radius: 50%; border-top-color: var(--accent); animation: spin 1s linear infinite; margin-right: 12px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-counter { color: var(--accent); font-size: 48px; font-weight: 700; margin: 20px 0; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8); }
        .loading-message { color: rgba(255, 255, 255, 0.7); font-size: 16px; margin-bottom: 20px; }
        .loading-progress { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.2); border-radius: 3px; overflow: hidden; margin-bottom: 20px; }
        .loading-progress-bar { height: 100%; background: linear-gradient(45deg, var(--accent), #d97706); border-radius: 3px; transition: width 0.3s ease; width: 0%; }
        #app-root { position: relative; width: 100vw; height: 100vh; background: var(--dark); overflow: hidden; }
        .hidden { display: none !important; }
        .app-footer {
            position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8);
            color: rgba(255, 255, 255, 0.6); text-align: center; padding: 4px 8px;
            font-size: 10px; z-index: 5; backdrop-filter: blur(10px);
        }
    </style>
</head>
<body>
    <!-- ========================================================================= -->
    <!-- MODULE A: PROVIDER SELECTION, AUTH, FOLDER SELECTION (UNTOUCHED)         -->
    <!-- ========================================================================= -->
    
    <div class="screen" id="provider-screen">
        <div class="card">
            <h1 class="title" style="font-size: 32px;">Orbital8</h1>
            <p class="subtitle">Select your cloud storage provider</p>
            <button class="provider-button" id="google-drive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M6.28 7L9.69 1h4.62l3.41 6zM16.05 7H7.95l4.05 7zM11.76 15h8.58L24 21H7.05z"/>
                </svg>
                Google Drive
            </button>
            <button class="provider-button" id="onedrive-btn">
                <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M17.75 8C16.82 8 16 8.82 16 9.75S16.82 11.5 17.75 11.5s1.75-.82 1.75-1.75S18.68 8 17.75 8z"/>
                </svg>
                OneDrive
            </button>
            <div class="settings-section">
                <div style="margin-bottom: 16px;">
                    <label style="color: rgba(255,255,255,0.9); font-size: 14px; font-weight: 500; display: block; margin-bottom: 8px;">Visual Cue Intensity:</label>
                    <div class="intensity-options">
                        <button class="intensity-btn" data-level="low">Low</button>
                        <button class="intensity-btn active" data-level="medium">Medium</button>
                        <button class="intensity-btn" data-level="high">High</button>
                    </div>
                </div>
                <div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="haptic-enabled" checked style="margin: 0;">
                        Enable Haptic Feedback (Mobile)
                    </label>
                </div>
            </div>
            <div id="provider-status" class="status info">Choose your preferred cloud storage</div>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <div class="screen hidden" id="gdrive-auth-screen">
        <div class="card">
            <h1 class="title">Google Drive</h1>
            <p class="subtitle">Connect to Google Drive</p>
            <input type="password" id="gdrive-client-secret" class="input" placeholder="Enter Google Client Secret">
            <button class="button" id="gdrive-auth-button">Connect Drive</button>
            <button class="button" id="gdrive-back-button" style="background: rgba(128,128,128,0.3);">â† Back</button>
            <div id="gdrive-auth-status" class="status info">Enter your client secret to continue</div>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <div class="screen hidden" id="onedrive-auth-screen">
        <div class="card">
            <h1 class="title">OneDrive</h1>
            <p class="subtitle">Connect to OneDrive</p>
            <button class="button" id="onedrive-auth-button">Connect OneDrive</button>
            <button class="button" id="onedrive-back-button" style="background: rgba(128,128,128,0.3);">â† Back</button>
            <div id="onedrive-auth-status" class="status info">Click to sign in with your Microsoft account</div>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <div class="screen hidden" id="gdrive-folder-screen">
        <div class="card" style="max-height: 80vh; display: flex; flex-direction: column;">
            <h2 class="title">Google Drive - Select Folder</h2>
            <div class="subtitle">Choose a folder containing images</div>
            <div class="folder-list" id="gdrive-folder-list"></div>
            <div class="folder-actions">
                <button class="folder-button" id="gdrive-refresh-folders">Refresh</button>
                <button class="folder-button" id="gdrive-back-to-provider">â† Provider</button>
                <button class="folder-button danger" id="gdrive-logout">Disconnect</button>
            </div>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <div class="screen hidden" id="onedrive-folder-screen">
        <div class="card" style="max-height: 80vh; display: flex; flex-direction: column;">
            <h2 class="title">OneDrive - Select Folder</h2>
            <div class="subtitle" id="onedrive-folder-subtitle">Starting from Downloads folder - browse or select any folder</div>
            <div class="folder-list" id="onedrive-folder-list"></div>
            <div class="folder-actions">
                <button class="folder-button" id="onedrive-refresh-folders">Refresh</button>
                <button class="folder-button" id="onedrive-back-to-provider">â† Provider</button>
                <button class="folder-button danger" id="onedrive-logout">Disconnect</button>
            </div>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <div class="screen hidden" id="loading-screen" style="z-index: 1500;">
        <div class="card">
            <h2 class="title">Loading Images</h2>
            <div class="loading-counter" id="loading-counter">0</div>
            <div class="loading-message" id="loading-message">Processing files...</div>
            <div class="loading-progress">
                <div class="loading-progress-bar" id="loading-progress-bar"></div>
            </div>
            <button class="button" id="cancel-loading" style="background: rgba(239, 68, 68, 0.8); margin-top: 16px;">Cancel</button>
        </div>
        <div class="app-footer">orbital8-refactored</div>
    </div>
    
    <!-- ========================================================================= -->
    <!-- APP ROOT: FRAMEWORK-DRIVEN UI (REBUILT)                                   -->
    <!-- ========================================================================= -->
    
    <div id="app-root" class="hidden"></div>
    <div id="toast" class="toast"></div>

    <script>
        // =====================================================================
        // MODULE A: PROVIDER INFRASTRUCTURE (UNTOUCHED)
        // =====================================================================
        
        class BaseProvider {
            getUserMetadata(fileId) {
                if (this.name === 'googledrive') {
                    const file = ModuleA.state.files.find(f => f.id === fileId);
                    const providerData = file ? file.appProperties : {};
                    return {
                        stack: providerData?.slideboxStack || 'in',
                        tags: providerData?.slideboxTags ? providerData.slideboxTags.split(',').map(t => t.trim()) : [],
                        qualityRating: parseInt(providerData?.qualityRating) || 0,
                        contentRating: parseInt(providerData?.contentRating) || 0,
                        notes: providerData?.notes || '',
                        stackSequence: parseInt(providerData?.stackSequence) || 0
                    };
                } else {
                    if (this.metadataCache.has(fileId)) {
                        return this.metadataCache.get(fileId);
                    }
                    return {
                        stack: 'in', tags: [], qualityRating: 0, contentRating: 0, notes: '', stackSequence: 0
                    };
                }
            }

            updateUserMetadata(fileId, updates) {
                if (this.name === 'googledrive') {
                    const file = ModuleA.state.files.find(f => f.id === fileId);
                    if(file) Object.assign(file, updates);

                    const properties = {};
                    if (updates.stack) properties.slideboxStack = updates.stack;
                    if (updates.tags) properties.slideboxTags = updates.tags.join(',');
                    if (updates.qualityRating !== undefined) properties.qualityRating = updates.qualityRating.toString();
                    if (updates.contentRating !== undefined) properties.contentRating = updates.contentRating.toString();
                    if (updates.notes !== undefined) properties.notes = updates.notes;
                    if (updates.stackSequence !== undefined) properties.stackSequence = updates.stackSequence.toString();
                    
                    return this.updateFileProperties(fileId, properties);

                } else {
                    const currentMetadata = this.getUserMetadata(fileId);
                    const newMetadata = { ...currentMetadata, ...updates };
                    this.metadataCache.set(fileId, newMetadata);
                    this.dirtyFiles.add(fileId);
                    
                    const file = ModuleA.state.files.find(f => f.id === fileId);
                    if(file) Object.assign(file, updates);
                }
            }
        }

        class GoogleDriveProvider extends BaseProvider {
            constructor() {
                super();
                this.name = 'googledrive';
                this.clientId = '567988062464-fa6c1ovesqeudqs5398vv4mbo6q068p9.apps.googleusercontent.com';
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scope = 'https://www.googleapis.com/auth/drive';
                this.apiBase = 'https://www.googleapis.com/drive/v3';
                this.accessToken = null;
                this.refreshToken = null;
                this.clientSecret = null;
                this.isAuthenticated = false;
                this.onProgressCallback = null;
                this.loadStoredCredentials();
            }
            
            loadStoredCredentials() {
                this.accessToken = localStorage.getItem('google_access_token');
                this.refreshToken = localStorage.getItem('google_refresh_token');
                this.clientSecret = localStorage.getItem('google_client_secret');
                this.isAuthenticated = !!(this.accessToken && this.refreshToken && this.clientSecret);
            }
            
            storeCredentials() {
                if (this.accessToken) localStorage.setItem('google_access_token', this.accessToken);
                if (this.refreshToken) localStorage.setItem('google_refresh_token', this.refreshToken);
                if (this.clientSecret) localStorage.setItem('google_client_secret', this.clientSecret);
            }
            
            clearStoredCredentials() {
                localStorage.removeItem('google_access_token');
                localStorage.removeItem('google_refresh_token');
                localStorage.removeItem('google_client_secret');
            }
            
            async authenticate(clientSecret) {
                if (clientSecret) {
                    this.clientSecret = clientSecret;
                    this.storeCredentials();
                }
                
                if (!this.clientSecret) {
                    throw new Error('Client secret is required for Google Drive authentication');
                }
                
                if (this.accessToken && this.refreshToken) {
                    try {
                        await this.makeApiCall('/files?pageSize=1');
                        this.isAuthenticated = true;
                        return true;
                    } catch (error) {
                    }
                }
                
                return new Promise((resolve, reject) => {
                    const authUrl = this.buildAuthUrl();
                    const popup = window.open(authUrl, 'google-auth', 'width=500,height=600,scrollbars=yes,resizable=yes');
                    
                    if (!popup) {
                        reject(new Error('Popup blocked by browser'));
                        return;
                    }
                    
                    const checkClosed = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkClosed);
                            reject(new Error('Authentication cancelled'));
                        }
                    }, 1000);
                    
                    const messageHandler = async (event) => {
                        if (event.origin !== window.location.origin) return;
                        
                        if (event.data.type === 'GOOGLE_AUTH_SUCCESS') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            
                            try {
                                await this.exchangeCodeForTokens(event.data.code);
                                this.isAuthenticated = true;
                                resolve(true);
                            } catch (error) {
                                reject(error);
                            }
                        } else if (event.data.type === 'GOOGLE_AUTH_ERROR') {
                            clearInterval(checkClosed);
                            window.removeEventListener('message', messageHandler);
                            popup.close();
                            reject(new Error(event.data.error));
                        }
                    };
                    
                    window.addEventListener('message', messageHandler);
                });
            }
            
            buildAuthUrl() {
                const params = new URLSearchParams({
                    client_id: this.clientId,
                    redirect_uri: this.redirectUri,
                    response_type: 'code',
                    scope: this.scope,
                    access_type: 'offline',
                    prompt: 'consent'
                });
                return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
            }
            
            async exchangeCodeForTokens(code) {
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        code: code,
                        grant_type: 'authorization_code',
                        redirect_uri: this.redirectUri
                    })
                });
                
                if (!response.ok) throw new Error('Token exchange failed');
                
                const tokens = await response.json();
                this.accessToken = tokens.access_token;
                this.refreshToken = tokens.refresh_token;
                this.storeCredentials();
            }
            
            async refreshAccessToken() {
                if (!this.refreshToken || !this.clientSecret) {
                    throw new Error('No refresh token or client secret available');
                }
                
                const response = await fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        refresh_token: this.refreshToken,
                        grant_type: 'refresh_token'
                    })
                });
                
                if (!response.ok) throw new Error('Failed to refresh access token');
                
                const tokens = await response.json();
                this.accessToken = tokens.access_token;
                this.storeCredentials();
                return this.accessToken;
            }
            
            async makeApiCall(endpoint, options = {}, isJson = true) {
                if (!this.accessToken) throw new Error('Not authenticated');
                
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = {
                    'Authorization': `Bearer ${this.accessToken}`,
                    ...options.headers
                };
                if(isJson) headers['Content-Type'] = 'application/json';
                
                let response = await fetch(url, { ...options, headers });
                
                if (response.status === 401 && this.refreshToken && this.clientSecret) {
                    try {
                        await this.refreshAccessToken();
                        headers['Authorization'] = `Bearer ${this.accessToken}`;
                        response = await fetch(url, { ...options, headers });
                    } catch (refreshError) {
                        this.isAuthenticated = false;
                        this.clearStoredCredentials();
                        throw new Error('Authentication expired. Please reconnect.');
                    }
                }
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API call failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                if (isJson) return await response.json();
                return response;
            }
            
            async getFolders() {
                const response = await this.makeApiCall('/files?q=mimeType%3D%27application/vnd.google-apps.folder%27&fields=files(id,name,createdTime,modifiedTime)&orderBy=modifiedTime%20desc');
                return response.files.map(folder => ({
                    id: folder.id,
                    name: folder.name,
                    type: 'folder',
                    createdTime: folder.createdTime,
                    modifiedTime: folder.modifiedTime
                }));
            }
            
            async getFilesAndMetadata(folderId = 'root') {
                const allFiles = [];
                let nextPageToken = null;
                
                do {
                    const query = `'${folderId}' in parents and trashed=false and (mimeType contains 'image/')`;
                    let url = `/files?q=${encodeURIComponent(query)}&fields=files(id,name,mimeType,size,createdTime,modifiedTime,thumbnailLink,webContentLink,appProperties,parents),nextPageToken&pageSize=100`;
                    
                    if (nextPageToken) url += `&pageToken=${nextPageToken}`;
                    
                    const response = await this.makeApiCall(url);
                    
                    const files = response.files
                        .filter(file => file.mimeType && file.mimeType.startsWith('image/'))
                        .map(file => ({
                            id: file.id,
                            name: file.name,
                            type: 'file',
                            mimeType: file.mimeType,
                            size: file.size ? parseInt(file.size) : 0,
                            createdTime: file.createdTime,
                            modifiedTime: file.modifiedTime,
                            thumbnailLink: file.thumbnailLink,
                            downloadUrl: file.webContentLink,
                            appProperties: file.appProperties || {},
                            parents: file.parents
                        }));
                    
                    allFiles.push(...files);
                    nextPageToken = response.nextPageToken;
                    
                    if (this.onProgressCallback) this.onProgressCallback(allFiles.length);
                    
                } while (nextPageToken);
                
                return { folders: [], files: allFiles };
            }
            
            async moveFileToStack(fileId, targetStack, sequence) {
                return this.updateUserMetadata(fileId, { stack: targetStack, stackSequence: sequence });
            }

            async moveFileToFolder(fileId, targetFolderId) {
                const file = await this.makeApiCall(`/files/${fileId}?fields=parents`);
                const previousParents = file.parents.join(',');
                await this.makeApiCall(`/files/${fileId}?addParents=${targetFolderId}&removeParents=${previousParents}&fields=id,parents`, {
                    method: 'PATCH'
                });
                await this.updateUserMetadata(fileId, { stack: 'in', stackSequence: Date.now() });
                return true;
            }
            
            async updateFileProperties(fileId, properties) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ appProperties: properties })
                });
                return true;
            }
            
            async deleteFile(fileId) {
                await this.makeApiCall(`/files/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ trashed: true })
                });
                return true;
            }
            
            async disconnect() {
                this.isAuthenticated = false;
                this.accessToken = null;
                this.refreshToken = null;
                this.clientSecret = null;
                this.clearStoredCredentials();
            }
        }

        class OneDriveProvider extends BaseProvider {
            constructor() {
                super();
                this.name = 'onedrive';
                this.apiBase = 'https://graph.microsoft.com/v1.0';
                this.isAuthenticated = false;
                this.activeAccount = null;
                this.msalInstance = null;
                this.currentParentId = null;
                this.currentParentPath = '';
                this.breadcrumb = [];
                this.onProgressCallback = null;
                this.metadataCache = new Map();
                this.dirtyFiles = new Set();
                this.initMSAL();
            }
            
            initMSAL() {
                const msalConfig = {
                    auth: {
                        clientId: 'b407fd45-c551-4dbb-9da5-cab3a2c5a949',
                        authority: 'https://login.microsoftonline.com/common',
                        redirectUri: window.location.origin + window.location.pathname
                    },
                    cache: { cacheLocation: 'localStorage' }
                };
                this.msalInstance = new msal.PublicClientApplication(msalConfig);
            }
            
            async authenticate() {
                try {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) {
                        this.msalInstance.setActiveAccount(accounts[0]);
                        this.activeAccount = accounts[0];
                    } else {
                        const loginResponse = await this.msalInstance.loginPopup({
                            scopes: ['Files.ReadWrite.AppFolder', 'User.Read']
                        });
                        this.activeAccount = loginResponse.account;
                        this.msalInstance.setActiveAccount(this.activeAccount);
                    }
                    this.isAuthenticated = true;
                    return true;
                } catch (error) {
                    this.isAuthenticated = false;
                    throw new Error(`Authentication failed: ${error.message}`);
                }
            }
            
            async getAccessToken() {
                if (!this.activeAccount) throw new Error('No active account');
                try {
                    const response = await this.msalInstance.acquireTokenSilent({
                        scopes: ['Files.ReadWrite.AppFolder'],
                        account: this.activeAccount
                    });
                    return response.accessToken;
                } catch (silentError) {
                    if (silentError instanceof msal.InteractionRequiredAuthError) {
                        const response = await this.msalInstance.acquireTokenPopup({
                            scopes: ['Files.ReadWrite.AppFolder'],
                            account: this.activeAccount
                        });
                        return response.accessToken;
                    }
                    throw silentError;
                }
            }
            
            async makeApiCall(endpoint, options = {}) {
                const accessToken = await this.getAccessToken();
                const url = endpoint.startsWith('https://') ? endpoint : `${this.apiBase}${endpoint}`;
                const headers = {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                const response = await fetch(url, { ...options, headers });
                if (response.status === 401) throw new Error('TOKEN_EXPIRED');
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API call failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                return response;
            }
            
            async getFilesAndMetadata(folderId = 'root') {
                this.metadataCache.clear();
                this.dirtyFiles.clear();
                const [imageResult, metadataFilesResult] = await Promise.all([
                    this.getFilesFromFolder(folderId),
                    this.getMetadataFileList()
                ]);
                if (metadataFilesResult.length > 0) {
                    const metadataContentPromises = metadataFilesResult.map(metaFile => 
                        this.getMetadataFileContent(metaFile.id)
                    );
                    const metadataContents = await Promise.all(metadataContentPromises);
                    metadataContents.forEach(content => {
                        if (content) this.metadataCache.set(content.id, content.data);
                    });
                }
                return { folders: [], files: imageResult };
            }

            async getFilesFromFolder(folderId) {
                const allFiles = [];
                let endpoint = folderId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${folderId}/children`;
                let nextLink = `${this.apiBase}${endpoint}`;
                while(nextLink) {
                    const response = await this.makeApiCall(nextLink.replace(this.apiBase, ''));
                    const data = await response.json();
                    const files = data.value
                        .filter(item => item.file && item.file.mimeType && item.file.mimeType.startsWith('image/'))
                        .map(item => ({
                            id: item.id,
                            name: item.name,
                            type: 'file',
                            mimeType: item.file.mimeType,
                            size: item.size || 0,
                            createdTime: item.createdDateTime,
                            modifiedTime: item.lastModifiedDateTime,
                            thumbnails: item.thumbnails && item.thumbnails.length > 0 ? {
                                large: item.thumbnails[0].large
                            } : null,
                            downloadUrl: item['@microsoft.graph.downloadUrl']
                        }));
                    allFiles.push(...files);
                    nextLink = data['@odata.nextLink'];
                    if (this.onProgressCallback) this.onProgressCallback(allFiles.length);
                }
                return allFiles;
            }

            async getMetadataFileList() {
                try {
                    const response = await this.makeApiCall('/me/drive/special/approot/children');
                    const data = await response.json();
                    return data.value.filter(item => item.name.endsWith('.json'));
                } catch (error) {
                    return [];
                }
            }

            async getMetadataFileContent(metadataFileId) {
                try {
                    const response = await this.makeApiCall(`/me/drive/items/${metadataFileId}/content`);
                    const data = await response.json();
                    const imageId = metadataFileId.replace('.json', '');
                    return { id: imageId, data: data };
                } catch (error) {
                    return null;
                }
            }
            
            async getDownloadsFolder() {
                try {
                    const response = await this.makeApiCall('/me/drive/root/children');
                    const data = await response.json();
                    const downloadsFolder = data.value.find(item => 
                        item.folder && (item.name.toLowerCase() === 'downloads' || item.name.toLowerCase() === 'download')
                    );
                    if (downloadsFolder) return downloadsFolder;
                    return { id: 'root', name: 'Root', folder: true };
                } catch (error) {
                    return { id: 'root', name: 'Root', folder: true };
                }
            }
            
            async getFolders() {
                try {
                    const downloadsFolder = await this.getDownloadsFolder();
                    this.currentParentId = downloadsFolder.id;
                    this.currentParentPath = downloadsFolder.name;
                    this.breadcrumb = [{ id: downloadsFolder.id, name: downloadsFolder.name }];
                    return await this.loadFoldersInParent(downloadsFolder.id);
                } catch (error) {
                    return [];
                }
            }
            
            async loadFoldersInParent(parentId) {
                try {
                    const folders = [];
                    let endpoint = parentId === 'root' ? '/me/drive/root/children' : `/me/drive/items/${parentId}/children`;
                    let nextLink = `${this.apiBase}${endpoint}`;
                    do {
                        const response = await this.makeApiCall(nextLink.replace(this.apiBase, ''));
                        const data = await response.json();
                        const folderItems = data.value
                            .filter(item => item.folder)
                            .map(folder => ({
                                id: folder.id,
                                name: folder.name,
                                type: 'folder',
                                createdTime: folder.createdDateTime,
                                modifiedTime: folder.lastModifiedDateTime,
                                itemCount: folder.folder.childCount || 0,
                                hasChildren: (folder.folder.childCount || 0) > 0
                            }));
                        folders.push(...folderItems);
                        nextLink = data['@odata.nextLink'];
                    } while (nextLink);
                    return folders.sort((a, b) => a.name.localeCompare(b.name));
                } catch (error) {
                    return [];
                }
            }
            
            async drillIntoFolder(folder) {
                try {
                    this.breadcrumb.push({ id: folder.id, name: folder.name });
                    this.currentParentId = folder.id;
                    this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / ');
                    return await this.loadFoldersInParent(folder.id);
                } catch (error) {
                    return [];
                }
            }
            
            async navigateToParent() {
                if (this.breadcrumb.length <= 1) return await this.getFolders();
                this.breadcrumb.pop();
                const parentFolder = this.breadcrumb[this.breadcrumb.length - 1];
                this.currentParentId = parentFolder.id;
                this.currentParentPath = this.breadcrumb.map(b => b.name).join(' / ');
                return await this.loadFoldersInParent(parentFolder.id);
            }
            
            getCurrentPath() { return this.currentParentPath; }
            canGoUp() { return this.breadcrumb.length > 1; }
            
            async moveFileToStack(fileId, targetStack, sequence) {
                this.updateUserMetadata(fileId, { stack: targetStack, stackSequence: sequence });
            }

            async moveFileToFolder(fileId, targetFolderId) {
                await this.makeApiCall(`/me/drive/items/${fileId}`, {
                    method: 'PATCH',
                    body: JSON.stringify({ parentReference: { id: targetFolderId } })
                });
                this.updateUserMetadata(fileId, { stack: 'in', stackSequence: Date.now() });
                return true;
            }
            
            async deleteFile(fileId) {
                await this.makeApiCall(`/me/drive/items/${fileId}`, { method: 'DELETE' });
                this.metadataCache.delete(fileId);
                this.dirtyFiles.add(fileId);
                return true;
            }
            
            async disconnect() {
                this.isAuthenticated = false;
                this.activeAccount = null;
                if (this.msalInstance) {
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) {
                        await this.msalInstance.logoutPopup({ account: accounts[0] });
                    }
                }
            }
        }
        
        if (window.location.search.includes('code=') || window.location.search.includes('error=')) {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            if (window.opener) {
                if (error) {
                    window.opener.postMessage({ type: 'GOOGLE_AUTH_ERROR', error: error }, window.location.origin);
                } else if (code) {
                    window.opener.postMessage({ type: 'GOOGLE_AUTH_SUCCESS', code: code }, window.location.origin);
                }
                window.close();
            }
        }
        
        const ModuleA = {
            state: {
                provider: null,
                providerType: null,
                folderId: null,
                folderName: '',
                files: [],
                visualIntensity: localStorage.getItem('orbital8_visual_intensity') || 'medium',
                hapticEnabled: localStorage.getItem('orbital8_haptic_enabled') !== 'false'
            },
            
            init() {
                this.setupProviderSelection();
                this.setupSettings();
                this.setupGoogleDrive();
                this.setupOneDrive();
            },
            
            setupProviderSelection() {
                document.getElementById('google-drive-btn').onclick = () => this.selectGoogleDrive();
                document.getElementById('onedrive-btn').onclick = () => this.selectOneDrive();
            },
            
            setupSettings() {
                document.querySelectorAll('.intensity-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.state.visualIntensity = btn.dataset.level;
                        localStorage.setItem('orbital8_visual_intensity', btn.dataset.level);
                        document.querySelectorAll('.intensity-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.level === btn.dataset.level);
                        });
                    });
                });
                document.getElementById('haptic-enabled').addEventListener('change', (e) => {
                    this.state.hapticEnabled = e.target.checked;
                    localStorage.setItem('orbital8_haptic_enabled', e.target.checked);
                });
            },
            
            selectGoogleDrive() {
                this.state.providerType = 'googledrive';
                this.showScreen('gdrive-auth-screen');
                const provider = new GoogleDriveProvider();
                if (provider.isAuthenticated) {
                    this.state.provider = provider;
                    this.showScreen('gdrive-folder-screen');
                    this.loadGoogleDriveFolders();
                }
            },
            
            async selectOneDrive() {
                this.state.providerType = 'onedrive';
                this.showScreen('onedrive-auth-screen');
                const provider = new OneDriveProvider();
                try {
                    const success = await provider.authenticate();
                    if (success) {
                        this.state.provider = provider;
                        this.showScreen('onedrive-folder-screen');
                        this.loadOneDriveFolders();
                    }
                } catch (error) {
                    document.getElementById('onedriveAuth-status').textContent = 'Click to sign in with your Microsoft account';
                }
            },
            
            setupGoogleDrive() {
                document.getElementById('gdrive-auth-button').onclick = async () => {
                    const clientSecret = document.getElementById('gdrive-client-secret').value.trim();
                    if (!clientSecret) {
                        document.getElementById('gdrive-auth-status').textContent = 'Please enter client secret';
                        document.getElementById('gdrive-auth-status').className = 'status error';
                        return;
                    }
                    document.getElementById('gdrive-auth-button').disabled = true;
                    document.getElementById('gdrive-auth-button').textContent = 'Connecting...';
                    document.getElementById('gdrive-auth-status').textContent = 'Connecting to Google Drive...';
                    document.getElementById('gdrive-auth-status').className = 'status info';
                    try {
                        const provider = new GoogleDriveProvider();
                        const success = await provider.authenticate(clientSecret);
                        if (success) {
                            this.state.provider = provider;
                            document.getElementById('gdrive-auth-status').textContent = 'âœ… Connected to Google Drive!';
                            document.getElementById('gdrive-auth-status').className = 'status success';
                            document.getElementById('gdrive-client-secret').value = '';
                            setTimeout(() => {
                                this.showScreen('gdrive-folder-screen');
                                this.loadGoogleDriveFolders();
                            }, 1000);
                        }
                    } catch (error) {
                        document.getElementById('gdrive-auth-status').textContent = `Authentication failed: ${error.message}`;
                        document.getElementById('gdrive-auth-status').className = 'status error';
                    } finally {
                        document.getElementById('gdrive-auth-button').disabled = false;
                        document.getElementById('gdrive-auth-button').textContent = 'Connect Drive';
                    }
                };
                document.getElementById('gdrive-back-button').onclick = () => this.backToProviderSelection();
                document.getElementById('gdrive-refresh-folders').onclick = () => this.loadGoogleDriveFolders();
                document.getElementById('gdrive-back-to-provider').onclick = () => this.backToProviderSelection();
                document.getElementById('gdrive-logout').onclick = () => {
                    this.state.provider.disconnect();
                    this.backToProviderSelection();
                };
            },
            
            setupOneDrive() {
                document.getElementById('onedrive-auth-button').onclick = async () => {
                    document.getElementById('onedrive-auth-button').disabled = true;
                    document.getElementById('onedrive-auth-button').textContent = 'Connecting...';
                    document.getElementById('onedrive-auth-status').textContent = 'Connecting to OneDrive...';
                    document.getElementById('onedrive-auth-status').className = 'status info';
                    try {
                        const provider = new OneDriveProvider();
                        const success = await provider.authenticate();
                        if (success) {
                            this.state.provider = provider;
                            document.getElementById('onedrive-auth-status').textContent = 'âœ… Connected to OneDrive!';
                            document.getElementById('onedrive-auth-status').className = 'status success';
                            setTimeout(() => {
                                this.showScreen('onedrive-folder-screen');
                                this.loadOneDriveFolders();
                            }, 1000);
                        }
                    } catch (error) {
                        document.getElementById('onedrive-auth-status').textContent = `Authentication failed: ${error.message}`;
                        document.getElementById('onedrive-auth-status').className = 'status error';
                    } finally {
                        document.getElementById('onedrive-auth-button').disabled = false;
                        document.getElementById('onedrive-auth-button').textContent = 'Connect OneDrive';
                    }
                };
                document.getElementById('onedrive-back-button').onclick = () => this.backToProviderSelection();
                document.getElementById('onedrive-refresh-folders').onclick = () => this.loadOneDriveFolders();
                document.getElementById('onedrive-back-to-provider').onclick = () => this.backToProviderSelection();
                document.getElementById('onedrive-logout').onclick = () => {
                    this.state.provider.disconnect();
                    this.backToProviderSelection();
                };
            },
            
            async loadGoogleDriveFolders() {
                document.getElementById('gdrive-folder-list').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><div class="spinner"></div><span>Loading folders...</span></div>';
                try {
                    const folders = await this.state.provider.getFolders();
                    if (folders.length === 0) {
                        document.getElementById('gdrive-folder-list').innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><span>No folders found in your Drive</span></div>';
                        return;
                    }
                    document.getElementById('gdrive-folder-list').innerHTML = '';
                    folders.forEach(folder => {
                        const div = document.createElement('div');
                        div.className = 'folder-item';
                        div.innerHTML = `
                            <svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                            </svg>
                            <div class="folder-info">
                                <div class="folder-name">${folder.name}</div>
                                <div class="folder-date">${new Date(folder.modifiedTime).toLocaleDateString()}</div>
                            </div>
                        `;
                        div.onclick = () => this.selectFolder(folder.id, folder.name);
                        document.getElementById('gdrive-folder-list').appendChild(div);
                    });
                } catch (error) {
                    this.showToast(`Error loading folders: ${error.message}`, 'error');
                }
            },
            
            async loadOneDriveFolders() {
                document.getElementById('onedrive-folder-list').innerHTML = '<div style="display: flex; align-items: center; justify-content: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><div class="spinner"></div><span>Loading folders...</span></div>';
                try {
                    const folders = await this.state.provider.getFolders();
                    this.displayOneDriveFolders(folders);
                    this.updateOneDriveNavigation();
                } catch (error) {
                    this.showToast('Error loading folders', 'error');
                }
            },
            
            displayOneDriveFolders(folders) {
                document.getElementById('onedrive-folder-list').innerHTML = '';
                if (folders.length === 0) {
                    document.getElementById('onedrive-folder-list').innerHTML = '<div style="text-align: center; padding: 40px; color: rgba(255, 255, 255, 0.7);"><span>No folders found in this location</span></div>';
                    return;
                }
                folders.forEach(folder => {
                    const div = document.createElement('div');
                    div.className = 'folder-item';
                    const hasChildren = folder.hasChildren;
                    const iconColor = hasChildren ? 'var(--accent)' : 'rgba(255, 255, 255, 0.6)';
                    div.innerHTML = `
                        <svg class="folder-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: ${iconColor};">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"></path>
                        </svg>
                        <div class="folder-info">
                            <div class="folder-name">${folder.name}</div>
                            <div class="folder-date">
                                ${new Date(folder.modifiedTime).toLocaleDateString()} â€¢ ${folder.itemCount} items
                                ${hasChildren ? ' â€¢ Has subfolders' : ''}
                            </div>
                        </div>
                        <div class="folder-actions">
                            ${hasChildren ? `<button class="folder-action-btn drill-btn" data-folder-id="${folder.id}">Browse â†’</button>` : ''}
                            <button class="folder-action-btn select-btn" data-folder-id="${folder.id}">Select</button>
                        </div>
                    `;
                    document.getElementById('onedrive-folder-list').appendChild(div);
                });
                document.querySelectorAll('.drill-btn').forEach(btn => {
                    btn.onclick = async (e) => {
                        e.stopPropagation();
                        const folderId = btn.dataset.folderId;
                        const folderElement = btn.closest('.folder-item');
                        const folderName = folderElement.querySelector('.folder-name').textContent;
                        try {
                            const subfolders = await this.state.provider.drillIntoFolder({ id: folderId, name: folderName });
                            this.displayOneDriveFolders(subfolders);
                            this.updateOneDriveNavigation();
                        } catch (error) {
                            this.showToast('Error loading subfolders', 'error');
                        }
                    };
                });
                document.querySelectorAll('.select-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const folderId = btn.dataset.folderId;
                        const folderElement = btn.closest('.folder-item');
                        const folderName = folderElement.querySelector('.folder-name').textContent;
                        this.selectFolder(folderId, folderName);
                    };
                });
            },
            
            updateOneDriveNavigation() {
                const currentPath = this.state.provider.getCurrentPath();
                const canGoUp = this.state.provider.canGoUp();
                document.getElementById('onedrive-folder-subtitle').textContent = `Current: ${currentPath}`;
                const refreshBtn = document.getElementById('onedrive-refresh-folders');
                if (canGoUp) {
                    refreshBtn.textContent = 'â† Go Up';
                    refreshBtn.onclick = async () => {
                        try {
                            const folders = await this.state.provider.navigateToParent();
                            this.displayOneDriveFolders(folders);
                            this.updateOneDriveNavigation();
                        } catch (error) {
                            this.showToast('Error navigating to parent folder', 'error');
                        }
                    };
                } else {
                    refreshBtn.textContent = 'Refresh';
                    refreshBtn.onclick = () => this.loadOneDriveFolders();
                }
            },
            
            async selectFolder(folderId, folderName) {
                this.state.folderId = folderId;
                this.state.folderName = folderName;
                this.showScreen('loading-screen');
                this.updateLoadingProgress(0, 0);
                this.state.provider.onProgressCallback = (count) => {
                    this.updateLoadingProgress(count, 0, `Found ${count} images...`);
                };
                try {
                    document.getElementById('loading-message').textContent = `Loading from ${folderName}...`;
                    const result = await this.state.provider.getFilesAndMetadata(folderId);
                    const files = result.files || [];
                    if (files.length === 0) {
                        this.showToast('No images found in this folder', 'info');
                        this.backToFolderSelection();
                        return;
                    }
                    this.updateLoadingProgress(0, files.length, 'Processing files...');
                    this.state.files = files.map((file, index) => {
                        this.updateLoadingProgress(index + 1, files.length, 'Processing files...');
                        const userMetadata = this.state.provider.getUserMetadata(file.id);
                        return {
                            id: file.id,
                            name: file.name,
                            filename: file.name,
                            originalName: file.name,
                            mimeType: file.mimeType,
                            size: file.size,
                            createdTime: file.createdTime,
                            modifiedTime: file.modifiedTime,
                            thumbnails: file.thumbnails,
                            downloadUrl: file.downloadUrl,
                            appProperties: file.appProperties,
                            extractedMetadata: {},
                            metadataStatus: 'pending',
                            ...userMetadata
                        };
                    });
                    Framework.start();
                } catch (error) {
                    this.showToast(`Error loading images: ${error.message}`, 'error');
                    this.backToFolderSelection();
                } finally {
                    if (this.state.provider) this.state.provider.onProgressCallback = null;
                }
            },
            
            backToFolderSelection() {
                if (this.state.providerType === 'googledrive') {
                    this.showScreen('gdrive-folder-screen');
                } else if (this.state.providerType === 'onedrive') {
                    this.showScreen('onedrive-folder-screen');
                }
            },
            
            backToProviderSelection() {
                this.state.provider = null;
                this.state.providerType = null;
                this.showScreen('provider-screen');
            },
            
            showScreen(screenId) {
                const screens = ['provider-screen', 'gdrive-auth-screen', 'onedrive-auth-screen', 
                               'gdrive-folder-screen', 'onedrive-folder-screen', 'loading-screen'];
                screens.forEach(id => {
                    document.getElementById(id).classList.toggle('hidden', id !== screenId);
                });
                document.getElementById('app-root').classList.add('hidden');
            },
            
            updateLoadingProgress(current, total, message = '') {
                document.getElementById('loading-counter').textContent = current;
                document.getElementById('loading-message').textContent = message || (total ? 
                    `Processing ${current} of ${total} items...` : 
                    `Found ${current} items`);
                if (total > 0) {
                    const percentage = (current / total) * 100;
                    document.getElementById('loading-progress-bar').style.width = `${percentage}%`;
                }
            },
            
            showToast(message, type = 'success') {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.className = `toast ${type} show`;
                setTimeout(() => toast.classList.remove('show'), 3000);
            }
        };
        
        document.getElementById('cancel-loading').onclick = () => {
            ModuleA.backToFolderSelection();
            ModuleA.showToast('Loading cancelled', 'info');
        };
        
        // =====================================================================
        // FRAMEWORK: DATA-DRIVEN UI ENGINE (REBUILT)
        // =====================================================================
        
        const Framework = {
            start() {
                console.log('ðŸš€ Framework starting with', ModuleA.state.files.length, 'files');
                document.getElementById('app-root').innerHTML = '<h1 style="color: white; text-align: center; margin-top: 50vh;">FRAMEWORK LOADED âœ…</h1><p style="color: white; text-align: center;">Files loaded: ' + ModuleA.state.files.length + '</p>';
                document.getElementById('app-root').classList.remove('hidden');
                const screens = ['provider-screen', 'gdrive-auth-screen', 'onedrive-auth-screen', 
                               'gdrive-folder-screen', 'onedrive-folder-screen', 'loading-screen'];
                screens.forEach(id => document.getElementById(id).classList.add('hidden'));
            }
        };
        
        // =====================================================================
        // INITIALIZATION
        // =====================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            ModuleA.init();
        });
    </script>
</body>
</html>
        };

        // =====================================================================
        // CONFIGURATION & MODULES B/C/D/E
        // =====================================================================
        const CONFIG = {
            SORT_MODULE: 1,
            GRID_MODULE: 1,
            DETAIL_MODULE: 1,
            FOCUS_MODULE: 1,
            VISUAL_EFFECTS: 1,
            DEBUG_TOASTS: 1
        };
        
        const STACKS = ['in', 'out', 'priority', 'trash'];
        
        const Utils = {
            showToast(msg) {
                if (!CONFIG.DEBUG_TOASTS) return;
                const toast = document.getElementById('toast');
                toast.textContent = msg;
                toast.classList.add('show');
                setTimeout(() => toast.classList.remove('show'), 2000);
            },
            showEdge(dir) {
                if (!CONFIG.VISUAL_EFFECTS) return;
                const edge = document.getElementById('edge-' + dir);
                edge.classList.add('active');
                setTimeout(() => edge.classList.remove('active'), 200);
            }
        };
        
        const ModuleB_Sort = {
            state: { currentIndex: 0 },
            init() {
                if (!CONFIG.SORT_MODULE) return;
                this.setupGestures();
                this.setupKeyboard();
                this.updatePills();
                this.loadImage(0);
            },
            setupGestures() {
                const layer = document.querySelector('.gesture-layer');
                let startX = 0, startY = 0;
                layer.addEventListener('pointerdown', e => { startX = e.clientX; startY = e.clientY; });
                layer.addEventListener('pointerup', e => {
                    const dx = e.clientX - startX, dy = e.clientY - startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 50) {
                        const stack = Math.abs(dy) > Math.abs(dx) ? (dy < 0 ? 'priority' : 'trash') : (dx < 0 ? 'in' : 'out');
                        this.moveToStack(stack);
                    }
                });
                let lastTap = 0;
                document.getElementById('hub-a').addEventListener('click', () => {
                    const now = Date.now();
                    if (now - lastTap < 300 && CONFIG.FOCUS_MODULE) ModuleE_Focus.enter();
                    lastTap = now;
                });
                document.querySelectorAll('.pill-counter').forEach(pill => {
                    pill.addEventListener('click', () => this.switchStack(pill.dataset.stack));
                });
            },
            moveToStack(stack) {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                const file = files[this.state.currentIndex];
                if (!file) return;
                file.stack = stack;
                ModuleA.state.provider.updateUserMetadata(file.id, { stack });
                this.updatePills();
                Utils.showEdge(stack === 'priority' ? 'top' : stack === 'trash' ? 'bottom' : stack === 'in' ? 'left' : 'right');
                Utils.showToast('Moved to ' + stack);
                this.next();
            },
            switchStack(stack) {
                ModuleA.state.currentStack = stack;
                document.querySelectorAll('.pill-counter').forEach(p => p.classList.remove('active'));
                document.querySelector('[data-stack="' + stack + '"]').classList.add('active');
                this.state.currentIndex = 0;
                this.loadImage(0);
            },
            updatePills() {
                STACKS.forEach(stack => {
                    const count = ModuleA.getFilesInStack(stack).length;
                    const pill = document.querySelector('[data-stack="' + stack + '"]');
                    pill.textContent = count;
                    pill.classList.toggle('visible', count > 0);
                });
            },
            loadImage(index) {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                if (index < 0 || index >= files.length) return;
                this.state.currentIndex = index;
                const file = files[index];
                document.getElementById('center-image').src = this.getImageUrl(file);
                document.getElementById('image-count').textContent = (index + 1) + '/' + files.length;
            },
            getImageUrl(file) {
                if (ModuleA.state.providerType === 'googledrive') {
                    return file.thumbnailLink?.replace('=s220', '=s1000') || 'https://drive.google.com/thumbnail?id=' + file.id + '&sz=w1000';
                } else {
                    return file['@microsoft.graph.downloadUrl'] || file.thumbnails?.[0]?.large?.url || '';
                }
            },
            setupKeyboard() {
                document.addEventListener('keydown', e => {
                    if (ModuleE_Focus.state.isActive) return;
                    if (e.key === 'ArrowRight' || e.key === ' ') this.next();
                    else if (e.key === 'ArrowLeft') this.previous();
                    else if (e.key === 'ArrowUp') this.moveToStack('priority');
                    else if (e.key === 'ArrowDown') this.moveToStack('trash');
                    else if (e.key === 'g' && CONFIG.GRID_MODULE) ModuleC_Grid.open();
                });
            },
            next() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                if (this.state.currentIndex < files.length - 1) this.loadImage(this.state.currentIndex + 1);
            },
            previous() {
                if (this.state.currentIndex > 0) this.loadImage(this.state.currentIndex - 1);
            }
        };
        
        const ModuleC_Grid = {
            state: { selectedIds: new Set() },
            init() {
                if (!CONFIG.GRID_MODULE) return;
                document.getElementById('grid-button').addEventListener('click', () => this.open());
                document.getElementById('close-grid').addEventListener('click', () => this.close());
            },
            open() {
                document.getElementById('grid-modal').classList.remove('hidden');
                this.render();
            },
            close() {
                document.getElementById('grid-modal').classList.add('hidden');
                this.state.selectedIds.clear();
            },
            render() {
                const container = document.getElementById('grid-container');
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                container.innerHTML = files.map(file => 
                    '<div class="grid-item ' + (this.state.selectedIds.has(file.id) ? 'selected' : '') + '" data-id="' + file.id + '" onclick="ModuleC_Grid.toggleSelection(\'' + file.id + '\')"><img class="grid-image loaded" src="' + ModuleB_Sort.getImageUrl(file) + '"></div>'
                ).join('');
            },
            toggleSelection(fileId) {
                if (this.state.selectedIds.has(fileId)) this.state.selectedIds.delete(fileId);
                else this.state.selectedIds.add(fileId);
                this.render();
            }
        };
        
        const ModuleD_Detail = {
            state: { currentTab: 'info', currentFileId: null },
            init() {
                if (!CONFIG.DETAIL_MODULE) return;
                document.getElementById('back-button').addEventListener('click', () => this.open());
                document.getElementById('close-details').addEventListener('click', () => this.close());
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.addEventListener('click', () => this.switchTab(btn.dataset.tab));
                });
                document.getElementById('save-notes').addEventListener('click', () => this.saveNotes());
                this.setupStars();
            },
            open() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                const file = files[ModuleB_Sort.state.currentIndex];
                if (!file) return;
                this.state.currentFileId = file.id;
                document.getElementById('details-modal').classList.remove('hidden');
                this.populate(file);
            },
            close() {
                document.getElementById('details-modal').classList.add('hidden');
            },
            switchTab(tab) {
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                document.querySelector('[data-tab="' + tab + '"]').classList.add('active');
                document.getElementById('tab-' + tab).classList.add('active');
            },
            populate(file) {
                document.getElementById('detail-filename').textContent = file.name;
                document.getElementById('detail-stack').textContent = file.stack || 'in';
                document.getElementById('detail-notes').value = file.notes || '';
                this.renderStars('quality-rating', file.quality || 0);
                document.getElementById('metadata-table').innerHTML = '<tr><td class="key-cell">ID</td><td class="value-cell">' + file.id + '</td></tr><tr><td class="key-cell">Name</td><td class="value-cell">' + file.name + '</td></tr>';
            },
            setupStars() {
                const container = document.getElementById('quality-rating');
                container.innerHTML = '';
                for (let i = 1; i <= 5; i++) {
                    const star = document.createElement('svg');
                    star.className = 'star';
                    star.setAttribute('fill', 'currentColor');
                    star.setAttribute('viewBox', '0 0 24 24');
                    star.innerHTML = '<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>';
                    star.addEventListener('click', () => this.setRating(i));
                    container.appendChild(star);
                }
            },
            renderStars(containerId, rating) {
                const stars = document.querySelectorAll('#' + containerId + ' .star');
                stars.forEach((star, i) => star.classList.toggle('active', i < rating));
            },
            async setRating(value) {
                const file = ModuleA.state.files.find(f => f.id === this.state.currentFileId);
                file.quality = value;
                await ModuleA.state.provider.updateUserMetadata(file.id, { quality: value });
                this.renderStars('quality-rating', value);
                Utils.showToast('Quality: ' + value + '/5');
            },
            async saveNotes() {
                const notes = document.getElementById('detail-notes').value;
                const file = ModuleA.state.files.find(f => f.id === this.state.currentFileId);
                file.notes = notes;
                await ModuleA.state.provider.updateUserMetadata(file.id, { notes });
                Utils.showToast('Notes saved');
            }
        };
        
        const ModuleE_Focus = {
            state: { isActive: false, currentIndex: 0 },
            init() {
                if (!CONFIG.FOCUS_MODULE) return;
                this.setupKeyboard();
                this.setupHubTap();
                document.getElementById('focus-fav').addEventListener('click', () => this.toggleFav());
            },
            enter() {
                this.state.isActive = true;
                this.state.currentIndex = ModuleB_Sort.state.currentIndex;
                document.getElementById('gesture-screen-a').hidden = true;
                document.getElementById('gesture-screen-b').hidden = false;
                document.querySelectorAll('.ui-button:not(.focus-mode-ui)').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.focus-mode-ui').forEach(el => el.style.display = 'block');
                document.querySelectorAll('.pill-counter').forEach(el => el.style.display = 'none');
                this.loadImage();
                this.updateUI();
            },
            exit() {
                this.state.isActive = false;
                document.getElementById('gesture-screen-a').hidden = false;
                document.getElementById('gesture-screen-b').hidden = true;
                document.querySelectorAll('.ui-button:not(.focus-mode-ui)').forEach(el => el.style.display = '');
                document.querySelectorAll('.focus-mode-ui').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.pill-counter.visible').forEach(el => el.style.display = '');
                ModuleB_Sort.state.currentIndex = this.state.currentIndex;
                ModuleB_Sort.loadImage(this.state.currentIndex);
            },
            loadImage() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                const file = files[this.state.currentIndex];
                if (!file) return;
                document.getElementById('center-image').src = ModuleB_Sort.getImageUrl(file);
            },
            updateUI() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                const file = files[this.state.currentIndex];
                if (!file) return;
                document.getElementById('focus-stack').textContent = file.stack || 'in';
                document.getElementById('focus-count').textContent = (this.state.currentIndex + 1) + '/' + files.length;
                document.getElementById('fav-icon').style.color = file.favorite ? '#fbbf24' : 'white';
            },
            setupKeyboard() {
                document.addEventListener('keydown', e => {
                    if (!this.state.isActive) return;
                    if (e.key === 'ArrowRight' || e.key === ' ') this.next();
                    else if (e.key === 'ArrowLeft' || e.key === 'Backspace') { e.preventDefault(); this.previous(); }
                    else if (e.key === 'f') this.toggleFav();
                    else if (e.key === 'Escape') this.exit();
                });
            },
            setupHubTap() {
                let lastTap = 0;
                document.getElementById('hub-b').addEventListener('click', () => {
                    const now = Date.now();
                    if (now - lastTap < 300) this.exit();
                    lastTap = now;
                });
                document.getElementById('half-left').addEventListener('click', () => this.previous());
                document.getElementById('half-right').addEventListener('click', () => this.next());
            },
            next() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                if (this.state.currentIndex < files.length - 1) {
                    this.state.currentIndex++;
                    this.loadImage();
                    this.updateUI();
                }
            },
            previous() {
                if (this.state.currentIndex > 0) {
                    this.state.currentIndex--;
                    this.loadImage();
                    this.updateUI();
                }
            },
            async toggleFav() {
                const files = ModuleA.getFilesInStack(ModuleA.state.currentStack);
                const file = files[this.state.currentIndex];
                file.favorite = !file.favorite;
                await ModuleA.state.provider.updateUserMetadata(file.id, { favorite: file.favorite });
                this.updateUI();
                Utils.showToast(file.favorite ? 'Favorited' : 'Unfavorited');
            }
        };
        
        // Override Framework.start to initialize modules
        Framework.start = function() {
            console.log('🚀 Framework starting with', ModuleA.state.files.length, 'files');
            document.getElementById('app-root').classList.remove('hidden');
            const screens = ['provider-screen', 'gdrive-auth-screen', 'onedrive-auth-screen', 
                           'gdrive-folder-screen', 'onedrive-folder-screen', 'loading-screen'];
            screens.forEach(id => document.getElementById(id).classList.add('hidden'));
            if (CONFIG.SORT_MODULE) ModuleB_Sort.init();
            if (CONFIG.GRID_MODULE) ModuleC_Grid.init();
            if (CONFIG.DETAIL_MODULE) ModuleD_Detail.init();
            if (CONFIG.FOCUS_MODULE) ModuleE_Focus.init();
            console.log('✅ All modules loaded');
        };
        
        document.addEventListener('DOMContentLoaded', () => {
            ModuleA.init();
        });
    </script>
</body>
</html>
