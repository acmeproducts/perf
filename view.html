<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Codex Recall</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f7f7fb;
      --bg-dark: #1a1d24;
      --panel: #ffffff;
      --panel-dark: #232734;
      --border: #d7d7e5;
      --border-dark: #34384a;
      --accent: #4361ee;
      --accent-dark: #7aa2ff;
      --danger: #d64550;
      --text: #1f2430;
      --text-muted: #596174;
      --text-invert: #f9fbff;
      font-family: "Inter", "Segoe UI", Helvetica, Arial, sans-serif;
      line-height: 1.5;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      background: linear-gradient(180deg, rgba(67,97,238,0.08), transparent 320px) var(--bg);
      color: var(--text);
    }

    @media (prefers-color-scheme: dark) {
      body {
        background: linear-gradient(180deg, rgba(122,162,255,0.16), transparent 320px) var(--bg-dark);
        color: var(--text-invert);
      }
    }

    header {
      padding: 24px clamp(20px, 4vw, 48px) 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
    }

    header h1 {
      margin: 0;
      font-size: clamp(1.4rem, 4vw, 2.1rem);
      letter-spacing: -0.03em;
    }

    header p {
      margin: 0;
      max-width: 520px;
      color: var(--text-muted);
      font-size: 0.95rem;
    }

    .container {
      display: grid;
      grid-template-columns: minmax(260px, 320px) 1fr;
      gap: 20px;
      padding: 0 clamp(20px, 4vw, 48px) 32px;
    }

    @media (max-width: 960px) {
      .container {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 32px rgba(20, 30, 60, 0.06);
    }

    @media (prefers-color-scheme: dark) {
      .panel {
        background: var(--panel-dark);
        border-color: var(--border-dark);
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
      }
    }

    .panel h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 14px;
    }

    label {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
    }

    input[type="text"],
    input[type="search"],
    textarea,
    select {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      font-size: 0.95rem;
      font-family: inherit;
      color: inherit;
      transition: border 0.2s ease, box-shadow 0.2s ease;
    }

    @media (prefers-color-scheme: dark) {
      input[type="text"],
      input[type="search"],
      textarea,
      select {
        background: rgba(35, 39, 52, 0.95);
        border-color: var(--border-dark);
      }
    }

    input[type="text"]:focus,
    input[type="search"]:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.22);
    }

    button {
      background: var(--accent);
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 0.95rem;
      color: white;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, filter 0.18s ease;
      font-weight: 600;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(67, 97, 238, 0.25);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .button-secondary {
      background: rgba(95, 107, 130, 0.16);
      color: inherit;
      border: 1px solid transparent;
    }

    .button-danger {
      background: var(--danger);
    }

    .token-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 18px;
    }

    .token-row span {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .status-bar {
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid rgba(67, 97, 238, 0.25);
      background: rgba(67, 97, 238, 0.08);
      margin-bottom: 18px;
      font-size: 0.9rem;
    }

    @media (prefers-color-scheme: dark) {
      .status-bar {
        background: rgba(122, 162, 255, 0.14);
        border-color: rgba(122, 162, 255, 0.25);
      }
    }

    .results-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .results-toolbar .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .request-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .request-card {
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      background: rgba(255, 255, 255, 0.92);
      display: grid;
      gap: 12px;
    }

    .request-header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: baseline;
    }

    .request-header h3 {
      margin: 0;
      font-size: 1.05rem;
    }

    .request-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .request-body {
      white-space: pre-wrap;
      background: rgba(67, 97, 238, 0.06);
      border-radius: 10px;
      padding: 12px;
      font-family: "SFMono-Regular", Consolas, "Liberation Mono", monospace;
      font-size: 0.85rem;
      overflow-x: auto;
    }

    .file-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .file-chip {
      background: rgba(95, 107, 130, 0.16);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.8rem;
    }

    .notes-area textarea {
      min-height: 80px;
      resize: vertical;
    }

    .tag-editor {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .tag-editor input {
      flex: 1;
      min-width: 160px;
    }

    .tag-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: rgba(67, 97, 238, 0.12);
      color: inherit;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.75rem;
    }

    .tag-pill button {
      background: transparent;
      border: none;
      color: inherit;
      padding: 0;
      font-size: 1rem;
      cursor: pointer;
    }

    .status-toggle {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }

    .status-toggle button {
      padding: 6px 14px;
      font-size: 0.8rem;
    }

    .request-card[data-status="exclude"] {
      border-color: rgba(214, 69, 80, 0.5);
      background: rgba(214, 69, 80, 0.08);
    }

    @media (prefers-color-scheme: dark) {
      input[type="text"], input[type="search"], textarea, select, .request-card {
        background: rgba(35, 39, 52, 0.85);
      }

      .file-chip {
        background: rgba(122, 162, 255, 0.16);
      }
    }

    dialog {
      border: none;
      border-radius: 16px;
      padding: 0;
      width: min(420px, 92vw);
    }

    dialog::backdrop {
      background: rgba(15, 18, 28, 0.55);
    }

    .modal-shell {
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      background: var(--panel);
    }

    @media (prefers-color-scheme: dark) {
      .modal-shell {
        background: var(--panel-dark);
      }
    }

    .modal-shell h2 {
      margin: 0;
      font-size: 1.2rem;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .empty-state {
      padding: 40px;
      border: 2px dashed rgba(95, 107, 130, 0.25);
      border-radius: 16px;
      text-align: center;
      color: var(--text-muted);
    }

    .loader {
      display: inline-block;
      width: 18px;
      height: 18px;
      border: 3px solid rgba(255, 255, 255, 0.6);
      border-top-color: rgba(255, 255, 255, 1);
      border-radius: 50%;
      animation: spin 0.75s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Codex Recall</h1>
      <p>Inventory merged Codex requests for any repository, inspect their prompts, map the files they touched, and curate a living checklist you can annotate or export.</p>
    </div>
    <div class="token-row">
      <span id="tokenStatus">Token: not set</span>
      <button id="setTokenBtn" class="button-secondary">Set token</button>
      <button id="forgetTokenBtn" class="button-secondary">Forget token</button>
    </div>
  </header>

  <div class="container">
    <section class="panel" id="controlPanel">
      <h2>Repository</h2>
      <div class="field">
        <label for="repoSelect">Repository</label>
        <select id="repoSelect" disabled>
          <option value="">Save a GitHub token to load repositories</option>
        </select>
      </div>
      <div class="field">
        <label for="branchSelect">Branch</label>
        <select id="branchSelect" disabled>
          <option value="">Select a repository first</option>
        </select>
      </div>
      <div class="field">
        <label for="branchFilterInput">Head branch filter (regex)</label>
        <input id="branchFilterInput" type="text" placeholder="Default: codex/" />
      </div>
      <div class="field">
        <label for="maxPrsInput">Maximum PRs to fetch</label>
        <input id="maxPrsInput" type="text" value="100" />
      </div>
      <div class="field">
        <label for="sinceInput">Only merged after (ISO date, optional)</label>
        <input id="sinceInput" type="text" placeholder="2024-01-01" />
      </div>
      <button id="loadBtn">Load merged requests</button>
      <div class="status-bar" id="statusBar" hidden></div>
      <div class="field">
        <label for="searchInput">Filter checklist</label>
        <input id="searchInput" type="search" placeholder="Search title, prompt, files" />
      </div>
      <div class="field">
        <label for="statusFilter">Status</label>
        <select id="statusFilter">
          <option value="all">All</option>
          <option value="include">Included</option>
          <option value="exclude">Excluded</option>
        </select>
      </div>
      <button id="exportBtn" class="button-secondary">Export checklist JSON</button>
      <button id="clearChecklistBtn" class="button-secondary">Clear local checklist copy</button>
    </section>

    <section class="panel" id="resultsPanel">
      <div class="results-toolbar">
        <div class="filters">
          <strong id="resultsCount">0 requests</strong>
          <span id="lastFetched"></span>
        </div>
        <div>
          <button id="refreshBtn" class="button-secondary">Refresh</button>
        </div>
      </div>
      <div id="results" class="request-list"></div>
      <div id="emptyState" class="empty-state">
        <p>Load a repository to see Codex merge requests. They will appear here with prompt text, affected files, and annotation controls.</p>
      </div>
    </section>
  </div>

  <dialog id="tokenDialog">
    <form method="dialog" class="modal-shell">
      <h2>Personal Access Token</h2>
      <p>Paste a GitHub token with <strong>repo</strong> scope. It stays in your browser’s localStorage and is only used for direct GitHub API calls from this page.</p>
      <div class="field">
        <label for="tokenInput">Token</label>
        <input id="tokenInput" type="text" autocomplete="off" required />
      </div>
      <div class="modal-actions">
        <button value="cancel" type="button" class="button-secondary">Cancel</button>
        <button value="confirm" type="submit">Save token</button>
      </div>
    </form>
  </dialog>

  <script>
    const TOKEN_KEY = 'codexrecall.pat';
    const SETTINGS_KEY = 'codexrecall.settings';

    const repoSelect = document.getElementById('repoSelect');
    const branchSelect = document.getElementById('branchSelect');
    const branchFilterInput = document.getElementById('branchFilterInput');
    const sinceInput = document.getElementById('sinceInput');
    const maxPrsInput = document.getElementById('maxPrsInput');
    const loadBtn = document.getElementById('loadBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const exportBtn = document.getElementById('exportBtn');
    const clearChecklistBtn = document.getElementById('clearChecklistBtn');
    const statusBar = document.getElementById('statusBar');
    const resultsEl = document.getElementById('results');
    const emptyStateEl = document.getElementById('emptyState');
    const resultsCountEl = document.getElementById('resultsCount');
    const lastFetchedEl = document.getElementById('lastFetched');
    const searchInput = document.getElementById('searchInput');
    const statusFilter = document.getElementById('statusFilter');
    const tokenStatus = document.getElementById('tokenStatus');
    const setTokenBtn = document.getElementById('setTokenBtn');
    const forgetTokenBtn = document.getElementById('forgetTokenBtn');
    const tokenDialog = document.getElementById('tokenDialog');
    const tokenInput = document.getElementById('tokenInput');

    const state = {
      entries: [],
      filteredEntries: [],
      owner: '',
      repo: '',
      repos: [],
      branches: [],
      selectedRepo: '',
      selectedBranch: '',
      pendingRepoSelection: '',
      pendingBranchSelection: '',
      isLoading: false,
      isFetchingRepos: false,
      isFetchingBranches: false,
      token: null
    };

    function loadSettings() {
      const storedSettings = localStorage.getItem(SETTINGS_KEY);
      let normalizedSettings = {
        repoFullName: '',
        branch: '',
        branchFilter: '',
        since: '',
        maxPrs: '100'
      };
      let shouldPersistNormalized = false;
      if (storedSettings) {
        try {
          const parsed = JSON.parse(storedSettings) || {};
          const repoFullName = parsed.repoFullName || (parsed.owner && parsed.repo ? `${parsed.owner}/${parsed.repo}` : '');
          if (repoFullName && repoFullName !== parsed.repoFullName) {
            shouldPersistNormalized = true;
          }
          normalizedSettings = {
            repoFullName,
            branch: parsed.branch || '',
            branchFilter: parsed.branchFilter || '',
            since: parsed.since || '',
            maxPrs: parsed.maxPrs || '100'
          };
        } catch (err) {
          console.warn('Failed to parse settings', err);
        }
      }
      branchFilterInput.value = normalizedSettings.branchFilter || '';
      branchFilterInput.dataset.mode = branchFilterInput.value ? 'manual' : 'auto';
      sinceInput.value = normalizedSettings.since || '';
      maxPrsInput.value = normalizedSettings.maxPrs || '100';
      state.selectedRepo = normalizedSettings.repoFullName || '';
      state.pendingRepoSelection = state.selectedRepo;
      state.selectedBranch = normalizedSettings.branch || '';
      state.pendingBranchSelection = state.selectedBranch;
      if (shouldPersistNormalized && normalizedSettings) {
        localStorage.setItem(SETTINGS_KEY, JSON.stringify(normalizedSettings));
      }
      const storedToken = localStorage.getItem(TOKEN_KEY);
      if (storedToken) {
        state.token = storedToken;
      }
      updateTokenStatus();
      if (state.token) {
        hydrateRepositories();
      } else {
        disableRepoControls('Save a GitHub token to load repositories');
      }
    }

    function persistSettings() {
      const repoFullName = state.selectedRepo || repoSelect.value || '';
      let owner = '';
      let repo = '';
      if (repoFullName.includes('/')) {
        [owner, repo] = repoFullName.split('/', 2);
      }
      const maxPrsValue = (maxPrsInput.value || '').trim() || '100';
      maxPrsInput.value = maxPrsValue;
      const payload = {
        repoFullName,
        branch: state.selectedBranch || branchSelect.value || '',
        branchFilter: branchFilterInput.value.trim(),
        since: sinceInput.value.trim(),
        maxPrs: maxPrsValue,
        owner,
        repo
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(payload));
    }

    function updateTokenStatus() {
      if (state.token) {
        tokenStatus.textContent = 'Token: saved locally';
        forgetTokenBtn.disabled = false;
      } else {
        tokenStatus.textContent = 'Token: not set';
        forgetTokenBtn.disabled = true;
      }
    }

    setTokenBtn.addEventListener('click', () => {
      tokenInput.value = '';
      tokenDialog.showModal();
      setTimeout(() => tokenInput.focus(), 10);
    });

    tokenDialog.addEventListener('close', () => {
      if (tokenDialog.returnValue === 'confirm' && tokenInput.value.trim()) {
        const token = tokenInput.value.trim();
        localStorage.setItem(TOKEN_KEY, token);
        state.token = token;
        updateTokenStatus();
        hydrateRepositories();
      }
    });

    forgetTokenBtn.addEventListener('click', () => {
      if (!state.token) return;
      if (confirm('Remove the stored token?')) {
        localStorage.removeItem(TOKEN_KEY);
        state.token = null;
        updateTokenStatus();
        disableRepoControls('Save a GitHub token to load repositories');
      }
    });

    loadBtn.addEventListener('click', () => {
      persistSettings();
      loadRequests();
    });

    refreshBtn.addEventListener('click', () => {
      loadRequests({force: true});
    });

    repoSelect.addEventListener('change', () => {
      state.pendingBranchSelection = '';
      state.selectedBranch = '';
      selectRepository(repoSelect.value, { userInitiated: true });
    });

    branchSelect.addEventListener('change', () => {
      applyBranchSelection(branchSelect.value, { userInitiated: true });
    });

    searchInput.addEventListener('input', () => {
      applyFilters();
      render();
    });

    statusFilter.addEventListener('change', () => {
      applyFilters();
      render();
    });

    branchFilterInput.addEventListener('input', () => {
      branchFilterInput.dataset.mode = 'manual';
    });

    branchFilterInput.addEventListener('change', () => {
      persistSettings();
    });

    sinceInput.addEventListener('change', () => {
      persistSettings();
    });

    maxPrsInput.addEventListener('change', () => {
      persistSettings();
    });

    exportBtn.addEventListener('click', () => {
      if (!state.entries.length) {
        alert('No checklist entries to export yet.');
        return;
      }
      const payload = {
        owner: state.owner,
        repo: state.repo,
        exportedAt: new Date().toISOString(),
        entries: state.entries
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `codexrecall-${state.owner}-${state.repo}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    });

    clearChecklistBtn.addEventListener('click', () => {
      if (!state.owner || !state.repo) {
        alert('Load a repository first.');
        return;
      }
      if (confirm('Clear the locally cached checklist for this repository?')) {
        localStorage.removeItem(checklistKey());
        state.entries = [];
        applyFilters();
        render();
      }
    });

    function checklistKey() {
      return `codexrecall.checklist.${state.owner}.${state.repo}`;
    }

    function setStatus(message, { tone = 'info', spinner = false } = {}) {
      if (!message) {
        statusBar.hidden = true;
        statusBar.textContent = '';
        return;
      }
      statusBar.hidden = false;
      statusBar.textContent = message;
      statusBar.dataset.tone = tone;
      if (spinner) {
        statusBar.innerHTML = `<span class="loader"></span> <span>${message}</span>`;
      }
    }

    function setStatusIdle(message, options) {
      if (state.isLoading) return;
      setStatus(message, options);
    }

    function setButtonsDisabled(disabled) {
      loadBtn.disabled = disabled;
      refreshBtn.disabled = disabled;
    }

    function disableRepoControls(message) {
      repoSelect.innerHTML = '';
      const repoOption = document.createElement('option');
      repoOption.value = '';
      repoOption.textContent = message;
      repoSelect.appendChild(repoOption);
      repoSelect.disabled = true;
      branchSelect.innerHTML = '';
      const branchOption = document.createElement('option');
      branchOption.value = '';
      branchOption.textContent = 'Select a repository first';
      branchSelect.appendChild(branchOption);
      branchSelect.disabled = true;
      state.repos = [];
      state.branches = [];
      state.owner = '';
      state.repo = '';
      state.selectedRepo = '';
      state.selectedBranch = '';
    }

    async function hydrateRepositories() {
      if (!state.token) {
        disableRepoControls('Save a GitHub token to load repositories');
        return;
      }
      if (state.isFetchingRepos) return;
      state.isFetchingRepos = true;
      repoSelect.disabled = true;
      repoSelect.innerHTML = '';
      const loadingOption = document.createElement('option');
      loadingOption.value = '';
      loadingOption.textContent = 'Loading repositories…';
      repoSelect.appendChild(loadingOption);
      setStatusIdle('Loading repositories…', { spinner: true });
      let error = null;
      try {
        const repos = await fetchUserRepositories();
        state.repos = repos.slice().sort((a, b) => {
          const aDate = Date.parse(a.pushed_at || 0) || 0;
          const bDate = Date.parse(b.pushed_at || 0) || 0;
          return bDate - aDate;
        });
        populateRepoSelect(state.repos);
      } catch (err) {
        error = err;
        console.error('Failed to load repositories', err);
        disableRepoControls('Unable to load repositories');
        setStatusIdle(`Error loading repositories: ${err.message}`, { tone: 'error' });
      } finally {
        state.isFetchingRepos = false;
        if (!error) {
          setStatusIdle('');
        }
      }
    }

    function populateRepoSelect(repos) {
      repoSelect.innerHTML = '';
      if (!repos.length) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No repositories found';
        repoSelect.appendChild(option);
        repoSelect.disabled = true;
        disableBranchControls('Select a repository first');
        setStatusIdle('No repositories available for this token.', { tone: 'error' });
        return;
      }
      for (const repo of repos) {
        const option = document.createElement('option');
        option.value = repo.full_name;
        option.textContent = repo.full_name;
        repoSelect.appendChild(option);
      }
      repoSelect.disabled = false;
      const desiredRepo = state.pendingRepoSelection && repos.some(repo => repo.full_name === state.pendingRepoSelection)
        ? state.pendingRepoSelection
        : (state.selectedRepo && repos.some(repo => repo.full_name === state.selectedRepo)
          ? state.selectedRepo
          : repos[0].full_name);
      state.pendingRepoSelection = '';
      if (desiredRepo) {
        selectRepository(desiredRepo, { userInitiated: false, fromHydration: true });
      } else {
        disableBranchControls('Select a repository first');
      }
    }

    function disableBranchControls(message) {
      branchSelect.innerHTML = '';
      const option = document.createElement('option');
      option.value = '';
      option.textContent = message;
      branchSelect.appendChild(option);
      branchSelect.disabled = true;
      state.branches = [];
      state.selectedBranch = '';
    }

    function selectRepository(fullName, { userInitiated = false, fromHydration = false } = {}) {
      if (!fullName) {
        disableBranchControls('Select a repository first');
        state.selectedRepo = '';
        state.owner = '';
        state.repo = '';
        persistSettings();
        return;
      }
      if (repoSelect.value !== fullName) {
        repoSelect.value = fullName;
      }
      if (fullName === state.selectedRepo && !userInitiated && !fromHydration) {
        return;
      }
      state.selectedRepo = fullName;
      if (!fullName.includes('/')) {
        console.warn('Invalid repository selection', fullName);
        return;
      }
      const [owner, repo] = fullName.split('/', 2);
      state.owner = owner;
      state.repo = repo;
      persistSettings();
      hydrateBranches({ owner, repo, fromHydration, userInitiated });
    }

    async function hydrateBranches({ owner, repo, fromHydration = false, userInitiated = false } = {}) {
      if (!owner || !repo) {
        disableBranchControls('Select a repository first');
        return;
      }
      state.isFetchingBranches = true;
      branchSelect.disabled = true;
      branchSelect.innerHTML = '';
      const loadingOption = document.createElement('option');
      loadingOption.value = '';
      loadingOption.textContent = 'Loading branches…';
      branchSelect.appendChild(loadingOption);
      setStatusIdle('Loading branches…', { spinner: true });
      let error = null;
      try {
        const branches = await fetchRepositoryBranches(owner, repo);
        state.branches = branches;
        populateBranchSelect(branches, { fromHydration, userInitiated });
      } catch (err) {
        error = err;
        console.error('Failed to load branches', err);
        disableBranchControls('Unable to load branches');
        setStatusIdle(`Error loading branches: ${err.message}`, { tone: 'error' });
      } finally {
        state.isFetchingBranches = false;
        if (!error) {
          setStatusIdle('');
        }
      }
    }

    function populateBranchSelect(branches, { fromHydration = false, userInitiated = false } = {}) {
      branchSelect.innerHTML = '';
      if (!branches.length) {
        disableBranchControls('No branches available');
        persistSettings();
        return;
      }
      for (const branch of branches) {
        const option = document.createElement('option');
        option.value = branch.name;
        const parts = [branch.name];
        if (branch.committedDate) {
          try {
            parts.push(`updated ${new Date(branch.committedDate).toLocaleString()}`);
          } catch (err) {
            parts.push(`updated ${branch.committedDate}`);
          }
        }
        option.textContent = parts.join(' · ');
        branchSelect.appendChild(option);
      }
      branchSelect.disabled = false;
      const desiredBranch = fromHydration
        ? (state.pendingBranchSelection || state.selectedBranch)
        : state.selectedBranch;
      const availableNames = branches.map(branch => branch.name);
      const fallbackBranch = branches[0].name;
      const branchToSelect = desiredBranch && availableNames.includes(desiredBranch)
        ? desiredBranch
        : fallbackBranch;
      state.pendingBranchSelection = '';
      applyBranchSelection(branchToSelect, { fromHydration, userInitiated });
    }

    function applyBranchSelection(branchName, { fromHydration = false, userInitiated = false } = {}) {
      const value = branchName || '';
      if (branchSelect.value !== value) {
        branchSelect.value = value;
      }
      state.selectedBranch = value;
      if (value) {
        applyAutoBranchFilter(value, { force: userInitiated });
      }
      persistSettings();
    }

    function applyAutoBranchFilter(branchName, { force = false } = {}) {
      if (!branchName) return;
      const mode = branchFilterInput.dataset.mode || 'auto';
      if (mode === 'manual' && !force) {
        return;
      }
      const regex = `^${escapeRegexLiteral(branchName)}$`;
      branchFilterInput.value = regex;
      branchFilterInput.dataset.mode = 'auto';
    }

    function escapeRegexLiteral(str) {
      return str.replace(/[-\/\^$*+?.()|[\]{}]/g, '\$&');
    }


    async function loadRequests({ force = false } = {}) {
      if (!state.token) {
        alert('Save a GitHub token first.');
        return;
      }
      const repoFullName = state.selectedRepo || repoSelect.value;
      if (!repoFullName) {
        alert('Select a repository first.');
        return;
      }
      if (!repoFullName.includes('/')) {
        alert('Repository selection is invalid.');
        return;
      }
      const [owner, repo] = repoFullName.split('/', 2);
      state.owner = owner;
      state.repo = repo;
      const cachedChecklist = !force ? loadCachedChecklist() : null;
      if (cachedChecklist && cachedChecklist.entries) {
        state.entries = cachedChecklist.entries;
        applyFilters();
        render();
      }
      try {
        state.isLoading = true;
        setButtonsDisabled(true);
        setStatus('Fetching merged pull requests…', { spinner: true });
        const filterText = branchFilterInput.value.trim();
        let branchRegex;
        if (filterText) {
          try {
            branchRegex = new RegExp(filterText, 'i');
          } catch (err) {
            throw new Error(`Invalid branch regex: ${err.message}`);
          }
        } else {
          branchRegex = /codex\//i;
        }
        const maxPrs = parseInt(maxPrsInput.value.trim(), 10) || 100;
        const since = sinceInput.value.trim();
        const mergedAfter = since ? Date.parse(since) : null;
        const prs = await fetchMergedPullRequests({ owner, repo, maxPrs });
        const filteredPrs = prs.filter(pr => branchRegex.test(pr.headRefName));
        const finalPrs = mergedAfter ? filteredPrs.filter(pr => Date.parse(pr.mergedAt) >= mergedAfter) : filteredPrs;
        setStatus(`Found ${finalPrs.length} merged PRs. Fetching file changes…`, { spinner: true });
        const entries = await enrichPullRequests(finalPrs, { owner, repo });
        mergeWithCached(entries);
        state.isLoading = false;
        setStatus(`Loaded ${entries.length} request${entries.length === 1 ? '' : 's'}.`);
        lastFetchedEl.textContent = `Last fetched ${new Date().toLocaleString()}`;
        saveChecklist();
        applyFilters();
        render();
      } catch (error) {
        console.error(error);
        state.isLoading = false;
        setStatus(`Error: ${error.message}`, { tone: 'error' });
      } finally {
        setButtonsDisabled(false);
      }
    }

    function loadCachedChecklist() {
      try {
        const raw = localStorage.getItem(checklistKey());
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        console.warn('Failed to parse cached checklist', err);
        return null;
      }
    }

    function saveChecklist() {
      const payload = {
        savedAt: new Date().toISOString(),
        entries: state.entries
      };
      localStorage.setItem(checklistKey(), JSON.stringify(payload));
    }

    function mergeWithCached(newEntries) {
      const cache = loadCachedChecklist();
      if (!cache || !cache.entries) {
        state.entries = newEntries;
        return;
      }
      const map = new Map(cache.entries.map(entry => [entry.id, entry]));
      const merged = newEntries.map(entry => {
        const cached = map.get(entry.id);
        if (!cached) return entry;
        return {
          ...entry,
          status: cached.status || 'include',
          notes: cached.notes || '',
          tags: cached.tags || []
        };
      });
      state.entries = merged;
    }

    async function fetchMergedPullRequests({ owner, repo, maxPrs }) {
      const perPage = 50;
      const collected = [];
      let cursor = null;
      while (collected.length < maxPrs) {
        const remaining = maxPrs - collected.length;
        const batchSize = Math.min(perPage, remaining);
        const result = await githubGraphQL({
          query: `query($owner:String!, $repo:String!, $cursor:String, $pageSize:Int!){
            repository(owner:$owner, name:$repo){
              pullRequests(first:$pageSize, after:$cursor, states:MERGED, orderBy:{field:UPDATED_AT, direction:DESC}){
                pageInfo{ hasNextPage endCursor }
                nodes{
                  number
                  title
                  mergedAt
                  createdAt
                  headRefName
                  url
                  author{ login }
                  body
                }
              }
            }
          }`,
          variables: { owner, repo, cursor, pageSize: batchSize }
        });
        const nodes = result?.repository?.pullRequests?.nodes || [];
        collected.push(...nodes);
        const pageInfo = result?.repository?.pullRequests?.pageInfo;
        if (!pageInfo?.hasNextPage) break;
        cursor = pageInfo.endCursor;
      }
      return collected;
    }

    async function enrichPullRequests(prs, { owner, repo }) {
      const entries = [];
      for (const pr of prs) {
        const files = await fetchPullRequestFiles(owner, repo, pr.number);
        entries.push({
          id: `pr-${pr.number}`,
          type: 'PR',
          number: pr.number,
          title: pr.title,
          mergedAt: pr.mergedAt,
          createdAt: pr.createdAt,
          headRefName: pr.headRefName,
          url: pr.url,
          author: pr.author?.login || 'unknown',
          prompt: pr.body || '',
          files: files.map(file => ({
            filename: file.filename,
            status: file.status,
            additions: file.additions,
            deletions: file.deletions,
            changes: file.changes,
            blobUrl: file.blob_url,
            rawUrl: file.raw_url
          })),
          status: 'include',
          notes: '',
          tags: []
        });
      }
      return entries;
    }

    async function fetchPullRequestFiles(owner, repo, number) {
      const results = [];
      let page = 1;
      while (true) {
        const response = await githubRest(`/repos/${owner}/${repo}/pulls/${number}/files?per_page=100&page=${page}`);
        if (!Array.isArray(response) || !response.length) break;
        results.push(...response);
        if (response.length < 100) break;
        page += 1;
      }
      return results;
    }

    async function githubGraphQL({ query, variables }) {
      const res = await fetch('https://api.github.com/graphql', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${state.token}`
        },
        body: JSON.stringify({ query, variables })
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GraphQL error ${res.status}: ${text}`);
      }
      const json = await res.json();
      if (json.errors) {
        throw new Error(json.errors.map(e => e.message).join('\n'));
      }
      return json.data;
    }

    async function githubRest(path) {
      const res = await fetch(`https://api.github.com${path}`, {
        headers: {
          'Authorization': `Bearer ${state.token}`,
          'Accept': 'application/vnd.github+json'
        }
      });
      if (!res.ok) {
        const text = await res.text();
        throw new Error(`GitHub API error ${res.status}: ${text}`);
      }
      return res.json();
    }

    async function fetchUserRepositories() {
      const results = [];
      let page = 1;
      while (true) {
        const batch = await githubRest(`/user/repos?sort=pushed&per_page=100&page=${page}`);
        if (!Array.isArray(batch) || !batch.length) break;
        results.push(...batch);
        if (batch.length < 100) break;
        page += 1;
      }
      return results;
    }

    async function fetchRepositoryBranches(owner, repo) {
      const branches = [];
      let cursor = null;
      while (true) {
        const data = await githubGraphQL({
          query: `query($owner:String!, $repo:String!, $cursor:String){
            repository(owner:$owner, name:$repo){
              refs(refPrefix:"refs/heads/", first:100, after:$cursor, orderBy:{field:ALPHABETICAL, direction:ASC}){
                nodes{
                  name
                  target{
                    __typename
                    ... on Commit{
                      pushedDate
                      committedDate
                    }
                  }
                }
                pageInfo{ hasNextPage endCursor }
              }
            }
          }`,
          variables: { owner, repo, cursor }
        });
        const refs = data?.repository?.refs;
        if (!refs) break;
        const nodes = refs.nodes || [];
        for (const node of nodes) {
          const target = node.target || {};
          const committedDate = target.pushedDate || target.committedDate || null;
          branches.push({
            name: node.name,
            committedDate
          });
        }
        if (!refs.pageInfo?.hasNextPage) break;
        cursor = refs.pageInfo.endCursor;
      }
      branches.sort((a, b) => {
        const aTime = Date.parse(a.committedDate || 0) || 0;
        const bTime = Date.parse(b.committedDate || 0) || 0;
        return bTime - aTime;
      });
      return branches;
    }

    function applyFilters() {
      const query = searchInput.value.trim().toLowerCase();
      const statusValue = statusFilter.value;
      const filtered = state.entries.filter(entry => {
        if (statusValue !== 'all' && entry.status !== statusValue) return false;
        if (!query) return true;
        const haystack = [
          entry.title,
          entry.prompt,
          entry.headRefName,
          entry.files.map(f => f.filename).join(' '),
          entry.tags?.join(' ')
        ].join(' ').toLowerCase();
        return haystack.includes(query);
      });
      state.filteredEntries = filtered;
    }

    function render() {
      resultsEl.innerHTML = '';
      if (!state.filteredEntries.length) {
        resultsCountEl.textContent = '0 requests';
        emptyStateEl.style.display = 'block';
        return;
      }
      emptyStateEl.style.display = 'none';
      resultsCountEl.textContent = `${state.filteredEntries.length} request${state.filteredEntries.length === 1 ? '' : 's'}`;
      for (const entry of state.filteredEntries) {
        const card = document.createElement('article');
        card.className = 'request-card';
        card.dataset.status = entry.status;
        card.innerHTML = `
          <div class="request-header">
            <h3>#${entry.number} · ${escapeHtml(entry.title)}</h3>
            <div class="request-meta">
              <span>${new Date(entry.mergedAt).toLocaleString()}</span>
              <span>${escapeHtml(entry.headRefName)}</span>
              <a href="${entry.url}" target="_blank" rel="noopener">View PR ↗</a>
            </div>
          </div>
          <div class="request-body">${escapeHtml(entry.prompt || '(no prompt provided)')}</div>
          <div class="file-list">${entry.files.map(file => `<span class="file-chip" title="Δ ${file.changes} (${file.status})">${escapeHtml(file.filename)}</span>`).join('')}</div>
          <div class="status-toggle">
            <span>Status:</span>
            <button data-action="set-status" data-value="include" ${entry.status === 'include' ? 'disabled' : ''}>Include</button>
            <button data-action="set-status" data-value="exclude" class="button-secondary" ${entry.status === 'exclude' ? 'disabled' : ''}>Exclude</button>
          </div>
          <div class="tag-editor">
            <div class="existing-tags">${renderTags(entry)}</div>
            <input type="text" placeholder="Add tag and press Enter" data-action="add-tag" />
          </div>
          <div class="notes-area">
            <label>Notes</label>
            <textarea data-action="update-notes" placeholder="Add checklist notes…">${escapeHtml(entry.notes || '')}</textarea>
          </div>
        `;
        card.querySelectorAll('button[data-action="set-status"]').forEach(btn => {
          btn.addEventListener('click', () => {
            const value = btn.dataset.value;
            updateEntry(entry.id, { status: value });
            applyFilters();
            render();
          });
        });
        const tagInput = card.querySelector('input[data-action="add-tag"]');
        tagInput.addEventListener('keydown', event => {
          if (event.key === 'Enter' && tagInput.value.trim()) {
            event.preventDefault();
            const tag = tagInput.value.trim();
            addTag(entry.id, tag);
            tagInput.value = '';
            applyFilters();
            render();
          }
        });
        card.querySelectorAll('.tag-pill button').forEach(btn => {
          btn.addEventListener('click', () => {
            const tag = btn.dataset.tag;
            removeTag(entry.id, tag);
            applyFilters();
            render();
          });
        });
        const notesArea = card.querySelector('textarea[data-action="update-notes"]');
        notesArea.addEventListener('change', () => {
          updateEntry(entry.id, { notes: notesArea.value });
        });
        resultsEl.appendChild(card);
      }
    }

    function renderTags(entry) {
      if (!entry.tags || !entry.tags.length) return '<span class="tag-pill" style="opacity:0.6;">No tags</span>';
      return entry.tags.map(tag => `<span class="tag-pill">${escapeHtml(tag)} <button data-tag="${escapeHtml(tag)}" title="Remove">×</button></span>`).join('');
    }

    function updateEntry(id, patch) {
      const index = state.entries.findIndex(entry => entry.id === id);
      if (index === -1) return;
      state.entries[index] = { ...state.entries[index], ...patch };
      saveChecklist();
    }

    function addTag(id, tag) {
      const entry = state.entries.find(e => e.id === id);
      if (!entry) return;
      entry.tags = Array.from(new Set([...(entry.tags || []), tag]));
      saveChecklist();
    }

    function removeTag(id, tag) {
      const entry = state.entries.find(e => e.id === id);
      if (!entry) return;
      entry.tags = (entry.tags || []).filter(t => t !== tag);
      saveChecklist();
    }

    function escapeHtml(str) {
      return (str || '').replace(/[&<>"']/g, ch => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      }[ch]));
    }

    loadSettings();
    applyFilters();
    render();
  </script>
</body>
</html>
