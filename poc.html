<!-- Orbital8-Goji-2025-09-25T04:38:34Z orbital sync pipeline + diagnostics modal refresh -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no, maximum-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Orbital8 Goji ‚Äì Sync POC</title>
    <script src="https://alcdn.msauth.net/browser/2.28.1/js/msal-browser.min.js"></script>
    <style>
        :root {
            --accent: #f59e0b;
            --accent-dark: #d97706;
            --glass: rgba(255, 255, 255, 0.08);
            --border: rgba(255, 255, 255, 0.25);
            --border-strong: rgba(255, 255, 255, 0.45);
            --dark-gradient: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            --surface: rgba(17, 24, 39, 0.8);
            --text-light: rgba(255, 255, 255, 0.86);
            --text-muted: rgba(255, 255, 255, 0.55);
            --success: #10b981;
            --danger: #ef4444;
            --modal-bg: rgba(15, 23, 42, 0.88);
            --shadow-strong: 0 20px 40px rgba(15, 23, 42, 0.45);
        }

        *, *::before, *::after { box-sizing: border-box; }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }

        body { background: var(--dark-gradient); }

        .screen {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--dark-gradient);
            padding: 32px;
            z-index: 1000;
        }

        .screen.hidden { display: none; }

        .card {
            width: min(520px, 92vw);
            padding: 48px 40px;
            border-radius: 28px;
            border: 1px solid var(--border);
            background: var(--glass);
            backdrop-filter: blur(24px);
            text-align: center;
            box-shadow: var(--shadow-strong);
        }

        .title {
            font-size: 26px;
            font-weight: 600;
            margin-bottom: 12px;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.75);
        }

        .subtitle {
            font-size: 15px;
            line-height: 1.6;
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        .provider-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            border-radius: 18px;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.28);
            color: white;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 16px;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .provider-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(245, 158, 11, 0.32);
            border-color: var(--accent);
        }

        .provider-button span.icon {
            display: inline-flex;
            width: 36px;
            height: 36px;
            border-radius: 12px;
            background: rgba(17, 24, 39, 0.6);
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .input, .notes-textarea, .tag-input, .select {
            width: 100%;
            padding: 14px 18px;
            border-radius: 14px;
            border: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.25);
            color: white;
            font-size: 15px;
            margin-bottom: 16px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            backdrop-filter: blur(12px);
        }

        .input:focus, .notes-textarea:focus, .tag-input:focus, .select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
        }

        .notes-textarea {
            min-height: 140px;
            resize: vertical;
            color: #111827;
            background: rgba(255, 255, 255, 0.92);
        }

        .button, .footer-button {
            width: 100%;
            padding: 16px 22px;
            border-radius: 16px;
            border: none;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            color: white;
            background: linear-gradient(45deg, var(--accent), var(--accent-dark));
            box-shadow: 0 14px 24px rgba(245, 158, 11, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            margin-bottom: 16px;
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        .button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 18px 32px rgba(245, 158, 11, 0.45);
        }

        .button.secondary {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.24);
            color: rgba(255, 255, 255, 0.82);
            box-shadow: none;
        }

        .button.secondary:hover:not(:disabled) { border-color: rgba(255, 255, 255, 0.45); }

        .folder-list {
            max-height: 320px;
            overflow-y: auto;
            margin-bottom: 24px;
            padding-right: 6px;
        }

        .folder-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 14px;
            color: white;
            margin-bottom: 10px;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }

        .folder-item:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
        }

        .folder-name { font-weight: 600; }
        .folder-meta { font-size: 13px; color: var(--text-muted); }

        .app-container {
            position: relative;
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            background: var(--dark-gradient);
            color: var(--text-light);
            overflow: hidden;
        }

        .app-container.hidden { display: none; }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(16px);
            z-index: 10;
        }

        .app-header .left, .app-header .right {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pill {
            display: inline-flex;
            align-items: center;
            padding: 6px 14px;
            border-radius: 9999px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.28);
            font-size: 13px;
            font-weight: 500;
        }

        .main-content {
            display: grid;
            grid-template-columns: minmax(0, 1fr) 380px;
            gap: 24px;
            padding: 24px;
            flex: 1;
            overflow: hidden;
        }

        .main-content .viewer-area {
            background: rgba(0, 0, 0, 0.35);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .main-content .viewer-area .placeholder {
            text-align: center;
            color: var(--text-muted);
            font-size: 18px;
        }

        .metadata-panel {
            background: rgba(255, 255, 255, 0.94);
            color: #111827;
            border-radius: 24px;
            padding: 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 24px 32px rgba(15, 23, 42, 0.45);
        }

        .metadata-panel h2 {
            margin: 0 0 12px 0;
            font-size: 20px;
            color: #111827;
        }

        .metadata-panel .field-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }

        .metadata-panel label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #6b7280;
            font-weight: 600;
        }

        .metadata-panel .input,
        .metadata-panel .notes-textarea {
            background: rgba(249, 250, 251, 0.95);
            color: #111827;
            border: 1px solid #d1d5db;
        }

        .metadata-panel .input:focus,
        .metadata-panel .notes-textarea:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .metadata-panel .pill-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .metadata-panel .pill-row .pill {
            background: rgba(59, 130, 246, 0.1);
            color: #1f2937;
            border-color: rgba(59, 130, 246, 0.2);
        }

        .metadata-panel .actions { margin-top: auto; display: grid; gap: 12px; }
        .metadata-panel .actions .button { margin-bottom: 0; }

        .status-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 999px;
            padding: 12px 22px;
            font-size: 14px;
            box-shadow: 0 12px 32px rgba(15, 23, 42, 0.4);
            display: none;
            z-index: 2000;
        }

        .status-bar.show { display: inline-flex; align-items: center; gap: 10px; }
        .status-bar.success { color: var(--success); }
        .status-bar.error { color: var(--danger); }

        .footer {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.45);
            border-top: 1px solid rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(12px);
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
        }

        .footer button {
            width: auto;
            padding: 10px 16px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.35);
            background: rgba(255, 255, 255, 0.12);
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: border-color 0.2s ease, transform 0.2s ease;
        }

        .footer button:hover {
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .diagnostics-modal {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.84);
            backdrop-filter: blur(18px);
            display: none;
            align-items: flex-end;
            justify-content: center;
            padding: 32px 24px;
            z-index: 3000;
        }

        .diagnostics-modal.active { display: flex; }

        .diagnostics-window {
            width: min(960px, 100%);
            max-height: 80vh;
            background: rgba(12, 18, 31, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 22px 22px 6px 6px;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.45);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .diagnostics-header {
            padding: 18px 22px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        }

        .diagnostics-header h3 {
            margin: 0;
            font-size: 16px;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.8);
        }

        .diagnostics-actions { display: flex; gap: 8px; }
        .diagnostics-actions button {
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.24);
            background: rgba(255, 255, 255, 0.12);
            color: white;
            cursor: pointer;
            font-weight: 500;
        }

        .diagnostics-body {
            flex: 1;
            padding: 18px 22px;
            overflow-y: auto;
            background: rgba(8, 12, 22, 0.96);
        }

        .diagnostics-body pre {
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
            font-family: 'SFMono-Regular', 'Menlo', monospace;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.85);
        }

        .diagnostics-body.diagnostics-empty { color: rgba(255, 255, 255, 0.55); }

        @media (max-width: 960px) {
            .main-content { grid-template-columns: 1fr; }
            .metadata-panel { order: -1; margin-bottom: 18px; }
            .viewer-area { min-height: 320px; }
        }
    </style>
</head>
<body>
    <div id="provider-screen" class="screen">
        <div class="card">
            <div class="title">Connect a storage provider</div>
            <div class="subtitle">One-tap login keeps your existing caches; this build swaps in the v4 sync engine under the hood.</div>
            <button data-provider="onedrive" class="provider-button">
                <span class="icon">‚òÅÔ∏è</span>
                <span>Sign in with Microsoft OneDrive</span>
            </button>
            <button data-provider="gdrive" class="provider-button">
                <span class="icon">üü¢</span>
                <span>Sign in with Google Drive</span>
            </button>
            <div id="provider-status" class="subtitle"></div>
        </div>
    </div>

    <div id="auth-screen" class="screen hidden">
        <div class="card">
            <div class="title">Authorizing‚Ä¶</div>
            <div class="subtitle">Hang tight while we refresh access tokens and validate the Orbital8 workspace.</div>
            <div id="auth-status" class="subtitle"></div>
        </div>
    </div>

    <div id="folder-screen" class="screen hidden">
        <div class="card">
            <div class="title">Select a Folder</div>
            <div class="subtitle">Your caches stay intact; we're layering the new sync engine underneath. Choose a folder to load triage state.</div>
            <div class="folder-list" id="folder-list"></div>
            <button id="folder-refresh" class="button secondary">Refresh</button>
            <button id="folder-back" class="button secondary">Back</button>
        </div>
    </div>

    <div id="loading-screen" class="screen hidden">
        <div class="card">
            <div class="title">Preparing Workspace</div>
            <div class="subtitle">Indexing metadata and priming caches‚Ä¶</div>
            <div class="loading-progress" style="width: 100%; background: rgba(255, 255, 255, 0.08); border-radius: 999px; height: 6px; overflow: hidden; margin-bottom: 18px;">
                <div id="loading-progress-bar" class="loading-progress-bar" style="width: 0%; height: 6px; background: linear-gradient(45deg, var(--accent), var(--accent-dark)); border-radius: 3px;"></div>
            </div>
            <div id="loading-status" class="subtitle"></div>
        </div>
    </div>

    <div id="app-container" class="app-container hidden">
        <div class="app-header">
            <div class="left">
                <button id="back-to-folders" class="footer-button">Folders</button>
                <span id="current-folder-pill" class="pill">No folder</span>
            </div>
            <div class="right">
                <span id="sync-status-pill" class="pill">Idle</span>
                <span id="queue-count-pill" class="pill">Queue: 0</span>
            </div>
        </div>
        <div class="main-content">
            <div class="viewer-area">
                <div class="placeholder">
                    <div style="font-size: 52px; margin-bottom: 12px;">üõ∞Ô∏è</div>
                    <div id="viewer-placeholder">Select a file to review metadata.</div>
                </div>
            </div>
            <div class="metadata-panel">
                <h2>Metadata</h2>
                <div class="field-group">
                    <label for="file-selector">File</label>
                    <select id="file-selector" class="select"></select>
                </div>
                <div class="pill-row">
                    <span id="selected-file-pill" class="pill">No file loaded</span>
                    <span id="selected-provider-pill" class="pill">‚Äî</span>
                </div>
                <div class="field-group">
                    <label for="title-input">Title</label>
                    <input id="title-input" class="input" placeholder="Enter descriptive title">
                </div>
                <div class="field-group">
                    <label for="tags-input">Tags</label>
                    <input id="tags-input" class="input" placeholder="Comma separated tags">
                </div>
                <div class="field-group">
                    <label for="rating-input">Rating</label>
                    <input id="rating-input" class="input" type="number" min="0" max="5" step="1" placeholder="0-5">
                </div>
                <div class="field-group">
                    <label for="notes-input">Notes</label>
                    <textarea id="notes-input" class="notes-textarea" placeholder="Notes stay local until the sync worker pushes them."></textarea>
                </div>
                <div class="actions">
                    <button id="save-metadata" class="button">Save metadata (debounced)</button>
                    <button id="favorite-toggle" class="button secondary">Toggle favorite</button>
                    <button id="delete-file" class="button secondary" style="border-color: rgba(239, 68, 68, 0.4); color: #ef4444;">Move to recycle queue</button>
                </div>
            </div>
        </div>
        <div class="footer">
            <span id="version-label">‚Äî</span>
            <button id="open-diagnostics">Diagnostics</button>
        </div>
    </div>

    <div id="status-bar" class="status-bar"></div>

    <div id="diagnostics-modal" class="diagnostics-modal">
        <div class="diagnostics-window">
            <div class="diagnostics-header">
                <h3>Diagnostics Log</h3>
                <div class="diagnostics-actions">
                    <button id="diagnostics-copy">Copy</button>
                    <button id="diagnostics-download">Download</button>
                    <button id="diagnostics-close">Close</button>
                </div>
            </div>
            <div id="diagnostics-output" class="diagnostics-body diagnostics-empty">No diagnostics captured yet.</div>
        </div>
    </div>

    <script>
        const RELEASE_TAG = '2025-09-25T04:38:34Z orbital sync pipeline + diagnostics modal refresh';
        const DB_NAME = 'Orbital8-Goji-V1';
        const DB_VERSION = 4;
        const METADATA_FIELDS = ['title', 'tags', 'rating', 'notes', 'favorite'];
        const DEBOUNCE_MS = 750;
        const CRITICAL_OPS = new Set(['deleteFile', 'moveFile', 'bulkApplyTags', 'bulkRemoveTags', 'bulkFolderMove', 'stackMove']);

        const dom = {
            providerScreen: document.getElementById('provider-screen'),
            authScreen: document.getElementById('auth-screen'),
            folderScreen: document.getElementById('folder-screen'),
            loadingScreen: document.getElementById('loading-screen'),
            appContainer: document.getElementById('app-container'),
            providerStatus: document.getElementById('provider-status'),
            authStatus: document.getElementById('auth-status'),
            loadingStatus: document.getElementById('loading-status'),
            loadingProgressBar: document.getElementById('loading-progress-bar'),
            folderList: document.getElementById('folder-list'),
            folderBack: document.getElementById('folder-back'),
            folderRefresh: document.getElementById('folder-refresh'),
            backToFolders: document.getElementById('back-to-folders'),
            fileSelector: document.getElementById('file-selector'),
            statusBar: document.getElementById('status-bar'),
            versionLabel: document.getElementById('version-label'),
            diagnosticsModal: document.getElementById('diagnostics-modal'),
            diagnosticsOutput: document.getElementById('diagnostics-output'),
            viewerPlaceholder: document.getElementById('viewer-placeholder'),
            selectedFilePill: document.getElementById('selected-file-pill'),
            selectedProviderPill: document.getElementById('selected-provider-pill'),
            saveButton: document.getElementById('save-metadata'),
            favoriteToggle: document.getElementById('favorite-toggle'),
            deleteButton: document.getElementById('delete-file'),
            syncStatusPill: document.getElementById('sync-status-pill'),
            queueCountPill: document.getElementById('queue-count-pill'),
            currentFolderPill: document.getElementById('current-folder-pill'),
            openDiagnostics: document.getElementById('open-diagnostics'),
            diagnosticsClose: document.getElementById('diagnostics-close'),
            diagnosticsCopy: document.getElementById('diagnostics-copy'),
            diagnosticsDownload: document.getElementById('diagnostics-download')
        };

        function createDiagnostics() {
            const listeners = new Set();
            let entries = [];
            let persistTimer = null;
            let dbWriter = null;

            function emit() {
                const text = entries.map(e => `[${e.ts}] [${e.scope}] ${e.message}${e.details ? `\n${e.details}` : ''}`).join('\n\n');
                if (dom.diagnosticsOutput) {
                    if (!text) {
                        dom.diagnosticsOutput.classList.add('diagnostics-empty');
                        dom.diagnosticsOutput.textContent = 'No diagnostics captured yet.';
                    } else {
                        dom.diagnosticsOutput.classList.remove('diagnostics-empty');
                        dom.diagnosticsOutput.innerHTML = `<pre>${text.replace(/</g, '&lt;')}</pre>`;
                    }
                }
                listeners.forEach(fn => fn(entries));
            }

            async function persistSoon() {
                if (!dbWriter) { return; }
                clearTimeout(persistTimer);
                persistTimer = setTimeout(() => {
                    dbWriter(entries).catch(console.error);
                }, 500);
            }

            return {
                attachWriter(writer) { dbWriter = writer; },
                onChange(listener) { listeners.add(listener); },
                offChange(listener) { listeners.delete(listener); },
                log(scope, message, details) {
                    const entry = {
                        ts: new Date().toISOString(),
                        scope,
                        message,
                        details: details ? (typeof details === 'string' ? details : JSON.stringify(details, null, 2)) : ''
                    };
                    entries.push(entry);
                    if (entries.length > 5000) {
                        entries = entries.slice(-5000);
                    }
                    emit();
                    persistSoon();
                },
                replace(newEntries) {
                    entries = Array.isArray(newEntries) ? newEntries : [];
                    emit();
                },
                export() {
                    return entries.map(e => `[${e.ts}] [${e.scope}] ${e.message}${e.details ? `\n${e.details}` : ''}`).join('\n\n');
                }
            };
        }

        const diagnostics = createDiagnostics();
        dom.versionLabel.textContent = `${RELEASE_TAG} ‚Ä¢ v4 sync engine + mobile diagnostics`;

        function debounce(fn, wait, { leading = false } = {}) {
            let timer = null;
            let lastArgs = null;
            return (...args) => {
                lastArgs = args;
                if (timer) {
                    clearTimeout(timer);
                } else if (leading) {
                    fn.apply(null, args);
                }
                return new Promise(resolve => {
                    timer = setTimeout(() => {
                        timer = null;
                        resolve(fn.apply(null, lastArgs));
                    }, wait);
                });
            };
        }

        class DBManager {
            constructor(name, version, logFn) {
                this.name = name;
                this.version = version;
                this.log = logFn;
                this.dbPromise = null;
                this.ready = this.open();
            }

            open() {
                if (this.dbPromise) { return this.dbPromise; }
                this.dbPromise = new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.name, this.version);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const existing = Array.from(db.objectStoreNames);
                        const needed = ['syncQueue', 'metadata', 'folderCache', 'pngText', 'syncMeta'];
                        existing.forEach(storeName => {
                            if (!needed.includes(storeName)) {
                                db.deleteObjectStore(storeName);
                            }
                        });
                        needed.forEach(storeName => {
                            if (!db.objectStoreNames.contains(storeName)) {
                                db.createObjectStore(storeName, { keyPath: 'id' });
                            }
                        });
                    };
                    request.onsuccess = () => {
                        const db = request.result;
                        db.onversionchange = () => {
                            diagnostics.log('db', 'Version change detected, closing IndexedDB connection');
                            db.close();
                        };
                        resolve(db);
                    };
                    request.onerror = () => reject(request.error);
                }).then(async db => {
                    await this.ensureDefaults(db);
                    return db;
                });
                return this.dbPromise;
            }

            async ensureDefaults(db) {
                const tx = db.transaction(['syncMeta'], 'readwrite');
                const store = tx.objectStore('syncMeta');
                const limits = await this.get(store, 'limits');
                if (!limits) {
                    await this.put(store, { id: 'limits', maxFolders: 1000, maxMegabytes: 512 });
                }
                const stats = await this.get(store, 'stats');
                if (!stats) {
                    await this.put(store, { id: 'stats', queueDepth: 0, pendingFlushes: 0, folderBytes: 0, pngBytes: 0, folders: 0, pngItems: 0, lastSweep: 0 });
                }
                const diagnosticsEntry = await this.get(store, 'diagnostics:latest');
                if (diagnosticsEntry && diagnosticsEntry.entries) {
                    diagnostics.replace(diagnosticsEntry.entries);
                }
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
                diagnostics.attachWriter(async (entries) => {
                    const database = await this.open();
                    const t = database.transaction(['syncMeta'], 'readwrite');
                    t.objectStore('syncMeta').put({ id: 'diagnostics:latest', entries });
                    await new Promise((resolve, reject) => {
                        t.oncomplete = () => resolve();
                        t.onerror = () => reject(t.error);
                    });
                });
            }

            async get(store, key) {
                return new Promise((resolve, reject) => {
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result || null);
                    request.onerror = () => reject(request.error);
                });
            }

            async put(store, value) {
                return new Promise((resolve, reject) => {
                    const request = store.put(value);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }

            async saveMetadataBatch(entries) {
                const db = await this.open();
                const tx = db.transaction(['metadata'], 'readwrite');
                const store = tx.objectStore('metadata');
                const now = Date.now();
                for (const entry of entries) {
                    const existing = await this.get(store, entry.id);
                    const merged = existing ? { ...existing } : { id: entry.id, provider: entry.provider, metadata: {}, pendingOps: 0 };
                    merged.provider = entry.provider || merged.provider;
                    merged.metadata = { ...(existing ? existing.metadata : {}), ...(entry.metadata || {}) };
                    merged.localUpdatedAt = entry.localUpdatedAt || now;
                    if (entry.lastSyncedAt) {
                        merged.lastSyncedAt = entry.lastSyncedAt;
                    }
                    if (typeof entry.pendingOps === 'number') {
                        merged.pendingOps = entry.pendingOps;
                    }
                    await this.put(store, merged);
                }
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }

            async updateQueueEntry(provider, fileId, operation) {
                const db = await this.open();
                const tx = db.transaction(['syncQueue'], 'readwrite');
                const store = tx.objectStore('syncQueue');
                const id = `${provider}:${fileId}`;
                const existing = await this.get(store, id) || {
                    id,
                    fileId,
                    provider,
                    operations: [],
                    pendingFlush: false,
                    inFlightFlushId: null,
                    lastMergedAt: 0,
                    retryCount: 0
                };
                existing.operations = this.mergeOperations(existing.operations, operation);
                await this.put(store, existing);
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
                await this.bumpQueueStats();
                return existing;
            }

            mergeOperations(existingOps, incoming) {
                const operations = Array.isArray(existingOps) ? [...existingOps] : [];
                const op = { ...incoming, queuedAt: incoming.queuedAt || Date.now() };
                if (op.type === 'updateMetadata') {
                    for (let i = operations.length - 1; i >= 0; i--) {
                        if (operations[i].type === 'updateMetadata') {
                            operations[i].payload = { ...operations[i].payload, ...op.payload };
                            operations[i].queuedAt = op.queuedAt;
                            return operations;
                        }
                    }
                }
                operations.push(op);
                return operations;
            }

            async bumpQueueStats() {
                const db = await this.open();
                const tx = db.transaction(['syncQueue'], 'readonly');
                const queueStore = tx.objectStore('syncQueue');
                const all = await new Promise((resolve, reject) => {
                    const request = queueStore.getAll();
                    request.onsuccess = () => resolve(request.result || []);
                    request.onerror = () => reject(request.error);
                });
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
                const depth = all.reduce((sum, item) => sum + (item.operations?.length || 0), 0);
                const metaTx = (await this.open()).transaction(['syncMeta'], 'readwrite');
                const metaStore = metaTx.objectStore('syncMeta');
                const stats = await this.get(metaStore, 'stats') || { id: 'stats' };
                stats.queueDepth = depth;
                await this.put(metaStore, { ...stats, id: 'stats' });
                await new Promise((resolve, reject) => {
                    metaTx.oncomplete = () => resolve();
                    metaTx.onerror = () => reject(metaTx.error);
                });
                dom.queueCountPill.textContent = `Queue: ${depth}`;
            }

            async touchCache(storeName, { id, provider, data, estimatedBytes = 0, pendingOps = 0 }) {
                const db = await this.open();
                const tx = db.transaction([storeName], 'readwrite');
                const store = tx.objectStore(storeName);
                const existing = await this.get(store, id);
                const now = Date.now();
                const record = existing ? { ...existing } : { id, provider, data: null, estimatedBytes: 0, pendingOps: 0 };
                if (data !== undefined) { record.data = data; }
                record.provider = provider || record.provider;
                record.estimatedBytes = estimatedBytes || record.estimatedBytes || 0;
                record.lastAccessed = now;
                if (typeof pendingOps === 'number') { record.pendingOps = pendingOps; }
                await this.put(store, record);
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }

            async recordStats(update) {
                const db = await this.open();
                const tx = db.transaction(['syncMeta'], 'readwrite');
                const store = tx.objectStore('syncMeta');
                const stats = await this.get(store, 'stats') || { id: 'stats' };
                Object.assign(stats, update, { id: 'stats' });
                await this.put(store, stats);
                await new Promise((resolve, reject) => {
                    tx.oncomplete = () => resolve();
                    tx.onerror = () => reject(tx.error);
                });
            }
        }
        function sharedDbManagerSource() {
            return `class DBManager {\n`
                + `  constructor(name, version, logFn) {\n`
                + `    this.name = name;\n`
                + `    this.version = version;\n`
                + `    this.log = logFn;\n`
                + `    this.dbPromise = null;\n`
                + `  }\n`
                + `  open() {\n`
                + `    if (this.dbPromise) { return this.dbPromise; }\n`
                + `    this.dbPromise = new Promise((resolve, reject) => {\n`
                + `      const request = indexedDB.open(this.name, this.version);\n`
                + `      request.onupgradeneeded = (event) => {\n`
                + `        const db = event.target.result;\n`
                + `        const needed = ['syncQueue', 'metadata', 'folderCache', 'pngText', 'syncMeta'];\n`
                + `        Array.from(db.objectStoreNames).forEach(name => { if (!needed.includes(name)) { db.deleteObjectStore(name); } });\n`
                + `        needed.forEach(name => { if (!db.objectStoreNames.contains(name)) { db.createObjectStore(name, { keyPath: 'id' }); } });\n`
                + `      };\n`
                + `      request.onsuccess = () => { resolve(request.result); };\n`
                + `      request.onerror = () => reject(request.error);\n`
                + `    }).then(async db => {\n`
                + `      db.onversionchange = () => db.close();\n`
                + `      const tx = db.transaction(['syncMeta'], 'readwrite');\n`
                + `      const store = tx.objectStore('syncMeta');\n`
                + `      const limits = await this.get(store, 'limits');\n`
                + `      if (!limits) { await this.put(store, { id: 'limits', maxFolders: 1000, maxMegabytes: 512 }); }\n`
                + `      const stats = await this.get(store, 'stats');\n`
                + `      if (!stats) { await this.put(store, { id: 'stats', queueDepth: 0, pendingFlushes: 0, folderBytes: 0, pngBytes: 0, folders: 0, pngItems: 0, lastSweep: 0 }); }\n`
                + `      await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `      return db;\n`
                + `    });\n`
                + `    return this.dbPromise;\n`
                + `  }\n`
                + `  async get(store, key) {\n`
                + `    return await new Promise((resolve, reject) => {\n`
                + `      const request = store.get(key);\n`
                + `      request.onsuccess = () => resolve(request.result || null);\n`
                + `      request.onerror = () => reject(request.error);\n`
                + `    });\n`
                + `  }\n`
                + `  async put(store, value) {\n`
                + `    return await new Promise((resolve, reject) => {\n`
                + `      const request = store.put(value);\n`
                + `      request.onsuccess = () => resolve();\n`
                + `      request.onerror = () => reject(request.error);\n`
                + `    });\n`
                + `  }\n`
                + `  async saveMetadataBatch(entries) {\n`
                + `    const db = await this.open();\n`
                + `    const tx = db.transaction(['metadata'], 'readwrite');\n`
                + `    const store = tx.objectStore('metadata');\n`
                + `    const now = Date.now();\n`
                + `    for (const entry of entries) {\n`
                + `      const existing = await this.get(store, entry.id);\n`
                + `      const merged = existing ? { ...existing } : { id: entry.id, provider: entry.provider, metadata: {}, pendingOps: 0 };\n`
                + `      merged.provider = entry.provider || merged.provider;\n`
                + `      merged.metadata = { ...(existing ? existing.metadata : {}), ...(entry.metadata || {}) };\n`
                + `      merged.localUpdatedAt = entry.localUpdatedAt || now;\n`
                + `      if (entry.lastSyncedAt) { merged.lastSyncedAt = entry.lastSyncedAt; }\n`
                + `      if (typeof entry.pendingOps === 'number') { merged.pendingOps = entry.pendingOps; }\n`
                + `      await this.put(store, merged);\n`
                + `    }\n`
                + `    await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `  }\n`
                + `  async recordStats(update) {\n`
                + `    const db = await this.open();\n`
                + `    const tx = db.transaction(['syncMeta'], 'readwrite');\n`
                + `    const store = tx.objectStore('syncMeta');\n`
                + `    const stats = await this.get(store, 'stats') || { id: 'stats' };\n`
                + `    Object.assign(stats, update, { id: 'stats' });\n`
                + `    await this.put(store, stats);\n`
                + `    await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `  }\n`
                + `  async touch(storeName, record) {\n`
                + `    const db = await this.open();\n`
                + `    const tx = db.transaction([storeName], 'readwrite');\n`
                + `    const store = tx.objectStore(storeName);\n`
                + `    const existing = await this.get(store, record.id);\n`
                + `    const now = Date.now();\n`
                + `    const merged = existing ? { ...existing } : { id: record.id, provider: record.provider, data: null, estimatedBytes: 0, pendingOps: 0 };\n`
                + `    merged.provider = record.provider || merged.provider;\n`
                + `    if (record.data !== undefined) { merged.data = record.data; }\n`
                + `    merged.lastAccessed = now;\n`
                + `    merged.estimatedBytes = record.estimatedBytes || merged.estimatedBytes || 0;\n`
                + `    if (typeof record.pendingOps === 'number') { merged.pendingOps = record.pendingOps; }\n`
                + `    await this.put(store, merged);\n`
                + `    await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `  }\n`
                + `  async getAll(storeName) {\n`
                + `    const db = await this.open();\n`
                + `    const tx = db.transaction([storeName], 'readonly');\n`
                + `    const store = tx.objectStore(storeName);\n`
                + `    return await new Promise((resolve, reject) => {\n`
                + `      const request = store.getAll();\n`
                + `      request.onsuccess = () => resolve(request.result || []);\n`
                + `      request.onerror = () => reject(request.error);\n`
                + `    });\n`
                + `  }\n`
                + `}`;
        }

        function createSyncWorker() {
            const source = `(() => {\n`
                + `const DB_NAME = '${DB_NAME}';\n`
                + `const DB_VERSION = ${DB_VERSION};\n`
                + `${sharedDbManagerSource()}\n`
                + `const dbManager = new DBManager(DB_NAME, DB_VERSION, () => {});\n`
                + `let processing = false;\n`
                + `let sweepTimer;\n`
                + `const METADATA_TYPES = new Set(['updateMetadata']);\n`
                + `const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n`
                + `const nowIso = () => new Date().toISOString();\n`
                + `async function markStats(stats) { await dbManager.recordStats(stats); }\n`
                + `async function processQueue(reason) {\n`
                + `  if (processing) { return; }\n`
                + `  processing = true;\n`
                + `  try {\n`
                + `    const db = await dbManager.open();\n`
                + `    const tx = db.transaction(['syncQueue'], 'readwrite');\n`
                + `    const store = tx.objectStore('syncQueue');\n`
                + `    const all = await new Promise((resolve, reject) => {\n`
                + `      const request = store.getAll();\n`
                + `      request.onsuccess = () => resolve(request.result || []);\n`
                + `      request.onerror = () => reject(request.error);\n`
                + `    });\n`
                + `    for (const entry of all) {\n`
                + `      if (!entry.operations || entry.operations.length === 0) { continue; }\n`
                + `      const flushId = ` + "`flush-${Date.now()}-${Math.random().toString(36).slice(2)}`" + `;\n`
                + `      entry.pendingFlush = reason === 'flush' ? true : entry.pendingFlush;\n`
                + `      entry.inFlightFlushId = flushId;\n`
                + `      await new Promise((resolve, reject) => {\n`
                + `        const putReq = store.put(entry);\n`
                + `        putReq.onsuccess = () => resolve();\n`
                + `        putReq.onerror = () => reject(putReq.error);\n`
                + `      });\n`
                + `      const { meta, others } = (() => {\n`
                + `        const metaPayload = {};\n`
                + `        const rest = [];\n`
                + `        for (const op of entry.operations) {\n`
                + `          if (METADATA_TYPES.has(op.type)) { Object.assign(metaPayload, op.payload || {}); } else { rest.push(op); }\n`
                + `        }\n`
                + `        return { meta: metaPayload, others: rest };\n`
                + `      })();\n`
                + `      let success = true;\n`
                + `      if (Object.keys(meta).length > 0 || others.length > 0) {\n`
                + `        try {\n`
                + `          await syncEntry(entry, meta, others);\n`
                + `          const complete = { ...entry, operations: [], pendingFlush: false, inFlightFlushId: null, lastMergedAt: Date.now(), retryCount: 0 };\n`
                + `          await new Promise((resolve, reject) => {\n`
                + `            const req = store.put(complete);\n`
                + `            req.onsuccess = () => resolve();\n`
                + `            req.onerror = () => reject(req.error);\n`
                + `          });\n`
                + `        } catch (error) {\n`
                + `          success = false;\n`
                + `          const failed = { ...entry, pendingFlush: true, inFlightFlushId: null, retryCount: (entry.retryCount || 0) + 1 };\n`
                + `          await new Promise((resolve, reject) => {\n`
                + `            const req = store.put(failed);\n`
                + `            req.onsuccess = () => resolve();\n`
                + `            req.onerror = () => reject(req.error);\n`
                + `          });\n`
                + `          self.postMessage({ type: 'diagnostic', payload: { scope: 'syncWorker', message: 'Provider sync failed', details: { fileId: entry.fileId, provider: entry.provider, error: error?.message || String(error) } }});\n`
                + `        }\n`
                + `      }\n`
                + `      if (!success) {\n`
                + `        await delay(500);\n`
                + `      } else {\n`
                + `        await dbManager.saveMetadataBatch([{ id: entry.fileId, provider: entry.provider, metadata: meta, lastSyncedAt: Date.now(), pendingOps: 0 }]);\n`
                + `      }\n`
                + `    }\n`
                + `    await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `  } catch (error) {\n`
                + `    self.postMessage({ type: 'diagnostic', payload: { scope: 'syncWorker', message: 'Queue processing error', details: error?.stack || error?.message || String(error) }});\n`
                + `  } finally {\n`
                + `    processing = false;\n`
                + `  }\n`
                + `}\n`
                + `async function syncEntry(entry, metaUpdates, otherOps) {\n`
                + `  if (entry.provider === 'onedrive') { await syncOneDrive(entry, metaUpdates, otherOps); }\n`
                + `  else if (entry.provider === 'gdrive') { await syncGoogleDrive(entry, metaUpdates, otherOps); }\n`
                + `}\n`
                + `async function syncOneDrive(entry, metaUpdates) {\n`
                + `  const headers = { 'Content-Type': 'application/json' };\n`
                + `  if (entry.providerMetadata?.accessToken) { headers['Authorization'] = 'Bearer ' + entry.providerMetadata.accessToken; }\n`
                + `  const base = 'https://graph.microsoft.com/v1.0/me/drive/special/approot';\n`
                + `  const resource = base + '/' + entry.fileId + '.json:/content';\n`
                + `  let remote = {};\n`
                + `  try {\n`
                + `    const response = await fetch(resource, { method: 'GET', headers });\n`
                + `    if (response.status === 200) { remote = await response.json(); }\n`
                + `    else if (response.status !== 404) { throw new Error('GET ' + response.status); }\n`
                + `  } catch (error) {\n`
                + `    throw error;\n`
                + `  }\n`
                + `  const payload = { ...remote, ...metaUpdates };\n`
                + `  const putResponse = await fetch(resource, { method: 'PUT', headers, body: JSON.stringify(payload) });\n`
                + `  if (!putResponse.ok) { throw new Error('PUT ' + putResponse.status); }\n`
                + `}\n`
                + `async function syncGoogleDrive(entry, metaUpdates) {\n`
                + `  const headers = { 'Content-Type': 'application/json' };\n`
                + `  if (entry.providerMetadata?.accessToken) { headers['Authorization'] = 'Bearer ' + entry.providerMetadata.accessToken; }\n`
                + `  const resource = 'https://www.googleapis.com/drive/v3/files/' + entry.fileId + '?alt=media';\n`
                + `  let remote = {};\n`
                + `  try {\n`
                + `    const response = await fetch(resource, { method: 'GET', headers });\n`
                + `    if (response.status === 200) { remote = await response.json(); }\n`
                + `  } catch (error) {\n`
                + `    /* allow create */\n`
                + `  }\n`
                + `  const payload = { ...remote, ...metaUpdates };\n`
                + `  const patchResource = 'https://www.googleapis.com/upload/drive/v3/files/' + entry.fileId + '?uploadType=media';\n`
                + `  const response = await fetch(patchResource, { method: 'PATCH', headers, body: JSON.stringify(payload) });\n`
                + `  if (!response.ok) { throw new Error('PATCH ' + response.status); }\n`
                + `}\n`
                + `async function runSweep() {\n`
                + `  const limits = await dbManager.open().then(db => new Promise((resolve, reject) => {\n`
                + `    const tx = db.transaction(['syncMeta'], 'readonly');\n`
                + `    const store = tx.objectStore('syncMeta');\n`
                + `    const req = store.get('limits');\n`
                + `    req.onsuccess = () => resolve(req.result || { maxFolders: 1000, maxMegabytes: 512 });\n`
                + `    req.onerror = () => reject(req.error);\n`
                + `  }));\n`
                + `  const folderEntries = await dbManager.getAll('folderCache');\n`
                + `  const pngEntries = await dbManager.getAll('pngText');\n`
                + `  const toEvict = [];\n`
                + `  const limitsBytes = (limits.maxMegabytes || 512) * 1024 * 1024;\n`
                + `  let totalFolders = folderEntries.length;\n`
                + `  let totalPng = pngEntries.length;\n`
                + `  let folderBytes = folderEntries.reduce((sum, item) => sum + (item.estimatedBytes || 0), 0);\n`
                + `  let pngBytes = pngEntries.reduce((sum, item) => sum + (item.estimatedBytes || 0), 0);\n`
                + `  const consider = (entries, storeName) => {\n`
                + `    const eligible = entries.filter(item => !item.pendingOps);\n`
                + `    eligible.sort((a, b) => (a.lastAccessed || 0) - (b.lastAccessed || 0));\n`
                + `    while ((storeName === 'folderCache' ? totalFolders : totalPng) > (limits.maxFolders || 1000) || (folderBytes + pngBytes) > limitsBytes) {\n`
                + `      const victim = eligible.shift();\n`
                + `      if (!victim) { break; }\n`
                + `      toEvict.push({ storeName, victim });\n`
                + `      if (storeName === 'folderCache') { totalFolders--; folderBytes -= victim.estimatedBytes || 0; } else { totalPng--; pngBytes -= victim.estimatedBytes || 0; }\n`
                + `    }\n`
                + `  };\n`
                + `  consider(folderEntries, 'folderCache');\n`
                + `  consider(pngEntries, 'pngText');\n`
                + `  if (toEvict.length) {\n`
                + `    const db = await dbManager.open();\n`
                + `    const tx = db.transaction(['folderCache', 'pngText'], 'readwrite');\n`
                + `    for (const item of toEvict) {\n`
                + `      const store = tx.objectStore(item.storeName);\n`
                + `      store.delete(item.victim.id);\n`
                + `      self.postMessage({ type: 'diagnostic', payload: { scope: 'syncWorker.eviction', message: 'Evicted cache entry', details: { store: item.storeName, id: item.victim.id, bytes: item.victim.estimatedBytes || 0 } }});\n`
                + `    }\n`
                + `    await new Promise((resolve, reject) => { tx.oncomplete = () => resolve(); tx.onerror = () => reject(tx.error); });\n`
                + `  }\n`
                + `  await markStats({ folders: totalFolders, pngItems: totalPng, folderBytes, pngBytes, lastSweep: Date.now() });\n`
                + `}\n`
                + `function scheduleSweep() {\n`
                + `  if (typeof sweepTimer !== 'undefined') { clearTimeout(sweepTimer); }\n`
                + `  sweepTimer = setTimeout(async () => {\n`
                + `    try { await runSweep(); } finally { scheduleSweep(); }\n`
                + `  }, 120000);\n`
                + `}\n`
                + `self.onmessage = async (event) => {\n`
                + `  const { type, payload } = event.data || {};\n`
                + `  if (type === 'queueUpdated') { await processQueue('queue'); }\n`
                + `  if (type === 'flushRequest') {\n`
                + `    const { flushId } = payload;\n`
                + `    self.postMessage({ type: 'flushAccepted', payload: { flushId } });\n`
                + `    await processQueue('flush');\n`
                + `    self.postMessage({ type: 'flushComplete', payload: { flushId } });\n`
                + `  }\n`
                + `};\n`
                + `dbManager.open().then(() => { scheduleSweep(); processQueue('startup'); });\n`
                + `})();`;
            const blob = new Blob([source], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }
        function createPngWorker() {
            const baseSource = `(() => {\n`
                + `const DB_NAME = '${DB_NAME}';\n`
                + `const DB_VERSION = ${DB_VERSION};\n`
                + `${sharedDbManagerSource()}\n`
                + `const dbManager = new DBManager(DB_NAME, DB_VERSION, () => {});\n`
                + `const textDecoder = new TextDecoder('utf-8');\n`
                + `const inflateChunk = async (data) => {\n`
                + `  if (typeof DecompressionStream === 'function') {\n`
                + `    const stream = new DecompressionStream('deflate');\n`
                + `    const decompressed = await new Response(new Blob([data]).stream().pipeThrough(stream)).arrayBuffer();\n`
                + `    return new Uint8Array(decompressed);\n`
                + `  }\n`
                + `  if (!self.pako) {\n`
                + `    const script = atob(PAKO_BASE64);\n`
                + `    eval(script);\n`
                + `  }\n`
                + `  const inflated = self.pako.inflate(data);\n`
                + `  return inflated instanceof Uint8Array ? inflated : new Uint8Array(inflated);\n`
                + `};\n`
                + `function parseChunks(buffer) {\n`
                + `  const data = new DataView(buffer);\n`
                + `  let offset = 8;\n`
                + `  const results = [];\n`
                + `  while (offset < data.byteLength) {\n`
                + `    const length = data.getUint32(offset);\n`
                + `    const type = String.fromCharCode(data.getUint8(offset + 4), data.getUint8(offset + 5), data.getUint8(offset + 6), data.getUint8(offset + 7));\n`
                + `    offset += 8;\n`
                + `    if (type === 'tEXt') {\n`
                + `      const slice = new Uint8Array(buffer, offset, length);\n`
                + `      results.push(textDecoder.decode(slice));\n`
                + `    } else if (type === 'zTXt') {\n`
                + `      let sep = offset;\n`
                + `      while (sep < offset + length && new Uint8Array(buffer, sep, 1)[0] !== 0) { sep++; }\n`
                + `      const keywordBytes = new Uint8Array(buffer, offset, sep - offset);\n`
                + `      const keyword = textDecoder.decode(keywordBytes);\n`
                + `      const compressionFlag = new Uint8Array(buffer, sep + 1, 1)[0];\n`
                + `      if (compressionFlag !== 0) {\n`
                + `        throw new Error('Unsupported PNG compression flag');\n`
                + `      }\n`
                + `      const compressed = new Uint8Array(buffer, sep + 2, offset + length - (sep + 2));\n`
                + `      results.push(keyword + '=' + textDecoder.decode(await inflateChunk(compressed)));\n`
                + `    }\n`
                + `    offset += length + 4;\n`
                + `  }\n`
                + `  return results;\n`
                + `}\n`
                + `self.onmessage = async (event) => {\n`
                + `  const { type, payload } = event.data || {};\n`
                + `  if (type === 'extractPngText') {\n`
                + `    try {\n`
                + `      const { buffer, entries } = payload;\n`
                + `      const texts = await parseChunks(buffer);\n`
                + `      const metadataEntries = texts.map(text => {\n`
                + `        const [key, ...rest] = text.split('=');\n`
                + `        const value = rest.join('=');\n`
                + `        return { id: entries.fileId, provider: entries.provider, metadata: { [key]: value }, localUpdatedAt: Date.now() };\n`
                + `      });\n`
                + `      if (metadataEntries.length) {\n`
                + `        await dbManager.saveMetadataBatch(metadataEntries);\n`
                + `        self.postMessage({ type: 'extractComplete', payload: { fileId: entries.fileId, count: metadataEntries.length } });\n`
                + `      }\n`
                + `    } catch (error) {\n`
                + `      self.postMessage({ type: 'diagnostic', payload: { scope: 'pngWorker', message: 'PNG text parse failed', details: error?.message || String(error) } });\n`
                + `    }\n`
                + `  }\n`
                + `};\n`
                + `})();`;
            const prefix = `const PAKO_BASE64 = '`;
            const blobParts = [prefix, LyohIHBha28gMi4xLjAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvIEBsaWNlbnNlIChNSVQgQU5EIFpsaWIpICovCiFmdW5jdGlvbihlLHQpeyJvYmplY3QiPT10eXBlb2YgZXhwb3J0cyYmInVuZGVmaW5lZCIhPXR5cGVvZiBtb2R1bGU/dChleHBvcnRzKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbImV4cG9ydHMiXSx0KTp0KChlPSJ1bmRlZmluZWQiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOmV8fHNlbGYpLnBha289e30pfSh0aGlzLChmdW5jdGlvbihlKXsidXNlIHN0cmljdCI7dmFyIHQ9KGUsdCxpLG4pPT57bGV0IGE9NjU1MzUmZXwwLHI9ZT4+PjE2JjY1NTM1fDAsbz0wO2Zvcig7MCE9PWk7KXtvPWk+MmUzPzJlMzppLGktPW87ZG97YT1hK3RbbisrXXwwLHI9cithfDB9d2hpbGUoLS1vKTthJT02NTUyMSxyJT02NTUyMX1yZXR1cm4gYXxyPDwxNnwwfTtjb25zdCBpPW5ldyBVaW50MzJBcnJheSgoKCk9PntsZXQgZSx0PVtdO2Zvcih2YXIgaT0wO2k8MjU2O2krKyl7ZT1pO2Zvcih2YXIgbj0wO248ODtuKyspZT0xJmU/Mzk4ODI5MjM4NF5lPj4+MTplPj4+MTt0W2ldPWV9cmV0dXJuIHR9KSgpKTt2YXIgbj0oZSx0LG4sYSk9Pntjb25zdCByPWksbz1hK247ZV49LTE7Zm9yKGxldCBpPWE7aTxvO2krKyllPWU+Pj44XnJbMjU1JihlXnRbaV0pXTtyZXR1cm4tMV5lfTtjb25zdCBhPTE2MjA5O3ZhciByPWZ1bmN0aW9uKGUsdCl7bGV0IGksbixyLG8scyxsLGQsZixjLGgsdSx3LGIsbSxrLF8sZyxwLHYseCx5LEUsUixBO2NvbnN0IFo9ZS5zdGF0ZTtpPWUubmV4dF9pbixSPWUuaW5wdXQsbj1pKyhlLmF2YWlsX2luLTUpLHI9ZS5uZXh0X291dCxBPWUub3V0cHV0LG89ci0odC1lLmF2YWlsX291dCkscz1yKyhlLmF2YWlsX291dC0yNTcpLGw9Wi5kbWF4LGQ9Wi53c2l6ZSxmPVoud2hhdmUsYz1aLnduZXh0LGg9Wi53aW5kb3csdT1aLmhvbGQsdz1aLmJpdHMsYj1aLmxlbmNvZGUsbT1aLmRpc3Rjb2RlLGs9KDE8PFoubGVuYml0cyktMSxfPSgxPDxaLmRpc3RiaXRzKS0xO2U6ZG97dzwxNSYmKHUrPVJbaSsrXTw8dyx3Kz04LHUrPVJbaSsrXTw8dyx3Kz04KSxnPWJbdSZrXTt0OmZvcig7Oyl7aWYocD1nPj4+MjQsdT4+Pj1wLHctPXAscD1nPj4+MTYmMjU1LDA9PT1wKUFbcisrXT02NTUzNSZnO2Vsc2V7aWYoISgxNiZwKSl7aWYoMD09KDY0JnApKXtnPWJbKDY1NTM1JmcpKyh1JigxPDxwKS0xKV07Y29udGludWUgdH1pZigzMiZwKXtaLm1vZGU9MTYxOTE7YnJlYWsgZX1lLm1zZz0iaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlIixaLm1vZGU9YTticmVhayBlfXY9NjU1MzUmZyxwJj0xNSxwJiYodzxwJiYodSs9UltpKytdPDx3LHcrPTgpLHYrPXUmKDE8PHApLTEsdT4+Pj1wLHctPXApLHc8MTUmJih1Kz1SW2krK108PHcsdys9OCx1Kz1SW2krK108PHcsdys9OCksZz1tW3UmX107aTpmb3IoOzspe2lmKHA9Zz4+PjI0LHU+Pj49cCx3LT1wLHA9Zz4+PjE2JjI1NSwhKDE2JnApKXtpZigwPT0oNjQmcCkpe2c9bVsoNjU1MzUmZykrKHUmKDE8PHApLTEpXTtjb250aW51ZSBpfWUubXNnPSJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiLFoubW9kZT1hO2JyZWFrIGV9aWYoeD02NTUzNSZnLHAmPTE1LHc8cCYmKHUrPVJbaSsrXTw8dyx3Kz04LHc8cCYmKHUrPVJbaSsrXTw8dyx3Kz04KSkseCs9dSYoMTw8cCktMSx4Pmwpe2UubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsWi5tb2RlPWE7YnJlYWsgZX1pZih1Pj4+PXAsdy09cCxwPXItbyx4PnApe2lmKHA9eC1wLHA+ZiYmWi5zYW5lKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLFoubW9kZT1hO2JyZWFrIGV9aWYoeT0wLEU9aCwwPT09Yyl7aWYoeSs9ZC1wLHA8dil7di09cDtkb3tBW3IrK109aFt5KytdfXdoaWxlKC0tcCk7eT1yLXgsRT1BfX1lbHNlIGlmKGM8cCl7aWYoeSs9ZCtjLXAscC09YyxwPHYpe3YtPXA7ZG97QVtyKytdPWhbeSsrXX13aGlsZSgtLXApO2lmKHk9MCxjPHYpe3A9Yyx2LT1wO2Rve0FbcisrXT1oW3krK119d2hpbGUoLS1wKTt5PXIteCxFPUF9fX1lbHNlIGlmKHkrPWMtcCxwPHYpe3YtPXA7ZG97QVtyKytdPWhbeSsrXX13aGlsZSgtLXApO3k9ci14LEU9QX1mb3IoO3Y+MjspQVtyKytdPUVbeSsrXSxBW3IrK109RVt5KytdLEFbcisrXT1FW3krK10sdi09Mzt2JiYoQVtyKytdPUVbeSsrXSx2PjEmJihBW3IrK109RVt5KytdKSl9ZWxzZXt5PXIteDtkb3tBW3IrK109QVt5KytdLEFbcisrXT1BW3krK10sQVtyKytdPUFbeSsrXSx2LT0zfXdoaWxlKHY+Mik7diYmKEFbcisrXT1BW3krK10sdj4xJiYoQVtyKytdPUFbeSsrXSkpfWJyZWFrfX1icmVha319d2hpbGUoaTxuJiZyPHMpO3Y9dz4+MyxpLT12LHctPXY8PDMsdSY9KDE8PHcpLTEsZS5uZXh0X2luPWksZS5uZXh0X291dD1yLGUuYXZhaWxfaW49aTxuP24taSs1OjUtKGktbiksZS5hdmFpbF9vdXQ9cjxzP3MtcisyNTc6MjU3LShyLXMpLFouaG9sZD11LFouYml0cz13fTtjb25zdCBvPTE1LHM9bmV3IFVpbnQxNkFycmF5KFszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDAsMF0pLGw9bmV3IFVpbnQ4QXJyYXkoWzE2LDE2LDE2LDE2LDE2LDE2LDE2LDE2LDE3LDE3LDE3LDE3LDE4LDE4LDE4LDE4LDE5LDE5LDE5LDE5LDIwLDIwLDIwLDIwLDIxLDIxLDIxLDIxLDE2LDcyLDc4XSksZD1uZXcgVWludDE2QXJyYXkoWzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdKSxmPW5ldyBVaW50OEFycmF5KFsxNiwxNiwxNiwxNiwxNywxNywxOCwxOCwxOSwxOSwyMCwyMCwyMSwyMSwyMiwyMiwyMywyMywyNCwyNCwyNSwyNSwyNiwyNiwyNywyNywyOCwyOCwyOSwyOSw2NCw2NF0pO3ZhciBjPShlLHQsaSxuLGEscixjLGgpPT57Y29uc3QgdT1oLmJpdHM7bGV0IHcsYixtLGssXyxnLHA9MCx2PTAseD0wLHk9MCxFPTAsUj0wLEE9MCxaPTAsUz0wLFQ9MCxPPW51bGw7Y29uc3QgVT1uZXcgVWludDE2QXJyYXkoMTYpLEQ9bmV3IFVpbnQxNkFycmF5KDE2KTtsZXQgSSxCLE4sQz1udWxsO2ZvcihwPTA7cDw9bztwKyspVVtwXT0wO2Zvcih2PTA7djxuO3YrKylVW3RbaSt2XV0rKztmb3IoRT11LHk9bzt5Pj0xJiYwPT09VVt5XTt5LS0pO2lmKEU+eSYmKEU9eSksMD09PXkpcmV0dXJuIGFbcisrXT0yMDk3MTUyMCxhW3IrK109MjA5NzE1MjAsaC5iaXRzPTEsMDtmb3IoeD0xO3g8eSYmMD09PVVbeF07eCsrKTtmb3IoRTx4JiYoRT14KSxaPTEscD0xO3A8PW87cCsrKWlmKFo8PD0xLFotPVVbcF0sWjwwKXJldHVybi0xO2lmKFo+MCYmKDA9PT1lfHwxIT09eSkpcmV0dXJuLTE7Zm9yKERbMV09MCxwPTE7cDxvO3ArKylEW3ArMV09RFtwXStVW3BdO2Zvcih2PTA7djxuO3YrKykwIT09dFtpK3ZdJiYoY1tEW3RbaSt2XV0rK109dik7aWYoMD09PWU/KE89Qz1jLGc9MjApOjE9PT1lPyhPPXMsQz1sLGc9MjU3KTooTz1kLEM9ZixnPTApLFQ9MCx2PTAscD14LF89cixSPUUsQT0wLG09LTEsUz0xPDxFLGs9Uy0xLDE9PT1lJiZTPjg1Mnx8Mj09PWUmJlM+NTkyKXJldHVybiAxO2Zvcig7Oyl7ST1wLUEsY1t2XSsxPGc/KEI9MCxOPWNbdl0pOmNbdl0+PWc/KEI9Q1tjW3ZdLWddLE49T1tjW3ZdLWddKTooQj05NixOPTApLHc9MTw8cC1BLGI9MTw8Uix4PWI7ZG97Yi09dyxhW18rKFQ+PkEpK2JdPUk8PDI0fEI8PDE2fE58MH13aGlsZSgwIT09Yik7Zm9yKHc9MTw8cC0xO1Qmdzspdz4+PTE7aWYoMCE9PXc/KFQmPXctMSxUKz13KTpUPTAsdisrLDA9PS0tVVtwXSl7aWYocD09PXkpYnJlYWs7cD10W2krY1t2XV19aWYocD5FJiYoVCZrKSE9PW0pe2ZvcigwPT09QSYmKEE9RSksXys9eCxSPXAtQSxaPTE8PFI7UitBPHkmJihaLT1VW1IrQV0sIShaPD0wKSk7KVIrKyxaPDw9MTtpZihTKz0xPDxSLDE9PT1lJiZTPjg1Mnx8Mj09PWUmJlM+NTkyKXJldHVybiAxO209VCZrLGFbbV09RTw8MjR8Ujw8MTZ8Xy1yfDB9fXJldHVybiAwIT09VCYmKGFbXytUXT1wLUE8PDI0fDY0PDwxNnwwKSxoLmJpdHM9RSwwfSxoPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfTUVNX0VSUk9SOi00LFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9O2NvbnN0e1pfRklOSVNIOnUsWl9CTE9DSzp3LFpfVFJFRVM6YixaX09LOm0sWl9TVFJFQU1fRU5EOmssWl9ORUVEX0RJQ1Q6XyxaX1NUUkVBTV9FUlJPUjpnLFpfREFUQV9FUlJPUjpwLFpfTUVNX0VSUk9SOnYsWl9CVUZfRVJST1I6eCxaX0RFRkxBVEVEOnl9PWgsRT0xNjE4MCxSPTE2MTkwLEE9MTYxOTEsWj0xNjE5MixTPTE2MTk0LFQ9MTYxOTksTz0xNjIwMCxVPTE2MjA2LEQ9MTYyMDksST1lPT4oZT4+PjI0JjI1NSkrKGU+Pj44JjY1MjgwKSsoKDY1MjgwJmUpPDw4KSsoKDI1NSZlKTw8MjQpO2Z1bmN0aW9uIEIoKXt0aGlzLnN0cm09bnVsbCx0aGlzLm1vZGU9MCx0aGlzLmxhc3Q9ITEsdGhpcy53cmFwPTAsdGhpcy5oYXZlZGljdD0hMSx0aGlzLmZsYWdzPTAsdGhpcy5kbWF4PTAsdGhpcy5jaGVjaz0wLHRoaXMudG90YWw9MCx0aGlzLmhlYWQ9bnVsbCx0aGlzLndiaXRzPTAsdGhpcy53c2l6ZT0wLHRoaXMud2hhdmU9MCx0aGlzLnduZXh0PTAsdGhpcy53aW5kb3c9bnVsbCx0aGlzLmhvbGQ9MCx0aGlzLmJpdHM9MCx0aGlzLmxlbmd0aD0wLHRoaXMub2Zmc2V0PTAsdGhpcy5leHRyYT0wLHRoaXMubGVuY29kZT1udWxsLHRoaXMuZGlzdGNvZGU9bnVsbCx0aGlzLmxlbmJpdHM9MCx0aGlzLmRpc3RiaXRzPTAsdGhpcy5uY29kZT0wLHRoaXMubmxlbj0wLHRoaXMubmRpc3Q9MCx0aGlzLmhhdmU9MCx0aGlzLm5leHQ9bnVsbCx0aGlzLmxlbnM9bmV3IFVpbnQxNkFycmF5KDMyMCksdGhpcy53b3JrPW5ldyBVaW50MTZBcnJheSgyODgpLHRoaXMubGVuZHluPW51bGwsdGhpcy5kaXN0ZHluPW51bGwsdGhpcy5zYW5lPTAsdGhpcy5iYWNrPTAsdGhpcy53YXM9MH1jb25zdCBOPWU9PntpZighZSlyZXR1cm4gMTtjb25zdCB0PWUuc3RhdGU7cmV0dXJuIXR8fHQuc3RybSE9PWV8fHQubW9kZTxFfHx0Lm1vZGU+MTYyMTE/MTowfSxDPWU9PntpZihOKGUpKXJldHVybiBnO2NvbnN0IHQ9ZS5zdGF0ZTtyZXR1cm4gZS50b3RhbF9pbj1lLnRvdGFsX291dD10LnRvdGFsPTAsZS5tc2c9IiIsdC53cmFwJiYoZS5hZGxlcj0xJnQud3JhcCksdC5tb2RlPUUsdC5sYXN0PTAsdC5oYXZlZGljdD0wLHQuZmxhZ3M9LTEsdC5kbWF4PTMyNzY4LHQuaGVhZD1udWxsLHQuaG9sZD0wLHQuYml0cz0wLHQubGVuY29kZT10LmxlbmR5bj1uZXcgSW50MzJBcnJheSg4NTIpLHQuZGlzdGNvZGU9dC5kaXN0ZHluPW5ldyBJbnQzMkFycmF5KDU5MiksdC5zYW5lPTEsdC5iYWNrPS0xLG19LHo9ZT0+e2lmKE4oZSkpcmV0dXJuIGc7Y29uc3QgdD1lLnN0YXRlO3JldHVybiB0LndzaXplPTAsdC53aGF2ZT0wLHQud25leHQ9MCxDKGUpfSxGPShlLHQpPT57bGV0IGk7aWYoTihlKSlyZXR1cm4gZztjb25zdCBuPWUuc3RhdGU7cmV0dXJuIHQ8MD8oaT0wLHQ9LXQpOihpPTUrKHQ+PjQpLHQ8NDgmJih0Jj0xNSkpLHQmJih0PDh8fHQ+MTUpP2c6KG51bGwhPT1uLndpbmRvdyYmbi53Yml0cyE9PXQmJihuLndpbmRvdz1udWxsKSxuLndyYXA9aSxuLndiaXRzPXQseihlKSl9LEw9KGUsdCk9PntpZighZSlyZXR1cm4gZztjb25zdCBpPW5ldyBCO2Uuc3RhdGU9aSxpLnN0cm09ZSxpLndpbmRvdz1udWxsLGkubW9kZT1FO2NvbnN0IG49RihlLHQpO3JldHVybiBuIT09bSYmKGUuc3RhdGU9bnVsbCksbn07bGV0IE0sSCxqPSEwO2NvbnN0IEs9ZT0+e2lmKGope009bmV3IEludDMyQXJyYXkoNTEyKSxIPW5ldyBJbnQzMkFycmF5KDMyKTtsZXQgdD0wO2Zvcig7dDwxNDQ7KWUubGVuc1t0KytdPTg7Zm9yKDt0PDI1NjspZS5sZW5zW3QrK109OTtmb3IoO3Q8MjgwOyllLmxlbnNbdCsrXT03O2Zvcig7dDwyODg7KWUubGVuc1t0KytdPTg7Zm9yKGMoMSxlLmxlbnMsMCwyODgsTSwwLGUud29yayx7Yml0czo5fSksdD0wO3Q8MzI7KWUubGVuc1t0KytdPTU7YygyLGUubGVucywwLDMyLEgsMCxlLndvcmsse2JpdHM6NX0pLGo9ITF9ZS5sZW5jb2RlPU0sZS5sZW5iaXRzPTksZS5kaXN0Y29kZT1ILGUuZGlzdGJpdHM9NX0sUD0oZSx0LGksbik9PntsZXQgYTtjb25zdCByPWUuc3RhdGU7cmV0dXJuIG51bGw9PT1yLndpbmRvdyYmKHIud3NpemU9MTw8ci53Yml0cyxyLnduZXh0PTAsci53aGF2ZT0wLHIud2luZG93PW5ldyBVaW50OEFycmF5KHIud3NpemUpKSxuPj1yLndzaXplPyhyLndpbmRvdy5zZXQodC5zdWJhcnJheShpLXIud3NpemUsaSksMCksci53bmV4dD0wLHIud2hhdmU9ci53c2l6ZSk6KGE9ci53c2l6ZS1yLnduZXh0LGE+biYmKGE9biksci53aW5kb3cuc2V0KHQuc3ViYXJyYXkoaS1uLGktbithKSxyLnduZXh0KSwobi09YSk/KHIud2luZG93LnNldCh0LnN1YmFycmF5KGktbixpKSwwKSxyLnduZXh0PW4sci53aGF2ZT1yLndzaXplKTooci53bmV4dCs9YSxyLnduZXh0PT09ci53c2l6ZSYmKHIud25leHQ9MCksci53aGF2ZTxyLndzaXplJiYoci53aGF2ZSs9YSkpKSwwfTt2YXIgWT17aW5mbGF0ZVJlc2V0OnosaW5mbGF0ZVJlc2V0MjpGLGluZmxhdGVSZXNldEtlZXA6QyxpbmZsYXRlSW5pdDplPT5MKGUsMTUpLGluZmxhdGVJbml0MjpMLGluZmxhdGU6KGUsaSk9PntsZXQgYSxvLHMsbCxkLGYsaCxCLEMseixGLEwsTSxILGosWSxHLFgsVyxxLEosUSxWPTA7Y29uc3QgJD1uZXcgVWludDhBcnJheSg0KTtsZXQgZWUsdGU7Y29uc3QgaWU9bmV3IFVpbnQ4QXJyYXkoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKTtpZihOKGUpfHwhZS5vdXRwdXR8fCFlLmlucHV0JiYwIT09ZS5hdmFpbF9pbilyZXR1cm4gZzthPWUuc3RhdGUsYS5tb2RlPT09QSYmKGEubW9kZT1aKSxkPWUubmV4dF9vdXQscz1lLm91dHB1dCxoPWUuYXZhaWxfb3V0LGw9ZS5uZXh0X2luLG89ZS5pbnB1dCxmPWUuYXZhaWxfaW4sQj1hLmhvbGQsQz1hLmJpdHMsej1mLEY9aCxRPW07ZTpmb3IoOzspc3dpdGNoKGEubW9kZSl7Y2FzZSBFOmlmKDA9PT1hLndyYXApe2EubW9kZT1aO2JyZWFrfWZvcig7QzwxNjspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKDImYS53cmFwJiYzNTYxNT09PUIpezA9PT1hLndiaXRzJiYoYS53Yml0cz0xNSksYS5jaGVjaz0wLCRbMF09MjU1JkIsJFsxXT1CPj4+OCYyNTUsYS5jaGVjaz1uKGEuY2hlY2ssJCwyLDApLEI9MCxDPTAsYS5tb2RlPTE2MTgxO2JyZWFrfWlmKGEuaGVhZCYmKGEuaGVhZC5kb25lPSExKSwhKDEmYS53cmFwKXx8KCgoMjU1JkIpPDw4KSsoQj4+OCkpJTMxKXtlLm1zZz0iaW5jb3JyZWN0IGhlYWRlciBjaGVjayIsYS5tb2RlPUQ7YnJlYWt9aWYoKDE1JkIpIT09eSl7ZS5tc2c9InVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIixhLm1vZGU9RDticmVha31pZihCPj4+PTQsQy09NCxKPTgrKDE1JkIpLDA9PT1hLndiaXRzJiYoYS53Yml0cz1KKSxKPjE1fHxKPmEud2JpdHMpe2UubXNnPSJpbnZhbGlkIHdpbmRvdyBzaXplIixhLm1vZGU9RDticmVha31hLmRtYXg9MTw8YS53Yml0cyxhLmZsYWdzPTAsZS5hZGxlcj1hLmNoZWNrPTEsYS5tb2RlPTUxMiZCPzE2MTg5OkEsQj0wLEM9MDticmVhaztjYXNlIDE2MTgxOmZvcig7QzwxNjspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKGEuZmxhZ3M9QiwoMjU1JmEuZmxhZ3MpIT09eSl7ZS5tc2c9InVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIixhLm1vZGU9RDticmVha31pZig1NzM0NCZhLmZsYWdzKXtlLm1zZz0idW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IixhLm1vZGU9RDticmVha31hLmhlYWQmJihhLmhlYWQudGV4dD1CPj44JjEpLDUxMiZhLmZsYWdzJiY0JmEud3JhcCYmKCRbMF09MjU1JkIsJFsxXT1CPj4+OCYyNTUsYS5jaGVjaz1uKGEuY2hlY2ssJCwyLDApKSxCPTAsQz0wLGEubW9kZT0xNjE4MjtjYXNlIDE2MTgyOmZvcig7QzwzMjspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWEuaGVhZCYmKGEuaGVhZC50aW1lPUIpLDUxMiZhLmZsYWdzJiY0JmEud3JhcCYmKCRbMF09MjU1JkIsJFsxXT1CPj4+OCYyNTUsJFsyXT1CPj4+MTYmMjU1LCRbM109Qj4+PjI0JjI1NSxhLmNoZWNrPW4oYS5jaGVjaywkLDQsMCkpLEI9MCxDPTAsYS5tb2RlPTE2MTgzO2Nhc2UgMTYxODM6Zm9yKDtDPDE2Oyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9YS5oZWFkJiYoYS5oZWFkLnhmbGFncz0yNTUmQixhLmhlYWQub3M9Qj4+OCksNTEyJmEuZmxhZ3MmJjQmYS53cmFwJiYoJFswXT0yNTUmQiwkWzFdPUI+Pj44JjI1NSxhLmNoZWNrPW4oYS5jaGVjaywkLDIsMCkpLEI9MCxDPTAsYS5tb2RlPTE2MTg0O2Nhc2UgMTYxODQ6aWYoMTAyNCZhLmZsYWdzKXtmb3IoO0M8MTY7KXtpZigwPT09ZilicmVhayBlO2YtLSxCKz1vW2wrK108PEMsQys9OH1hLmxlbmd0aD1CLGEuaGVhZCYmKGEuaGVhZC5leHRyYV9sZW49QiksNTEyJmEuZmxhZ3MmJjQmYS53cmFwJiYoJFswXT0yNTUmQiwkWzFdPUI+Pj44JjI1NSxhLmNoZWNrPW4oYS5jaGVjaywkLDIsMCkpLEI9MCxDPTB9ZWxzZSBhLmhlYWQmJihhLmhlYWQuZXh0cmE9bnVsbCk7YS5tb2RlPTE2MTg1O2Nhc2UgMTYxODU6aWYoMTAyNCZhLmZsYWdzJiYoTD1hLmxlbmd0aCxMPmYmJihMPWYpLEwmJihhLmhlYWQmJihKPWEuaGVhZC5leHRyYV9sZW4tYS5sZW5ndGgsYS5oZWFkLmV4dHJhfHwoYS5oZWFkLmV4dHJhPW5ldyBVaW50OEFycmF5KGEuaGVhZC5leHRyYV9sZW4pKSxhLmhlYWQuZXh0cmEuc2V0KG8uc3ViYXJyYXkobCxsK0wpLEopKSw1MTImYS5mbGFncyYmNCZhLndyYXAmJihhLmNoZWNrPW4oYS5jaGVjayxvLEwsbCkpLGYtPUwsbCs9TCxhLmxlbmd0aC09TCksYS5sZW5ndGgpKWJyZWFrIGU7YS5sZW5ndGg9MCxhLm1vZGU9MTYxODY7Y2FzZSAxNjE4NjppZigyMDQ4JmEuZmxhZ3Mpe2lmKDA9PT1mKWJyZWFrIGU7TD0wO2Rve0o9b1tsK0wrK10sYS5oZWFkJiZKJiZhLmxlbmd0aDw2NTUzNiYmKGEuaGVhZC5uYW1lKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEopKX13aGlsZShKJiZMPGYpO2lmKDUxMiZhLmZsYWdzJiY0JmEud3JhcCYmKGEuY2hlY2s9bihhLmNoZWNrLG8sTCxsKSksZi09TCxsKz1MLEopYnJlYWsgZX1lbHNlIGEuaGVhZCYmKGEuaGVhZC5uYW1lPW51bGwpO2EubGVuZ3RoPTAsYS5tb2RlPTE2MTg3O2Nhc2UgMTYxODc6aWYoNDA5NiZhLmZsYWdzKXtpZigwPT09ZilicmVhayBlO0w9MDtkb3tKPW9bbCtMKytdLGEuaGVhZCYmSiYmYS5sZW5ndGg8NjU1MzYmJihhLmhlYWQuY29tbWVudCs9U3RyaW5nLmZyb21DaGFyQ29kZShKKSl9d2hpbGUoSiYmTDxmKTtpZig1MTImYS5mbGFncyYmNCZhLndyYXAmJihhLmNoZWNrPW4oYS5jaGVjayxvLEwsbCkpLGYtPUwsbCs9TCxKKWJyZWFrIGV9ZWxzZSBhLmhlYWQmJihhLmhlYWQuY29tbWVudD1udWxsKTthLm1vZGU9MTYxODg7Y2FzZSAxNjE4ODppZig1MTImYS5mbGFncyl7Zm9yKDtDPDE2Oyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9aWYoNCZhLndyYXAmJkIhPT0oNjU1MzUmYS5jaGVjaykpe2UubXNnPSJoZWFkZXIgY3JjIG1pc21hdGNoIixhLm1vZGU9RDticmVha31CPTAsQz0wfWEuaGVhZCYmKGEuaGVhZC5oY3JjPWEuZmxhZ3M+PjkmMSxhLmhlYWQuZG9uZT0hMCksZS5hZGxlcj1hLmNoZWNrPTAsYS5tb2RlPUE7YnJlYWs7Y2FzZSAxNjE4OTpmb3IoO0M8MzI7KXtpZigwPT09ZilicmVhayBlO2YtLSxCKz1vW2wrK108PEMsQys9OH1lLmFkbGVyPWEuY2hlY2s9SShCKSxCPTAsQz0wLGEubW9kZT1SO2Nhc2UgUjppZigwPT09YS5oYXZlZGljdClyZXR1cm4gZS5uZXh0X291dD1kLGUuYXZhaWxfb3V0PWgsZS5uZXh0X2luPWwsZS5hdmFpbF9pbj1mLGEuaG9sZD1CLGEuYml0cz1DLF87ZS5hZGxlcj1hLmNoZWNrPTEsYS5tb2RlPUE7Y2FzZSBBOmlmKGk9PT13fHxpPT09YilicmVhayBlO2Nhc2UgWjppZihhLmxhc3Qpe0I+Pj49NyZDLEMtPTcmQyxhLm1vZGU9VTticmVha31mb3IoO0M8Mzspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fXN3aXRjaChhLmxhc3Q9MSZCLEI+Pj49MSxDLT0xLDMmQil7Y2FzZSAwOmEubW9kZT0xNjE5MzticmVhaztjYXNlIDE6aWYoSyhhKSxhLm1vZGU9VCxpPT09Yil7Qj4+Pj0yLEMtPTI7YnJlYWsgZX1icmVhaztjYXNlIDI6YS5tb2RlPTE2MTk2O2JyZWFrO2Nhc2UgMzplLm1zZz0iaW52YWxpZCBibG9jayB0eXBlIixhLm1vZGU9RH1CPj4+PTIsQy09MjticmVhaztjYXNlIDE2MTkzOmZvcihCPj4+PTcmQyxDLT03JkM7QzwzMjspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKCg2NTUzNSZCKSE9KEI+Pj4xNl42NTUzNSkpe2UubXNnPSJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIixhLm1vZGU9RDticmVha31pZihhLmxlbmd0aD02NTUzNSZCLEI9MCxDPTAsYS5tb2RlPVMsaT09PWIpYnJlYWsgZTtjYXNlIFM6YS5tb2RlPTE2MTk1O2Nhc2UgMTYxOTU6aWYoTD1hLmxlbmd0aCxMKXtpZihMPmYmJihMPWYpLEw+aCYmKEw9aCksMD09PUwpYnJlYWsgZTtzLnNldChvLnN1YmFycmF5KGwsbCtMKSxkKSxmLT1MLGwrPUwsaC09TCxkKz1MLGEubGVuZ3RoLT1MO2JyZWFrfWEubW9kZT1BO2JyZWFrO2Nhc2UgMTYxOTY6Zm9yKDtDPDE0Oyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9aWYoYS5ubGVuPTI1NysoMzEmQiksQj4+Pj01LEMtPTUsYS5uZGlzdD0xKygzMSZCKSxCPj4+PTUsQy09NSxhLm5jb2RlPTQrKDE1JkIpLEI+Pj49NCxDLT00LGEubmxlbj4yODZ8fGEubmRpc3Q+MzApe2UubXNnPSJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyIsYS5tb2RlPUQ7YnJlYWt9YS5oYXZlPTAsYS5tb2RlPTE2MTk3O2Nhc2UgMTYxOTc6Zm9yKDthLmhhdmU8YS5uY29kZTspe2Zvcig7QzwzOyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9YS5sZW5zW2llW2EuaGF2ZSsrXV09NyZCLEI+Pj49MyxDLT0zfWZvcig7YS5oYXZlPDE5OylhLmxlbnNbaWVbYS5oYXZlKytdXT0wO2lmKGEubGVuY29kZT1hLmxlbmR5bixhLmxlbmJpdHM9NyxlZT17Yml0czphLmxlbmJpdHN9LFE9YygwLGEubGVucywwLDE5LGEubGVuY29kZSwwLGEud29yayxlZSksYS5sZW5iaXRzPWVlLmJpdHMsUSl7ZS5tc2c9ImludmFsaWQgY29kZSBsZW5ndGhzIHNldCIsYS5tb2RlPUQ7YnJlYWt9YS5oYXZlPTAsYS5tb2RlPTE2MTk4O2Nhc2UgMTYxOTg6Zm9yKDthLmhhdmU8YS5ubGVuK2EubmRpc3Q7KXtmb3IoO1Y9YS5sZW5jb2RlW0ImKDE8PGEubGVuYml0cyktMV0saj1WPj4+MjQsWT1WPj4+MTYmMjU1LEc9NjU1MzUmViwhKGo8PUMpOyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9aWYoRzwxNilCPj4+PWosQy09aixhLmxlbnNbYS5oYXZlKytdPUc7ZWxzZXtpZigxNj09PUcpe2Zvcih0ZT1qKzI7Qzx0ZTspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKEI+Pj49aixDLT1qLDA9PT1hLmhhdmUpe2UubXNnPSJpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0IixhLm1vZGU9RDticmVha31KPWEubGVuc1thLmhhdmUtMV0sTD0zKygzJkIpLEI+Pj49MixDLT0yfWVsc2UgaWYoMTc9PT1HKXtmb3IodGU9aiszO0M8dGU7KXtpZigwPT09ZilicmVhayBlO2YtLSxCKz1vW2wrK108PEMsQys9OH1CPj4+PWosQy09aixKPTAsTD0zKyg3JkIpLEI+Pj49MyxDLT0zfWVsc2V7Zm9yKHRlPWorNztDPHRlOyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9Qj4+Pj1qLEMtPWosSj0wLEw9MTErKDEyNyZCKSxCPj4+PTcsQy09N31pZihhLmhhdmUrTD5hLm5sZW4rYS5uZGlzdCl7ZS5tc2c9ImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiLGEubW9kZT1EO2JyZWFrfWZvcig7TC0tOylhLmxlbnNbYS5oYXZlKytdPUp9fWlmKGEubW9kZT09PUQpYnJlYWs7aWYoMD09PWEubGVuc1syNTZdKXtlLm1zZz0iaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIixhLm1vZGU9RDticmVha31pZihhLmxlbmJpdHM9OSxlZT17Yml0czphLmxlbmJpdHN9LFE9YygxLGEubGVucywwLGEubmxlbixhLmxlbmNvZGUsMCxhLndvcmssZWUpLGEubGVuYml0cz1lZS5iaXRzLFEpe2UubXNnPSJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQiLGEubW9kZT1EO2JyZWFrfWlmKGEuZGlzdGJpdHM9NixhLmRpc3Rjb2RlPWEuZGlzdGR5bixlZT17Yml0czphLmRpc3RiaXRzfSxRPWMoMixhLmxlbnMsYS5ubGVuLGEubmRpc3QsYS5kaXN0Y29kZSwwLGEud29yayxlZSksYS5kaXN0Yml0cz1lZS5iaXRzLFEpe2UubXNnPSJpbnZhbGlkIGRpc3RhbmNlcyBzZXQiLGEubW9kZT1EO2JyZWFrfWlmKGEubW9kZT1ULGk9PT1iKWJyZWFrIGU7Y2FzZSBUOmEubW9kZT1PO2Nhc2UgTzppZihmPj02JiZoPj0yNTgpe2UubmV4dF9vdXQ9ZCxlLmF2YWlsX291dD1oLGUubmV4dF9pbj1sLGUuYXZhaWxfaW49ZixhLmhvbGQ9QixhLmJpdHM9QyxyKGUsRiksZD1lLm5leHRfb3V0LHM9ZS5vdXRwdXQsaD1lLmF2YWlsX291dCxsPWUubmV4dF9pbixvPWUuaW5wdXQsZj1lLmF2YWlsX2luLEI9YS5ob2xkLEM9YS5iaXRzLGEubW9kZT09PUEmJihhLmJhY2s9LTEpO2JyZWFrfWZvcihhLmJhY2s9MDtWPWEubGVuY29kZVtCJigxPDxhLmxlbmJpdHMpLTFdLGo9Vj4+PjI0LFk9Vj4+PjE2JjI1NSxHPTY1NTM1JlYsIShqPD1DKTspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKFkmJjA9PSgyNDAmWSkpe2ZvcihYPWosVz1ZLHE9RztWPWEubGVuY29kZVtxKygoQiYoMTw8WCtXKS0xKT4+WCldLGo9Vj4+PjI0LFk9Vj4+PjE2JjI1NSxHPTY1NTM1JlYsIShYK2o8PUMpOyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9Qj4+Pj1YLEMtPVgsYS5iYWNrKz1YfWlmKEI+Pj49aixDLT1qLGEuYmFjays9aixhLmxlbmd0aD1HLDA9PT1ZKXthLm1vZGU9MTYyMDU7YnJlYWt9aWYoMzImWSl7YS5iYWNrPS0xLGEubW9kZT1BO2JyZWFrfWlmKDY0Jlkpe2UubXNnPSJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiLGEubW9kZT1EO2JyZWFrfWEuZXh0cmE9MTUmWSxhLm1vZGU9MTYyMDE7Y2FzZSAxNjIwMTppZihhLmV4dHJhKXtmb3IodGU9YS5leHRyYTtDPHRlOyl7aWYoMD09PWYpYnJlYWsgZTtmLS0sQis9b1tsKytdPDxDLEMrPTh9YS5sZW5ndGgrPUImKDE8PGEuZXh0cmEpLTEsQj4+Pj1hLmV4dHJhLEMtPWEuZXh0cmEsYS5iYWNrKz1hLmV4dHJhfWEud2FzPWEubGVuZ3RoLGEubW9kZT0xNjIwMjtjYXNlIDE2MjAyOmZvcig7Vj1hLmRpc3Rjb2RlW0ImKDE8PGEuZGlzdGJpdHMpLTFdLGo9Vj4+PjI0LFk9Vj4+PjE2JjI1NSxHPTY1NTM1JlYsIShqPD1DKTspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWlmKDA9PSgyNDAmWSkpe2ZvcihYPWosVz1ZLHE9RztWPWEuZGlzdGNvZGVbcSsoKEImKDE8PFgrVyktMSk+PlgpXSxqPVY+Pj4yNCxZPVY+Pj4xNiYyNTUsRz02NTUzNSZWLCEoWCtqPD1DKTspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fUI+Pj49WCxDLT1YLGEuYmFjays9WH1pZihCPj4+PWosQy09aixhLmJhY2srPWosNjQmWSl7ZS5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsYS5tb2RlPUQ7YnJlYWt9YS5vZmZzZXQ9RyxhLmV4dHJhPTE1JlksYS5tb2RlPTE2MjAzO2Nhc2UgMTYyMDM6aWYoYS5leHRyYSl7Zm9yKHRlPWEuZXh0cmE7Qzx0ZTspe2lmKDA9PT1mKWJyZWFrIGU7Zi0tLEIrPW9bbCsrXTw8QyxDKz04fWEub2Zmc2V0Kz1CJigxPDxhLmV4dHJhKS0xLEI+Pj49YS5leHRyYSxDLT1hLmV4dHJhLGEuYmFjays9YS5leHRyYX1pZihhLm9mZnNldD5hLmRtYXgpe2UubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPUQ7YnJlYWt9YS5tb2RlPTE2MjA0O2Nhc2UgMTYyMDQ6aWYoMD09PWgpYnJlYWsgZTtpZihMPUYtaCxhLm9mZnNldD5MKXtpZihMPWEub2Zmc2V0LUwsTD5hLndoYXZlJiZhLnNhbmUpe2UubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsYS5tb2RlPUQ7YnJlYWt9TD5hLnduZXh0PyhMLT1hLnduZXh0LE09YS53c2l6ZS1MKTpNPWEud25leHQtTCxMPmEubGVuZ3RoJiYoTD1hLmxlbmd0aCksSD1hLndpbmRvd31lbHNlIEg9cyxNPWQtYS5vZmZzZXQsTD1hLmxlbmd0aDtMPmgmJihMPWgpLGgtPUwsYS5sZW5ndGgtPUw7ZG97c1tkKytdPUhbTSsrXX13aGlsZSgtLUwpOzA9PT1hLmxlbmd0aCYmKGEubW9kZT1PKTticmVhaztjYXNlIDE2MjA1OmlmKDA9PT1oKWJyZWFrIGU7c1tkKytdPWEubGVuZ3RoLGgtLSxhLm1vZGU9TzticmVhaztjYXNlIFU6aWYoYS53cmFwKXtmb3IoO0M8MzI7KXtpZigwPT09ZilicmVhayBlO2YtLSxCfD1vW2wrK108PEMsQys9OH1pZihGLT1oLGUudG90YWxfb3V0Kz1GLGEudG90YWwrPUYsNCZhLndyYXAmJkYmJihlLmFkbGVyPWEuY2hlY2s9YS5mbGFncz9uKGEuY2hlY2sscyxGLGQtRik6dChhLmNoZWNrLHMsRixkLUYpKSxGPWgsNCZhLndyYXAmJihhLmZsYWdzP0I6SShCKSkhPT1hLmNoZWNrKXtlLm1zZz0iaW5jb3JyZWN0IGRhdGEgY2hlY2siLGEubW9kZT1EO2JyZWFrfUI9MCxDPTB9YS5tb2RlPTE2MjA3O2Nhc2UgMTYyMDc6aWYoYS53cmFwJiZhLmZsYWdzKXtmb3IoO0M8MzI7KXtpZigwPT09ZilicmVhayBlO2YtLSxCKz1vW2wrK108PEMsQys9OH1pZig0JmEud3JhcCYmQiE9PSg0Mjk0OTY3Mjk1JmEudG90YWwpKXtlLm1zZz0iaW5jb3JyZWN0IGxlbmd0aCBjaGVjayIsYS5tb2RlPUQ7YnJlYWt9Qj0wLEM9MH1hLm1vZGU9MTYyMDg7Y2FzZSAxNjIwODpRPWs7YnJlYWsgZTtjYXNlIEQ6UT1wO2JyZWFrIGU7Y2FzZSAxNjIxMDpyZXR1cm4gdjtkZWZhdWx0OnJldHVybiBnfXJldHVybiBlLm5leHRfb3V0PWQsZS5hdmFpbF9vdXQ9aCxlLm5leHRfaW49bCxlLmF2YWlsX2luPWYsYS5ob2xkPUIsYS5iaXRzPUMsKGEud3NpemV8fEYhPT1lLmF2YWlsX291dCYmYS5tb2RlPEQmJihhLm1vZGU8VXx8aSE9PXUpKSYmUChlLGUub3V0cHV0LGUubmV4dF9vdXQsRi1lLmF2YWlsX291dCksei09ZS5hdmFpbF9pbixGLT1lLmF2YWlsX291dCxlLnRvdGFsX2luKz16LGUudG90YWxfb3V0Kz1GLGEudG90YWwrPUYsNCZhLndyYXAmJkYmJihlLmFkbGVyPWEuY2hlY2s9YS5mbGFncz9uKGEuY2hlY2sscyxGLGUubmV4dF9vdXQtRik6dChhLmNoZWNrLHMsRixlLm5leHRfb3V0LUYpKSxlLmRhdGFfdHlwZT1hLmJpdHMrKGEubGFzdD82NDowKSsoYS5tb2RlPT09QT8xMjg6MCkrKGEubW9kZT09PVR8fGEubW9kZT09PVM/MjU2OjApLCgwPT09eiYmMD09PUZ8fGk9PT11KSYmUT09PW0mJihRPXgpLFF9LGluZmxhdGVFbmQ6ZT0+e2lmKE4oZSkpcmV0dXJuIGc7bGV0IHQ9ZS5zdGF0ZTtyZXR1cm4gdC53aW5kb3cmJih0LndpbmRvdz1udWxsKSxlLnN0YXRlPW51bGwsbX0saW5mbGF0ZUdldEhlYWRlcjooZSx0KT0+e2lmKE4oZSkpcmV0dXJuIGc7Y29uc3QgaT1lLnN0YXRlO3JldHVybiAwPT0oMiZpLndyYXApP2c6KGkuaGVhZD10LHQuZG9uZT0hMSxtKX0saW5mbGF0ZVNldERpY3Rpb25hcnk6KGUsaSk9Pntjb25zdCBuPWkubGVuZ3RoO2xldCBhLHIsbztyZXR1cm4gTihlKT9nOihhPWUuc3RhdGUsMCE9PWEud3JhcCYmYS5tb2RlIT09Uj9nOmEubW9kZT09PVImJihyPTEscj10KHIsaSxuLDApLHIhPT1hLmNoZWNrKT9wOihvPVAoZSxpLG4sbiksbz8oYS5tb2RlPTE2MjEwLHYpOihhLmhhdmVkaWN0PTEsbSkpKX0saW5mbGF0ZUluZm86InBha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCkifTtjb25zdCBHPShlLHQpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KTt2YXIgWD1mdW5jdGlvbihlKXtjb25zdCB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtmb3IoO3QubGVuZ3RoOyl7Y29uc3QgaT10LnNoaWZ0KCk7aWYoaSl7aWYoIm9iamVjdCIhPXR5cGVvZiBpKXRocm93IG5ldyBUeXBlRXJyb3IoaSsibXVzdCBiZSBub24tb2JqZWN0Iik7Zm9yKGNvbnN0IHQgaW4gaSlHKGksdCkmJihlW3RdPWlbdF0pfX1yZXR1cm4gZX0sVz1lPT57bGV0IHQ9MDtmb3IobGV0IGk9MCxuPWUubGVuZ3RoO2k8bjtpKyspdCs9ZVtpXS5sZW5ndGg7Y29uc3QgaT1uZXcgVWludDhBcnJheSh0KTtmb3IobGV0IHQ9MCxuPTAsYT1lLmxlbmd0aDt0PGE7dCsrKXtsZXQgYT1lW3RdO2kuc2V0KGEsbiksbis9YS5sZW5ndGh9cmV0dXJuIGl9O2xldCBxPSEwO3RyeXtTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpfWNhdGNoKGUpe3E9ITF9Y29uc3QgSj1uZXcgVWludDhBcnJheSgyNTYpO2ZvcihsZXQgZT0wO2U8MjU2O2UrKylKW2VdPWU+PTI1Mj82OmU+PTI0OD81OmU+PTI0MD80OmU+PTIyND8zOmU+PTE5Mj8yOjE7SlsyNTRdPUpbMjU0XT0xO3ZhciBRPWU9PntpZigiZnVuY3Rpb24iPT10eXBlb2YgVGV4dEVuY29kZXImJlRleHRFbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUpcmV0dXJuKG5ldyBUZXh0RW5jb2RlcikuZW5jb2RlKGUpO2xldCB0LGksbixhLHIsbz1lLmxlbmd0aCxzPTA7Zm9yKGE9MDthPG87YSsrKWk9ZS5jaGFyQ29kZUF0KGEpLDU1Mjk2PT0oNjQ1MTImaSkmJmErMTxvJiYobj1lLmNoYXJDb2RlQXQoYSsxKSw1NjMyMD09KDY0NTEyJm4pJiYoaT02NTUzNisoaS01NTI5Njw8MTApKyhuLTU2MzIwKSxhKyspKSxzKz1pPDEyOD8xOmk8MjA0OD8yOmk8NjU1MzY/Mzo0O2Zvcih0PW5ldyBVaW50OEFycmF5KHMpLHI9MCxhPTA7cjxzO2ErKylpPWUuY2hhckNvZGVBdChhKSw1NTI5Nj09KDY0NTEyJmkpJiZhKzE8byYmKG49ZS5jaGFyQ29kZUF0KGErMSksNTYzMjA9PSg2NDUxMiZuKSYmKGk9NjU1MzYrKGktNTUyOTY8PDEwKSsobi01NjMyMCksYSsrKSksaTwxMjg/dFtyKytdPWk6aTwyMDQ4Pyh0W3IrK109MTkyfGk+Pj42LHRbcisrXT0xMjh8NjMmaSk6aTw2NTUzNj8odFtyKytdPTIyNHxpPj4+MTIsdFtyKytdPTEyOHxpPj4+NiY2Myx0W3IrK109MTI4fDYzJmkpOih0W3IrK109MjQwfGk+Pj4xOCx0W3IrK109MTI4fGk+Pj4xMiY2Myx0W3IrK109MTI4fGk+Pj42JjYzLHRbcisrXT0xMjh8NjMmaSk7cmV0dXJuIHR9LFY9KGUsdCk9Pntjb25zdCBpPXR8fGUubGVuZ3RoO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBUZXh0RGVjb2RlciYmVGV4dERlY29kZXIucHJvdG90eXBlLmRlY29kZSlyZXR1cm4obmV3IFRleHREZWNvZGVyKS5kZWNvZGUoZS5zdWJhcnJheSgwLHQpKTtsZXQgbixhO2NvbnN0IHI9bmV3IEFycmF5KDIqaSk7Zm9yKGE9MCxuPTA7bjxpOyl7bGV0IHQ9ZVtuKytdO2lmKHQ8MTI4KXtyW2ErK109dDtjb250aW51ZX1sZXQgbz1KW3RdO2lmKG8+NClyW2ErK109NjU1MzMsbis9by0xO2Vsc2V7Zm9yKHQmPTI9PT1vPzMxOjM9PT1vPzE1Ojc7bz4xJiZuPGk7KXQ9dDw8Nnw2MyZlW24rK10sby0tO28+MT9yW2ErK109NjU1MzM6dDw2NTUzNj9yW2ErK109dDoodC09NjU1MzYsclthKytdPTU1Mjk2fHQ+PjEwJjEwMjMsclthKytdPTU2MzIwfDEwMjMmdCl9fXJldHVybigoZSx0KT0+e2lmKHQ8NjU1MzQmJmUuc3ViYXJyYXkmJnEpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxlLmxlbmd0aD09PXQ/ZTplLnN1YmFycmF5KDAsdCkpO2xldCBpPSIiO2ZvcihsZXQgbj0wO248dDtuKyspaSs9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKTtyZXR1cm4gaX0pKHIsYSl9LCQ9KGUsdCk9PnsodD10fHxlLmxlbmd0aCk+ZS5sZW5ndGgmJih0PWUubGVuZ3RoKTtsZXQgaT10LTE7Zm9yKDtpPj0wJiYxMjg9PSgxOTImZVtpXSk7KWktLTtyZXR1cm4gaTwwfHwwPT09aT90OmkrSltlW2ldXT50P2k6dH0sZWU9ezI6Im5lZWQgZGljdGlvbmFyeSIsMToic3RyZWFtIGVuZCIsMDoiIiwiLTEiOiJmaWxlIGVycm9yIiwiLTIiOiJzdHJlYW0gZXJyb3IiLCItMyI6ImRhdGEgZXJyb3IiLCItNCI6Imluc3VmZmljaWVudCBtZW1vcnkiLCItNSI6ImJ1ZmZlciBlcnJvciIsIi02IjoiaW5jb21wYXRpYmxlIHZlcnNpb24ifTt2YXIgdGU9ZnVuY3Rpb24oKXt0aGlzLmlucHV0PW51bGwsdGhpcy5uZXh0X2luPTAsdGhpcy5hdmFpbF9pbj0wLHRoaXMudG90YWxfaW49MCx0aGlzLm91dHB1dD1udWxsLHRoaXMubmV4dF9vdXQ9MCx0aGlzLmF2YWlsX291dD0wLHRoaXMudG90YWxfb3V0PTAsdGhpcy5tc2c9IiIsdGhpcy5zdGF0ZT1udWxsLHRoaXMuZGF0YV90eXBlPTIsdGhpcy5hZGxlcj0wfTt2YXIgaWU9ZnVuY3Rpb24oKXt0aGlzLnRleHQ9MCx0aGlzLnRpbWU9MCx0aGlzLnhmbGFncz0wLHRoaXMub3M9MCx0aGlzLmV4dHJhPW51bGwsdGhpcy5leHRyYV9sZW49MCx0aGlzLm5hbWU9IiIsdGhpcy5jb21tZW50PSIiLHRoaXMuaGNyYz0wLHRoaXMuZG9uZT0hMX07Y29uc3QgbmU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyx7Wl9OT19GTFVTSDphZSxaX0ZJTklTSDpyZSxaX09LOm9lLFpfU1RSRUFNX0VORDpzZSxaX05FRURfRElDVDpsZSxaX1NUUkVBTV9FUlJPUjpkZSxaX0RBVEFfRVJST1I6ZmUsWl9NRU1fRVJST1I6Y2V9PWg7ZnVuY3Rpb24gaGUoZSl7dGhpcy5vcHRpb25zPVgoe2NodW5rU2l6ZTo2NTUzNix3aW5kb3dCaXRzOjE1LHRvOiIifSxlfHx7fSk7Y29uc3QgdD10aGlzLm9wdGlvbnM7dC5yYXcmJnQud2luZG93Qml0cz49MCYmdC53aW5kb3dCaXRzPDE2JiYodC53aW5kb3dCaXRzPS10LndpbmRvd0JpdHMsMD09PXQud2luZG93Qml0cyYmKHQud2luZG93Qml0cz0tMTUpKSwhKHQud2luZG93Qml0cz49MCYmdC53aW5kb3dCaXRzPDE2KXx8ZSYmZS53aW5kb3dCaXRzfHwodC53aW5kb3dCaXRzKz0zMiksdC53aW5kb3dCaXRzPjE1JiZ0LndpbmRvd0JpdHM8NDgmJjA9PSgxNSZ0LndpbmRvd0JpdHMpJiYodC53aW5kb3dCaXRzfD0xNSksdGhpcy5lcnI9MCx0aGlzLm1zZz0iIix0aGlzLmVuZGVkPSExLHRoaXMuY2h1bmtzPVtdLHRoaXMuc3RybT1uZXcgdGUsdGhpcy5zdHJtLmF2YWlsX291dD0wO2xldCBpPVkuaW5mbGF0ZUluaXQyKHRoaXMuc3RybSx0LndpbmRvd0JpdHMpO2lmKGkhPT1vZSl0aHJvdyBuZXcgRXJyb3IoZWVbaV0pO2lmKHRoaXMuaGVhZGVyPW5ldyBpZSxZLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLHRoaXMuaGVhZGVyKSx0LmRpY3Rpb25hcnkmJigic3RyaW5nIj09dHlwZW9mIHQuZGljdGlvbmFyeT90LmRpY3Rpb25hcnk9USh0LmRpY3Rpb25hcnkpOiJbb2JqZWN0IEFycmF5QnVmZmVyXSI9PT1uZS5jYWxsKHQuZGljdGlvbmFyeSkmJih0LmRpY3Rpb25hcnk9bmV3IFVpbnQ4QXJyYXkodC5kaWN0aW9uYXJ5KSksdC5yYXcmJihpPVkuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLHQuZGljdGlvbmFyeSksaSE9PW9lKSkpdGhyb3cgbmV3IEVycm9yKGVlW2ldKX1mdW5jdGlvbiB1ZShlLHQpe2NvbnN0IGk9bmV3IGhlKHQpO2lmKGkucHVzaChlKSxpLmVycil0aHJvdyBpLm1zZ3x8ZWVbaS5lcnJdO3JldHVybiBpLnJlc3VsdH1oZS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe2NvbnN0IGk9dGhpcy5zdHJtLG49dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxhPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O2xldCByLG8scztpZih0aGlzLmVuZGVkKXJldHVybiExO2ZvcihvPXQ9PT1+fnQ/dDohMD09PXQ/cmU6YWUsIltvYmplY3QgQXJyYXlCdWZmZXJdIj09PW5lLmNhbGwoZSk/aS5pbnB1dD1uZXcgVWludDhBcnJheShlKTppLmlucHV0PWUsaS5uZXh0X2luPTAsaS5hdmFpbF9pbj1pLmlucHV0Lmxlbmd0aDs7KXtmb3IoMD09PWkuYXZhaWxfb3V0JiYoaS5vdXRwdXQ9bmV3IFVpbnQ4QXJyYXkobiksaS5uZXh0X291dD0wLGkuYXZhaWxfb3V0PW4pLHI9WS5pbmZsYXRlKGksbykscj09PWxlJiZhJiYocj1ZLmluZmxhdGVTZXREaWN0aW9uYXJ5KGksYSkscj09PW9lP3I9WS5pbmZsYXRlKGksbyk6cj09PWZlJiYocj1sZSkpO2kuYXZhaWxfaW4+MCYmcj09PXNlJiZpLnN0YXRlLndyYXA+MCYmMCE9PWVbaS5uZXh0X2luXTspWS5pbmZsYXRlUmVzZXQoaSkscj1ZLmluZmxhdGUoaSxvKTtzd2l0Y2gocil7Y2FzZSBkZTpjYXNlIGZlOmNhc2UgbGU6Y2FzZSBjZTpyZXR1cm4gdGhpcy5vbkVuZChyKSx0aGlzLmVuZGVkPSEwLCExfWlmKHM9aS5hdmFpbF9vdXQsaS5uZXh0X291dCYmKDA9PT1pLmF2YWlsX291dHx8cj09PXNlKSlpZigic3RyaW5nIj09PXRoaXMub3B0aW9ucy50byl7bGV0IGU9JChpLm91dHB1dCxpLm5leHRfb3V0KSx0PWkubmV4dF9vdXQtZSxhPVYoaS5vdXRwdXQsZSk7aS5uZXh0X291dD10LGkuYXZhaWxfb3V0PW4tdCx0JiZpLm91dHB1dC5zZXQoaS5vdXRwdXQuc3ViYXJyYXkoZSxlK3QpLDApLHRoaXMub25EYXRhKGEpfWVsc2UgdGhpcy5vbkRhdGEoaS5vdXRwdXQubGVuZ3RoPT09aS5uZXh0X291dD9pLm91dHB1dDppLm91dHB1dC5zdWJhcnJheSgwLGkubmV4dF9vdXQpKTtpZihyIT09b2V8fDAhPT1zKXtpZihyPT09c2UpcmV0dXJuIHI9WS5pbmZsYXRlRW5kKHRoaXMuc3RybSksdGhpcy5vbkVuZChyKSx0aGlzLmVuZGVkPSEwLCEwO2lmKDA9PT1pLmF2YWlsX2luKWJyZWFrfX1yZXR1cm4hMH0saGUucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihlKXt0aGlzLmNodW5rcy5wdXNoKGUpfSxoZS5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24oZSl7ZT09PW9lJiYoInN0cmluZyI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbigiIik6dGhpcy5yZXN1bHQ9Vyh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPWUsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ307dmFyIHdlPWhlLGJlPXVlLG1lPWZ1bmN0aW9uKGUsdCl7cmV0dXJuKHQ9dHx8e30pLnJhdz0hMCx1ZShlLHQpfSxrZT11ZSxfZT1oLGdlPXtJbmZsYXRlOndlLGluZmxhdGU6YmUsaW5mbGF0ZVJhdzptZSx1bmd6aXA6a2UsY29uc3RhbnRzOl9lfTtlLkluZmxhdGU9d2UsZS5jb25zdGFudHM9X2UsZS5kZWZhdWx0PWdlLGUuaW5mbGF0ZT1iZSxlLmluZmxhdGVSYXc9bWUsZS51bmd6aXA9a2UsT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSkpOwo=, `';\n` + baseSource];
            const combined = blobParts.join('');
            const blob = new Blob([combined], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }
        const state = {
            provider: null,
            providerMetadata: {},
            folder: null,
            files: new Map(),
            metadataCache: new Map(),
            flushPromises: new Map(),
            flushCounter: 0,
            currentFile: null
        };

        function showScreen(active) {
            const screens = [dom.providerScreen, dom.authScreen, dom.folderScreen, dom.loadingScreen, dom.appContainer];
            for (const screen of screens) {
                if (!screen) { continue; }
                if (screen === active) {
                    screen.classList.remove('hidden');
                } else {
                    screen.classList.add('hidden');
                }
            }
        }

        function showStatus(message, variant = 'info', duration = 2000) {
            dom.statusBar.textContent = message;
            dom.statusBar.className = `status-bar show ${variant === 'success' ? 'success' : variant === 'error' ? 'error' : ''}`;
            if (duration) {
                setTimeout(() => dom.statusBar.classList.remove('show'), duration);
            }
        }

        function updateMetadataFields(metadata = {}) {
            document.getElementById('title-input').value = metadata.title || '';
            document.getElementById('tags-input').value = Array.isArray(metadata.tags) ? metadata.tags.join(', ') : (metadata.tags || '');
            document.getElementById('rating-input').value = metadata.rating ?? '';
            document.getElementById('notes-input').value = metadata.notes || '';
            dom.selectedFilePill.textContent = state.currentFile ? state.currentFile.name : 'No file loaded';
            dom.selectedProviderPill.textContent = state.provider ? state.provider.toUpperCase() : '‚Äî';
        }

        async function enqueueOperation({ provider, fileId, type, payload, critical = false }) {
            const entry = await dbManager.updateQueueEntry(provider, fileId, { type, payload, queuedAt: Date.now() });
            diagnostics.log('queue', `Enqueued ${type} for ${provider}:${fileId}`, { operations: entry.operations.length, critical });
            syncWorker.postMessage({ type: 'queueUpdated', payload: { provider, fileId, critical } });
            if (critical) {
                showStatus('Critical change queued', 'info', 1200);
            }
        }

        const commitMetadataUpdate = async ({ fileId, provider, changes }) => {
            await dbManager.saveMetadataBatch([{ id: fileId, provider, metadata: changes, localUpdatedAt: Date.now(), pendingOps: 1 }]);
            await enqueueOperation({ provider, fileId, type: 'updateMetadata', payload: changes });
        };

        const debouncedMetadataUpdate = debounce(commitMetadataUpdate, DEBOUNCE_MS);

        async function queueMetadataUpdate(details, options = {}) {
            if (options.critical) {
                return commitMetadataUpdate(details);
            }
            return debouncedMetadataUpdate(details);
        }

        const mockFolders = [
            { id: 'folder-launch', name: 'Launch Prep', provider: 'onedrive', count: 128, updatedAt: 'Just now', estimatedBytes: 24_000_000 },
            { id: 'folder-triage', name: 'Triage Queue', provider: 'gdrive', count: 64, updatedAt: '2h ago', estimatedBytes: 16_000_000 }
        ];

        const mockFilesByFolder = new Map([
            ['folder-launch', [
                { id: 'launch-01', name: 'IMG_0001.PNG', provider: 'onedrive', estimatedBytes: 2_400_000 },
                { id: 'launch-02', name: 'IMG_0002.PNG', provider: 'onedrive', estimatedBytes: 2_200_000 }
            ]],
            ['folder-triage', [
                { id: 'triage-01', name: 'Capture_3021.PNG', provider: 'gdrive', estimatedBytes: 1_800_000 },
                { id: 'triage-02', name: 'Capture_3022.PNG', provider: 'gdrive', estimatedBytes: 1_700_000 }
            ]]
        ]);

        function renderFolders() {
            dom.folderList.innerHTML = '';
            for (const folder of mockFolders) {
                const item = document.createElement('div');
                item.className = 'folder-item';
                item.innerHTML = `<div><div class="folder-name">${folder.name}</div><div class="folder-meta">${folder.count} items ‚Ä¢ ${folder.updatedAt}</div></div><div>‚Ä∫</div>`;
                item.addEventListener('click', async () => {
                    state.folder = folder;
                    dom.currentFolderPill.textContent = folder.name;
                    await dbManager.touchCache('folderCache', { id: folder.id, provider: folder.provider, estimatedBytes: folder.estimatedBytes, data: { count: folder.count } });
                    diagnostics.log('ui', 'Folder selected', { folder: folder.id, provider: folder.provider });
                    showScreen(dom.loadingScreen);
                    dom.loadingStatus.textContent = 'Loading folder manifest‚Ä¶';
                    await new Promise(resolve => setTimeout(resolve, 400));
                    loadFilesForFolder(folder);
                });
                dom.folderList.appendChild(item);
            }
        }

        async function loadFilesForFolder(folder) {
            const files = mockFilesByFolder.get(folder.id) || [];
            state.files = new Map(files.map(file => [file.id, file]));
            dom.fileSelector.innerHTML = '';
            dom.fileSelector.append(new Option('Select a file', ''));
            for (const file of files) {
                dom.fileSelector.append(new Option(file.name, file.id));
                await dbManager.touchCache('pngText', { id: file.id, provider: file.provider, estimatedBytes: file.estimatedBytes, pendingOps: 0 });
            }
            showScreen(dom.appContainer);
            dom.viewerPlaceholder.textContent = 'Choose a file to begin triage.';
            showStatus('Folder cached locally', 'success');
        }

        async function selectFile(fileId) {
            if (!fileId) {
                state.currentFile = null;
                updateMetadataFields();
                return;
            }
            const file = state.files.get(fileId);
            if (!file) { return; }
            state.currentFile = file;
            dom.selectedFilePill.textContent = file.name;
            dom.selectedProviderPill.textContent = file.provider.toUpperCase();
            await dbManager.touchCache('pngText', { id: file.id, provider: file.provider, estimatedBytes: file.estimatedBytes });
            const db = await dbManager.open();
            const tx = db.transaction(['metadata'], 'readonly');
            const store = tx.objectStore('metadata');
            const record = await new Promise((resolve, reject) => {
                const request = store.get(file.id);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => reject(request.error);
            });
            await new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
            const metadata = record ? record.metadata : {};
            state.metadataCache.set(file.id, metadata);
            updateMetadataFields(metadata);
            diagnostics.log('ui', 'File selected', { fileId: file.id, provider: file.provider });
        }

        async function requestWorkerFlush(reason) {
            const flushId = `ui-${Date.now()}-${(++state.flushCounter).toString(16)}`;
            diagnostics.log('flush', `Requesting worker flush (${reason})`, { flushId });
            const promise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    diagnostics.log('flush', 'Flush request timed out', { flushId });
                    state.flushPromises.delete(flushId);
                    reject(new Error('flush timeout'));
                }, 12000);
                state.flushPromises.set(flushId, { resolve, reject, timeout });
            });
            syncWorker.postMessage({ type: 'flushRequest', payload: { flushId, reason } });
            return promise;
        }

        async function initializeLifecycleGuards() {
            const handler = async (event) => {
                if (document.visibilityState === 'hidden' || event.type !== 'visibilitychange') {
                    try {
                        await requestWorkerFlush(event.type);
                    } catch (error) {
                        diagnostics.log('flush', 'Lifecycle flush failed', { reason: event.type, error: error.message });
                    }
                }
            };
            document.addEventListener('visibilitychange', handler);
            window.addEventListener('pagehide', handler);
            const beforeUnloadHandler = (event) => {
                event.preventDefault();
                event.returnValue = '';
                requestWorkerFlush('beforeunload').finally(() => {
                    window.removeEventListener('beforeunload', beforeUnloadHandler);
                });
            };
            window.addEventListener('beforeunload', beforeUnloadHandler);
        }

        function wireDiagnosticsModal() {
            dom.openDiagnostics.addEventListener('click', () => {
                dom.diagnosticsModal.classList.add('active');
            });
            dom.diagnosticsClose.addEventListener('click', () => {
                dom.diagnosticsModal.classList.remove('active');
            });
            dom.diagnosticsCopy.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText(diagnostics.export());
                    showStatus('Diagnostics copied', 'success');
                } catch (error) {
                    showStatus('Clipboard unavailable', 'error');
                }
            });
            dom.diagnosticsDownload.addEventListener('click', () => {
                const blob = new Blob([diagnostics.export()], { type: 'text/plain' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `orbital8-diagnostics-${Date.now()}.txt`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            });
        }

        function bindUI(dbManager) {
            document.querySelectorAll('.provider-button').forEach(button => {
                button.addEventListener('click', () => {
                    const provider = button.dataset.provider;
                    state.provider = provider;
                    diagnostics.log('auth', 'Provider selected', { provider });
                    showScreen(dom.authScreen);
                    dom.authStatus.textContent = 'Simulating auth handshake‚Ä¶';
                    setTimeout(() => {
                        showScreen(dom.folderScreen);
                        renderFolders();
                    }, 600);
                });
            });

            if (dom.folderBack) {
                dom.folderBack.addEventListener('click', () => {
                    showScreen(dom.providerScreen);
                });
            }

            if (dom.backToFolders) {
                dom.backToFolders.addEventListener('click', () => {
                    showScreen(dom.folderScreen);
                });
            }

            if (dom.folderRefresh) {
                dom.folderRefresh.addEventListener('click', () => {
                    diagnostics.log('ui', 'Folder list refreshed');
                    renderFolders();
                });
            }

            dom.fileSelector.addEventListener('change', (event) => {
                selectFile(event.target.value);
            });

            dom.saveButton.addEventListener('click', async () => {
                if (!state.currentFile) { return; }
                const changes = collectMetadataFromInputs();
                await queueMetadataUpdate({ fileId: state.currentFile.id, provider: state.currentFile.provider, changes });
                showStatus('Metadata queued for sync', 'success');
            });

            dom.favoriteToggle.addEventListener('click', async () => {
                if (!state.currentFile) { return; }
                const current = state.metadataCache.get(state.currentFile.id) || {};
                const favorite = !current.favorite;
                current.favorite = favorite;
                updateMetadataFields(current);
                await queueMetadataUpdate({ fileId: state.currentFile.id, provider: state.currentFile.provider, changes: { favorite } }, { critical: true });
            });

            dom.deleteButton.addEventListener('click', async () => {
                if (!state.currentFile) { return; }
                await enqueueOperation({ provider: state.currentFile.provider, fileId: state.currentFile.id, type: 'deleteFile', payload: { when: Date.now() }, critical: true });
                showStatus('File queued for deletion', 'error');
            });

            ['title-input', 'tags-input', 'rating-input', 'notes-input'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (!state.currentFile) { return; }
                    const metadata = collectMetadataFromInputs();
                    state.metadataCache.set(state.currentFile.id, metadata);
                });
            });
        }

        function collectMetadataFromInputs() {
            const title = document.getElementById('title-input').value.trim();
            const tagsValue = document.getElementById('tags-input').value.trim();
            const tags = tagsValue ? tagsValue.split(',').map(tag => tag.trim()).filter(Boolean) : [];
            const ratingValue = document.getElementById('rating-input').value;
            const rating = ratingValue === '' ? null : Number(ratingValue);
            const notes = document.getElementById('notes-input').value;
            const favorite = (state.metadataCache.get(state.currentFile?.id || '') || {}).favorite || false;
            return { title, tags, rating, notes, favorite };
        }

        const dbManager = new DBManager(DB_NAME, DB_VERSION, (scope, message, details) => diagnostics.log(scope, message, details));
        let syncWorker;
        let pngWorker;

        async function bootstrap() {
            await dbManager.ready;
            syncWorker = createSyncWorker();
            pngWorker = createPngWorker();
            syncWorker.onmessage = (event) => {
                const { type, payload } = event.data || {};
                if (type === 'diagnostic') {
                    const info = payload || {};
                    diagnostics.log(info.scope || 'worker', info.message || '', info.details || null);
                }
                if (type === 'flushAccepted') {
                    const slot = state.flushPromises.get(payload.flushId);
                    if (slot) {
                        diagnostics.log('flush', 'Worker accepted flush', { flushId: payload.flushId });
                    }
                }
                if (type === 'flushComplete') {
                    const slot = state.flushPromises.get(payload.flushId);
                    if (slot) {
                        clearTimeout(slot.timeout);
                        slot.resolve();
                        state.flushPromises.delete(payload.flushId);
                        diagnostics.log('flush', 'Worker completed flush', { flushId: payload.flushId });
                    }
                }
            };

            pngWorker.onmessage = (event) => {
                const { type, payload } = event.data || {};
                if (type === 'diagnostic') {
                    const info = payload || {};
                    diagnostics.log(info.scope || 'png', info.message || '', info.details || null);
                }
                if (type === 'extractComplete') {
                    diagnostics.log('png', 'PNG text cached', payload);
                }
            };

            wireDiagnosticsModal();
            bindUI(dbManager);
            initializeLifecycleGuards();
            renderFolders();
            diagnostics.log('app', 'Bootstrap complete');
        }

        bootstrap();
    </script>
</body>
</html>
